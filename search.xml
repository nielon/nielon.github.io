<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BOOL 和 bool（C++ 的） 和 _Bool（C 的）</title>
    <url>/2017/03/07/BooleanInCoding/</url>
    <content><![CDATA[<p>2016年1月12日 18:14:37</p>
<p>本节转自 <a href="http://developer.51cto.com/art/201312/420153.htm">bool BOOL 和 _Bool辨析</a></p>
<h1 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h1><p>BOOL 类型在头文件 &lt;windef.h&gt; 中定义为 <code>typedef int BOOL</code>；在头文件 &lt;wtypes.h&gt; 中定义为 <code>typedef long BOOL</code>。<br>BOOL 类型，即 int 类型的长度视实际环境来定，一般可认为是 4 个字节。<br>BOOL 是微软定义的表达布尔逻辑的类型。与 C++ 中的 bool 类型不同是，它是一个<strong>三值逻辑</strong>：TRUE、FALSE 和 ERROR。当返回值为大于 0 的整数时为 TRUE，返回值为 0 时为 FALSE，返回值为 -1 时为 ERROR。</p>
<p>bool 类型在 C++ 中以关键字的形式被支持，表示布尔类型，其对应变量的值只有真（true）和假（false）两种值。bool 在 C++ 里占用 1 字节。</p>
<p>_Bool 是 C99 标准中定义的一个新关键字，以提供布尔类型。C2008 草案中只规定了 _Bool 类型的大小至少应能够存放 0 和 1 这两个值。而并没有规定具体的大小。这交给编译器自由发挥了。</p>
<p><strong>以上，足够读者区别彼此的使用场景了。</strong></p>
<a id="more"></a>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在 C 代码中使用布尔类型的几种方式：（如果编译器不支持 C99，就只能使用第一种方法了）</p>
<h2 id="自己定义的“仿布尔类型”"><a href="#自己定义的“仿布尔类型”" class="headerlink" title="自己定义的“仿布尔类型”"></a>自己定义的“仿布尔类型”</h2><p>在 C99 标准被支持之前，我们常常自己模仿定义布尔类型，方式有很多种，常见的有下面两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 第一种方法 */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BOOL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">/* 第二种方法 */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bool</span>&#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="使用-C99-新增的关键字-Bool"><a href="#使用-C99-新增的关键字-Bool" class="headerlink" title="使用 C99 新增的关键字 _Bool"></a>使用 C99 新增的关键字 _Bool</h2><p>标准并未对 _Bool 规定具体的大小。我们使用 gcc（64位环境）做下面测试：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/_Bool.png" alt="测试结果"></p>
<p>看来，gcc 编译器规定 _Bool 类型的长度为 1，只能取值为 0 或 1 。将任意非零值赋值给 _Bool 类型变量，都会先转换为 1，表示为真；将零值赋值给 _Bool 类型，结果为 0，表示为假。</p>
<h2 id="使用-C99-新增头文件-stdbool-h"><a href="#使用-C99-新增头文件-stdbool-h" class="headerlink" title="使用 C99 新增头文件 stdbool.h"></a>使用 C99 新增头文件 stdbool.h</h2><p>在 C++ 中，通过 bool 来定义布尔变量，通过 true 和 false 对布尔变量进行赋值。C99 为了让我们能够写出与 C++ 兼容的代码（在 c 代码中使用 bool、true、false，而非在C++ 代码中使用 _Bool），添加了头文件 &lt;stdbool.h&gt; 。所以我们只要包含了该头文件，就可以像 C++ 中使用布尔变量的方式进行操作。</p>
<p>在我自己的 linux 系统中查找 stdbool.h 头文件，找到两处：</p>
<p>系统定义 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Betty ~]# vi /usr/lib/syslinux/com32/include/stdbool.h</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* $Id: stdbool.h,v 1.1 2003/04/16 06:32:31 hpa Exp $</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* stdbool.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STDBOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STDBOOL_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __cplusplus</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__STDC_VERSION__) || (__STDC_VERSION__ &lt; 199901L)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(__GNUC__) ||(__GNUC__ &lt; 3)</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">char</span> <span class="built_in">_Bool</span>;           <span class="comment">/* For C compilers without _Bool */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool  _Bool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* C++ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool  bool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true  true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false false</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bool_true_false_are_defined 1</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _STDBOOL_H */</span></span></span><br></pre></td></tr></table></figure>
<p>GCC 定义 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Betty ~]# vi /usr/lib/gcc/x86_64-redhat-linux/4.1.1/include/stdbool.h</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">This file is part of GCC.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">GCC is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">the Free Software Foundation; either version 2, or (at your option)</span></span><br><span class="line"><span class="comment">any later version.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">GCC is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment">along with GCC; see the file COPYING.  If not, write to</span></span><br><span class="line"><span class="comment">the Free Software Foundation, 51 Franklin Street, Fifth Floor,</span></span><br><span class="line"><span class="comment">Boston, MA 02110-1301, USA.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* As a special exception, if you include this header file into source</span></span><br><span class="line"><span class="comment">   files compiled by GCC, this header file does not by itself cause</span></span><br><span class="line"><span class="comment">   the resulting executable to be covered by the GNU General Public</span></span><br><span class="line"><span class="comment">   License.  This exception does not however invalidate any other</span></span><br><span class="line"><span class="comment">   reasons why the executable file might be covered by the GNU General</span></span><br><span class="line"><span class="comment">   Public License.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ISO C Standard:  7.16  Boolean type and values  &lt;stdbool.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STDBOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STDBOOL_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __cplusplus</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool    _Bool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false   0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Supporting &lt;stdbool.h&gt; in C++ is a GCC extension.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Bool   bool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool    bool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false   false</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true    true</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Signal that all the definitions are present.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bool_true_false_are_defined   1</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* stdbool.h */</span> </span></span><br></pre></td></tr></table></figure>
<h1 id="真假大小写"><a href="#真假大小写" class="headerlink" title="真假大小写"></a>真假大小写</h1><p>相应的真假大小写区别—— false/true 是标准 C++ 语言里新增的关键字，而 FALSE/TRUE 是通过 <code>#define</code>，用途是解决程序在 C 与 C++ 中环境的差异,以下是 FALSE/TRUE 在 windef.h 的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FALSE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TRUE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p>也就是说 FALSE/TRUE 是 int 类型，而 false/true 是 bool 类型。所以两者不一样的，只不过我们在使用中没有这种感觉，因为 C++ 会帮你做隐式转换。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>CString 类</title>
    <url>/2017/03/08/CStringOfVC/</url>
    <content><![CDATA[<p>2015年12月7日 16:55:34</p>
<p>说说 CString 的几个函数。</p>
<ul>
<li>CString 对象在内存中用一个计数器来维持可用缓冲区的大小。</li>
<li>另外，CString 内，<code>GetLength()</code> 获取字符串长度并不是动态计算的，而是在赋值操作后计算并保存在一个 int 变量内的。</li>
</ul>
<a id="more"></a>

<h1 id="CString-GetBuffer-和-ReleaseBuffer"><a href="#CString-GetBuffer-和-ReleaseBuffer" class="headerlink" title="CString:GetBuffer() 和 ReleaseBuffer()"></a>CString:GetBuffer() 和 ReleaseBuffer()</h1><h2 id="GetBuffer-函数原型"><a href="#GetBuffer-函数原型" class="headerlink" title="GetBuffer() 函数原型"></a>GetBuffer() 函数原型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CString::GetBuffer</span><br><span class="line"><span class="function">LPTSTR <span class="title">GetBuffer</span><span class="params">( <span class="keyword">int</span> nMinBufLength )</span></span>;</span><br><span class="line"><span class="keyword">throw</span>( CMemoryException );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Return Value</p>
<p>  An <code>LPTSTR</code> pointer to the object’s (null-terminated) character buffer.</p>
</li>
<li><p>Parameters</p>
<p>  nMinBufLength - The minimum size of the character buffer in characters. This value does not include space for a null terminator.</p>
</li>
<li><p>Remarks</p>
<p>  Returns a pointer to the internal character buffer for the CString object. The returned <code>LPTSTR</code> is not const and thus allows direct modification of CString contents.</p>
<p>  If you use the pointer returned by <code>GetBuffer</code> to change the string contents, you must call <code>ReleaseBuffer</code> before using any other CString member functions.</p>
</li>
</ul>
<p>翻译过来的意思就是：</p>
<ul>
<li><p>返回值：一个指向对象的（以空字符结尾的）字符缓冲区的 <code>LPTSTR</code> 指针。</p>
</li>
<li><p>参数：nMinBufLength  字符缓冲区的以字符数表示的最小容量。这个值不包括一个结尾的空字符的空间。</p>
</li>
<li><p>说明：</p>
<p>  此成员函数返回一个指向 CString 对象的内部字符缓冲区的指针。返回的 <code>LPTSTR</code> 不是 const，因此可以允许直接修改 CString 的内容。</p>
<p>  如果你使用由 <code>GetBuffer</code> 返回的指针来改变字符串的内容，你必须在使用其它的 CString 成员函数之前调用 <code>ReleaseBuffer</code> 函数。</p>
</li>
</ul>
<h2 id="GetBuffer-函数作用及使用范围"><a href="#GetBuffer-函数作用及使用范围" class="headerlink" title="GetBuffer() 函数作用及使用范围"></a>GetBuffer() 函数作用及使用范围</h2><p>对一个 CString 变量，你可以使用的唯一合法转换符是 <code>LPCTSTR</code>，直接转换成非常量指针（<code>LPTSTR</code>-[const] char*）是错误的。正确的得到一个指向缓冲区的非常量指针的方法是调用 <code>GetBuffer()</code> 方法。</p>
<p><code>GetBuffer()</code> 主要作用是将字符串的缓冲区长度锁定，<code>ReleaseBuffer()</code> 则是解除锁定，使得 CString 对象在以后的代码中继续可以实现长度自适应增长的功能。参考 <code>ReleaseBuffer()</code>函数作进一步了解。</p>
<p><code>CString ::GetBuffer()</code> 有两个重载版本:</p>
<ul>
<li><code>LPTSTR GetBuffer();</code></li>
<li><code>LPTSTR GetBuffer(int nMinBufferLength);</code></li>
</ul>
<p>在第二个版本中，</p>
<ul>
<li>当设定的长度小于原字符串长度时，nMinBufLength = nOldLen，该参数会被忽略，不分配内存，指向原 CString；</li>
<li>当设定的长度大于原字符串本身的长度时就要重新分配（reallocate）一块比较大的空间出来。</li>
</ul>
<p>而调用第一个版本时，应如通过传入0来调用第二个版本一样。</p>
<p>是否需要在 <code>GetBuffer</code> 后面调用 <code>ReleaseBuffer()</code>，是根据你的后面的程序是否需要继续使用该字符串变量，并且是否动态改变其长度而定的。如果你 <code>GetBuffer</code> 以后程序自函数就退出，局部变量都不存在了，调用不调用 <code>ReleaseBuffer</code> 没什么意义了。</p>
<p>最典型的应用就是读取文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFile file;</span><br><span class="line"><span class="comment">// FILE_NAME 为实现定义好的文件名称</span></span><br><span class="line"><span class="keyword">if</span>(file.Open(FILE_NAME,CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">       CString szContent;</span><br><span class="line">       <span class="keyword">int</span> nFileLength = file.GetLength();</span><br><span class="line">       file.Read(szContent.GetBuffer(nFileLength),nFileLength);</span><br><span class="line">       szContent.ReleaseBuffer();</span><br><span class="line">       <span class="comment">// 取得文件內容放在szContent中，我们之后可以对其操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReleaseBuffer-函数原型"><a href="#ReleaseBuffer-函数原型" class="headerlink" title="ReleaseBuffer() 函数原型"></a>ReleaseBuffer() 函数原型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseBuffer</span><span class="params">( <span class="keyword">int</span> nNewLength = <span class="number">-1</span> )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">      <span class="keyword">if</span>( nNewLength == <span class="number">-1</span> ) </span><br><span class="line">      &#123; </span><br><span class="line">           nNewLength = StringLength( m_pszData ); </span><br><span class="line">      &#125; </span><br><span class="line">      SetLength( nNewLength ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReleaseBuffer-函数作用及使用范围"><a href="#ReleaseBuffer-函数作用及使用范围" class="headerlink" title="ReleaseBuffer() 函数作用及使用范围"></a>ReleaseBuffer() 函数作用及使用范围</h2><p>CString 对象在内存中用一个计数器来维持可用缓冲区的大小，很明显 <code>ReleaseBuffer</code> 的作用就是更新字符串的长度。CString 内，<code>GetLength</code> 获取字符串长度并不是动态计算的，而是读取的某成员变量的值（此成员变量在赋值操作后计算并更新），当通过 <code>GetBuffer</code> 直接修改 CString时，那个 int 变量（记录长度的成员变量）并不可能自动更新，于是便有了 <code>ReleaseBuffer</code>。</p>
<p>当你用 <code>ReleaseBuffer</code> 来释放该缓冲区时，如果指定长度参数，则不应该包含结尾的空字符（如果有的话）。建议不指定参数，使用空参数调用，让 <code>ReleaseBuffer</code> 对该缓冲区执行 <code>strlen</code> 来确定它的长度。</p>
<p>在调用 <code>ReleaseBuffer</code> 之后，由 <code>GetBuffer</code> 返回的地址<strong>也许</strong>就无效了，因为其它的 CString 操作可能会导致 CString 缓冲区被重新分配。如果你没有改变此 CString 的长度，则缓冲区不会被重新分配。当此 CString 对象被销毁时，其缓冲区内存将被自动释放。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的例子说明了如何用 <code>CString::GetBuffer</code> 和 <code>CString::ReleaseBuffer</code>（最好逐步调试观察值和地址的变化）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">CString <span class="title">s</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = s.GetLength(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s length1 is %d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    LPTSTR p = s.GetBuffer(<span class="number">6</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>( p, <span class="string">&quot;12345&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="keyword">int</span> j = s.GetLength(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s length2 is %d\n&quot;</span>, j);</span><br><span class="line">    s.ReleaseBuffer(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">int</span> k = s.GetLength(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s length3 is %d\n&quot;</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>( p, <span class="string">&quot;a1b2c3&quot;</span>);     <span class="comment">// 这里新指定的字串若为&quot;a1b2c3e&quot;则会在此中断</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="keyword">int</span> m = s.GetLength(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s length4 is %d\n&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/the-output-of-GetBuffer-ReleaseBuffer.png" alt="运行结果"></p>
<p>参考：<a href="http://blog.163.com/shi_shun/blog/static/23707849201023133945192/">CString的GetBuffer用法</a> 、<a href="http://www.cnblogs.com/ziwuge/archive/2011/06/17/2083999.html">CString:GetBuffer和ReleaseBuffer的作用</a></p>
<h1 id="CString-Format-函数与格式输入与输出"><a href="#CString-Format-函数与格式输入与输出" class="headerlink" title="CString::Format() 函数与格式输入与输出"></a>CString::Format() 函数与格式输入与输出</h1><p><a href="http://www.cnblogs.com/kent9/archive/2008/12/30/1365389.html">http://www.cnblogs.com/kent9/archive/2008/12/30/1365389.html</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>条件编译，针对VS</title>
    <url>/2017/04/19/ConditionalCompilationInVS/</url>
    <content><![CDATA[<p>2016/3/26 20:07:56</p>
<p>条件编译是应用较为广泛的一个概念，不限于编译器。但在这里，只讲如何在 VS2010 一个项目中使用条件编译实现不同的版本。</p>
<p>只放链接，以后再次用到时再做整理。</p>
<ul>
<li><a href="http://blog.csdn.net/xemexeme/article/details/8026313">使用Visual Studio .NET 2010的配置和条件编译在一个项目实现不同版本</a></li>
<li><a href="http://blog.163.com/lvan100@yeah/blog/static/68117214201124402367/">【经验之谈】如何实现条件编译（VS2010为例）</a></li>
<li><a href="http://blog.csdn.net/NewMap/article/details/5206265#comments">使用VS配置管理器实现不同版本的输出</a></li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>跨平台使用文本文件时的陷阱</title>
    <url>/2017/03/21/Cross-Platform-Text/</url>
    <content><![CDATA[<p>问题主要发生于将 windows 下的文本（源代码、脚本等）拷贝到 Linux 平台；反之，因为 windows 的霸道，其开发工具、编辑器会强制转换，所以一般不会产生问题。</p>
<ul>
<li>gcc 编译报错让我认识到，utf8 格式的文本还分带 BOM 头，不带 BOM 头；</li>
<li>vim 启动有问题认识到换行、回车到现在还在影响着跨平台；</li>
</ul>
<a id="more"></a>

<h1 id="UTF-8-是否带-BOM-头"><a href="#UTF-8-是否带-BOM-头" class="headerlink" title="UTF-8 是否带 BOM 头"></a>UTF-8 是否带 BOM 头</h1><p>2016年1月14日 17:37:30</p>
<p>ps 【…有4个链接要看】</p>
<h2 id="BOM-概念"><a href="#BOM-概念" class="headerlink" title="BOM 概念"></a>BOM 概念</h2><p>BOM，就是 utf8-bom 中的 bom。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">字节顺序标记</a>（英语：byte-order mark，BOM）是位于码点 <code>U+FEFF</code> 的统一码字符的名称。统一码中，值为 <code>U+FFFE</code> 的码位被保证将不会被指定成一个统一码字符。Unicode 的编码点是唯一的，但表达方式（存储方式）多样。表达方式涉及 utf8,utf16 等；存储方式除了前者还涉及 <a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节顺序</a>。在 UTF-16 中：</p>
<ul>
<li>大尾序存储形式：数值的低有效位存储在存储地址高的位置。即 <code>0xFE,0xFF</code></li>
<li>小尾序存储形式：数值的低有效位存储在存储地址低的位置。即 <code>0xFF,0xFE</code></li>
</ul>
<p>UTF-8 是否应该携有 BOM 是历史问题，不做讨论。当其携有 BOM 时，按照其 <a href="https://zh.wikipedia.org/wiki/UTF-8#UTF-8%E7%9A%84%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F">编码方式</a>，码点 <code>U+FEFF(1111,1110,1111,1111)</code> 会被存储为三个字节 <code>1110(1111),10(111011),10(111111)</code>，即 <code>0xef,0xbb,0xbf</code>。虽然携有 BOM，但</p>
<blockquote>
<p>它只用来标示一个 UTF-8 的文件，而不用来说明字节顺序</p>
</blockquote>
<p>另外，在 c++11 起，新增了两个 <a href="https://zh.cppreference.com/w/cpp/language/escape">转义字符</a>：</p>
<ul>
<li><code>\unnnn</code>，    通用字符名（任意 Unicode 值）可能生成多个字符，表示编码点 <code>U+nnnn</code></li>
<li><code>\Unnnnnnnn</code>，通用字符名（任意 Unicode 值）可能生成多个字符，表示编码点 <code>U+nnnnnnnn</code></li>
</ul>
<p>因为 <a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">BMP 基本多文种平面</a> 基本包含了我们目前接触到的所有字符，所以 <code>\U</code> 大写的转移字符一般是用不到的。</p>
<p>由此，如果我们想通过 C++ 的输出流创建 utf8-bom 文件并写入 <code>niel水</code> 有多样的代码可选：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UTF-8 data with BOM</span></span><br><span class="line"><span class="built_in">std</span>::ofstream(<span class="string">&quot;text.txt&quot;</span>) &lt;&lt; <span class="string">u8&quot;\ufeff&quot;</span> &lt;&lt; <span class="string">u8&quot;niel\u6c34&quot;</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">std</span>::ofstream(<span class="string">&quot;text.txt&quot;</span>) &lt;&lt; <span class="string">&quot;\xef\xbb\xbf&quot;</span> &lt;&lt; <span class="string">u8&quot;niel水&quot;</span>;</span><br><span class="line"><span class="comment">// 两者并无本质区别：我们优先做了转码工作或者交给预处理器去做</span></span><br></pre></td></tr></table></figure>
<h2 id="“error-stray-‘-357’-in-program”"><a href="#“error-stray-‘-357’-in-program”" class="headerlink" title="“error: stray ‘\357’ in program”"></a>“error: stray ‘\357’ in program”</h2><p>在 linux 上某次编译时老是报错，错误信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -I../../include unit_test.cpp -o unit_test</span></span><br><span class="line">unit_test.cpp:1: 错误： 程序中有游离的&#x27;\357&#x27;</span><br><span class="line">unit_test.cpp:1: 错误： 程序中有游离的&#x27;\273&#x27;</span><br><span class="line">unit_test.cpp:1: 错误： 程序中有游离的&#x27;\277&#x27;</span><br><span class="line">In file included from unit_test.cpp:63:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>或在英文系统下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -I../../include unit_test.cpp -o unit_test</span></span><br><span class="line">unit_test.cpp:1: error: stray &#x27;\357&#x27; in program</span><br><span class="line">unit_test.cpp:1: error: stray &#x27;\273&#x27; in program</span><br><span class="line">unit_test.cpp:1: error: stray &#x27;\277&#x27; in program</span><br><span class="line">In file included from unit_test.cpp:63:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>\357\273\277</code> （八进制）就是 <code>EF BB BF</code>（十六进制），这是 utf8 格式文本文件的 BOM 头。so……</p>
<p>产生原因:</p>
<p>文本文件（源代码文件 .cpp .h 等也是文本文件）的编码格式各种各样，没有明确的区分。而一些浏览文本文件的软件大多是用猜测的算法来区分这些编码，这里涉及内容很多，不多说。windows 下为了区分 UTF-8 编码格式，在以 UTF-8 编码的文本文件前写入三个字节的标志（0xef 0xbb 0xbf）来区分 UTF-8 编码的文本文件，也就是带 BOM 的 UTF-8。而 linux 下的一些编译器不识别 BOM，所以就会报错。</p>
<p>一般在 windows 下的文件都存成 ansi 格式，为了在 linux 下能通用，建议保存成 UTF-8 不带 BOM 编码格式，因为目前 gcc 和 g++ 不支持 <strong>UTF-8 带 BOM</strong> 编码格式。</p>
<p>延伸阅读：<a href="http://www.cnblogs.com/findumars/p/3620078.html">UTF8最好不要带BOM，附许多经典评论</a> （很值得一看）</p>
<p>解决方法：<a href="http://huoding.com/2011/05/14/78">UTF-8编码中BOM的检测与删除</a> 【需测试，验证…】</p>
<h2 id="学习-od-命令"><a href="#学习-od-命令" class="headerlink" title="学习 od 命令"></a>学习 od 命令</h2><ul>
<li><a href="http://os.51cto.com/art/200912/173136.htm">详细介绍Linux指令od</a></li>
<li><a href="http://blog.chinaunix.net/uid-9525959-id-2001619.html">Linux命令学习手册-od命令</a></li>
</ul>
<p>如何判断文件是否是使用 UTF-8 BOM 存储的？执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat unit_test.cpp |hd -n 10</span></span><br><span class="line">00000000 ef bb bf 2f 2a 2a 2a 2a 2a 2a |.../******|</span><br><span class="line">0000000a</span><br></pre></td></tr></table></figure>
<p>ps: <code>hd</code> 命令在 13x 系列服务器上不存在，在 Debian8 中有。 猜测应该是 <code>hexdump</code> 命令？？</p>
<h1 id="回车、换行是两个字符"><a href="#回车、换行是两个字符" class="headerlink" title="回车、换行是两个字符"></a>回车、换行是两个字符</h1><p>虽然很早就意识到回车、换行的区别，在不同平台上不一致。但在新的系统、新的应用中，这个问题一般会被“抹掉”，不会再暴露出来。但在 N 年前的老机子就得注意了！</p>
<h2 id="Not-an-editor-command-M"><a href="#Not-an-editor-command-M" class="headerlink" title="Not an editor command: ^M"></a>Not an editor command: ^M</h2><p>2015年11月20日 17:32:39</p>
<p>转载自：<a href="http://www.cnblogs.com/ini_always/archive/2012/03/03/2378554.html">http://www.cnblogs.com/ini_always/archive/2012/03/03/2378554.html</a></p>
<p>将 windows 下的 vim 配置文件 _vimrc 拷贝到 mac 下，重命名为 .vimrc，本指望实现共用配置文件。但在启动 vim 时却报了以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E492: Not an editor command: ^M</span><br><span class="line">E488: Trailing characters: nocompatible^M</span><br><span class="line">E15: Invalid expression: has(&quot;syntax&quot;)^M</span><br><span class="line">E171: Missing :endif</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Not-an-enditor-command.png" alt="报错信息"></p>
<p>Mac OS 的本质是 unix，而 unix-like 的文件换行符为 <code>\n</code>，但 windows 却非要把 <code>\r\n</code> 作为换行符，所以，vim 在解析从 windows 拷贝到 mac 的的 vimrc 时，因为遇到无法解析的 <code>\r</code>，所以报错。</p>
<p>这个简单，用vim的神替换功能处理一下就好：<code>:%s/^M//gc</code>，<code>g</code> 选项表示全局替换，<code>c</code> 选项表示每次替换都需要确认。</p>
<p>但要注意：这里的 <code>^M</code> 是特殊字符，并不是使用 <code>^</code>和 <code>M</code> 两个字符输入的，而是通过两个组合键 <code>C-V</code> <code>C-M</code> 输入的（C 代指 Ctrl），当然，<code>^M</code> 也可以使用 <code>\r</code> 表示。</p>
<p>问题：我按照上面的执行替换指令后，报错 未找到 <code>\r</code>。不清楚为什么，反正不好用。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Pattern-not-found.png" alt="未找到 \r"></p>
<p>从网上搜到的相关问题的解决办法： <a href="http://blog.csdn.net/alex_xhl/article/details/6097191">vim 替换^M</a></p>
<p>使用 <code>dos2unix</code> 命令。一般的分发版本中都带有这个小工具（如果没有可以根据下面的连接去下载），使用起来很方便：<code>$ dos2unix myfile.txt</code></p>
<p>上面的命令会去掉行尾的^M。</p>
<p>执行成功。推荐。</p>
<h2 id="脚本莫名其妙的打印"><a href="#脚本莫名其妙的打印" class="headerlink" title="脚本莫名其妙的打印"></a>脚本莫名其妙的打印</h2><p>2015年11月4日 16:19:54</p>
<p>先说结论：windows 下编辑的文件拿到 linux 下用，可以，但要谨慎，反之亦然。出现问题时先排除是不是回车、换行的问题。</p>
<p>以前接触 linux 很少，shell 更是一点都不了解。今天调试一个项目，需要运行 sh 文件。可是太蛋疼了，详述如下：</p>
<p>在 suse11 的环境（公司 10.1.72.57 的服务器上）下，运行 bug.sh 和 normal.sh，两者显示内容一致，如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SRCPATH=<span class="string">&quot;hello&quot;</span></span><br><span class="line">rm -f bench_test</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;SRCPATH&#125;</span><span class="string">&quot;CAT&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果却大相径庭</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/UnexpectedOutputOfScript.png" alt="Linux 下执行结果"></p>
<p>而在 windows 系统下，安装的 Git Bash Here 窗口中运行，结果一致</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/UnexpectedOutputOfScript-2.png" alt="Windows 下执行结果"></p>
<p>在 UltraCompare 中使用二进制窗口看出最终的区别，也验证了猜想</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/UnexpectedOutputOfScript-3.png" alt="二进制形式查看"></p>
<p><code>0x0d 0x0a</code> 和 <code>0x0a</code> 的区别，是 windows 和 linux 的区别，当文件从 windows 拿到 linux 时，我们无法保证正在使用的 linux 版本在兼容性方面做得完美。比如 git 虽然是 linux 的背景，做的就很好；而 suse 显然在这方面尚有不足，让人在没有这方面意识、没有针对性的前提下，浪费大量时间，无从把握。</p>
<p>windows 系统下，回车是由两个字符构成的，<code>0x0d</code> 和 <code>0x0a</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>ASCII码</th>
<th>十六进制</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>回车</td>
<td>CR</td>
<td><code>\r</code></td>
<td>0x0d</td>
<td>回车的作用只是移动光标至该行的起始位置；</td>
</tr>
<tr>
<td>换行</td>
<td>LF</td>
<td><code>\n</code></td>
<td>0x0a</td>
<td>换行至下一行行首起始位置；</td>
</tr>
</tbody></table>
<p>在键盘上敲下回车键，在不同软件下获得字符大有不同。Windows 下在 txt 文件中敲下回车键，然后十六进制进制观察，你会发现获得了 2 个字符，<code>0x0d</code> 和 <code>0x0a</code>，这个大家都知道，但这不意味着，在任何情况下敲下回车键，都会获得 <code>0x0d</code> 和 <code>0x0a</code>。在 linux 下，你对一个文件，敲下回车键，你就会发现，它每次只增加一个字符 <code>0x0a</code>。</p>
<p>延伸阅读：<a href="http://blog.sina.com.cn/s/blog_6933011901011ght.html">回车 换行 0x0D 0x0A CR LF \r \n的来龙去脉</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>怎样的linux开发方式？很原始的</title>
    <url>/2017/04/24/DevelopmentOnLinux/</url>
    <content><![CDATA[<p>2015年11月20日 14:31:06</p>
<p>从月初开始接触 linux 开发，真心是磕磕绊绊。简单的使用，查阅一些操作命令这些都不是问题，困难主要在于 linux 下的开发。</p>
<ol>
<li>大学有一本 unix 的教材，至少看了前五章。自己也折腾安装过 linux 的系统，从 CentOS、Fedora 到 debian，安装后也简单的操作过，虽说没有任务驱动最终也不了了之。但多少不认生。</li>
<li>公司的开发环境是有几台 suse 的服务器，在不同的局域网里。远程连接上去进行开发。使用的工具是 Xbrowser，其中包括 Xshell、Xftp 等。最开始两天使用过其中的 XDMCP 以图形界面操作局域网 A 中一台服务器，唯一的感受就是卡，画面的操作很不流畅，严重影响使用体验。一开始使用 suse 企业版 10 远程图形界面操作一般，后来重装系统 open suse linux 10 之后，XDMCP 的操作体验变得很糟糕。</li>
<li>XDMCP 的使用，需要在服务器上进行有关的设置。后来在 57（局域网B中服务器的 ip）服务器上开发，工作组成员都没有此服务器的 root 权限。再没有使用图形界面，使用 Xshell+Xftp，使用 Xshell 进行和开发有关的操作，使用 Xftp 进行文件的传输和文本的编辑。基本上就是<strong>在主机上使用 notepad++ 编辑代码，通过 Xftp 同步到服务器，在 Xshell 中进行编译、运行操作</strong>（还没有掌握 gdb，调试处于看错误输出，改项目源码的阶段）。在 Xftp 中可以直接打开服务器上的源码进行编辑保存操作，所以还是比较方便的。</li>
<li>目前阶段这种“拼凑”的开发方式还是足够用的，但能明显感觉到瓶颈。对 vim 的操作止于零，这个<strong>周末在家练习</strong>，一步步把 vim 搭建成开发环境。+ makefile文件 + gdb</li>
<li>有时间了补足一下 x- 系列的操作步骤，虽然简单，但当时在网上没找到有关的介绍，前后也花费了大半天时间。</li>
</ol>
<a id="more"></a>

<h1 id="x-系列使用教程"><a href="#x-系列使用教程" class="headerlink" title="x-系列使用教程"></a>x-系列使用教程</h1><p>在网上搜到两篇帖子，重点在讲怎么配置 linux 以供 windows 上使用 x- 连接。因为工作过程中并不需要我来配置 linux，所以这两篇帖子并没有看过。</p>
<ul>
<li><a href="http://www.linuxidc.com/Linux/2014-10/107894.htm">如何使用XManager下的Xshell远程连接Linux</a></li>
<li><a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/Xmanager_Enterprise_4_%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.docx">Xmanager_Enterprise_4_使用说明</a></li>
</ul>
<p>以下是工作过程中在 windows 上如何操作的记录：</p>
<ul>
<li><a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/Xshell%E3%80%81Xftp%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C.rar">《Xshell、Xftp连接操作.rar》</a></li>
<li><a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/Xshell%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86.rar">《Xshell中文乱码怎么处理》</a></li>
</ul>
<p>注意事项：以上操作只是在 cts2 项目中，使用 Xshell、Xftp 远程操作 suse 服务器时的有关设置。因为连接协议、端口以及用户名等都与服务器设置关联，故不具有通用性。</p>
<p>推荐，查阅软件的使用帮助</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/0141e3ad-7dc1-4f49-94b7-ad2f34c3ad24.png" alt="Xshell 帮助"></p>
<p>如果其中找不到，再去网上搜索。</p>
<h1 id="编译时怎么定义目录"><a href="#编译时怎么定义目录" class="headerlink" title="编译时怎么定义目录"></a>编译时怎么定义目录</h1><p>2015年12月21日 18:24:22</p>
<p>首先说明，这里主要针对使用 makefile 生成项目时怎么定义目录。而不是特指 windows 下使用 VS 生成项目时有关目录下从存放什么文件。</p>
<h2 id="lib-目录"><a href="#lib-目录" class="headerlink" title="lib 目录"></a>lib 目录</h2><p>以上，可以参考linux 系统下，/lib 目录内容（/lib64 or /usr/lib or /usr/lib64）</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/lib.png" alt="lib 目录"></p>
<p>lib 包含程序实现文件编译生成的library，<strong>包括静态库.a 和动态库.so文件</strong>。</p>
<p>我们可以来看一看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Dev-Cpp&gt;dir lib &#x2F;s &#x2F;b &#x2F;a &gt;lib.txt</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">C:\Dev-Cpp\lib\gcrt1.o</span><br><span class="line">C:\Dev-Cpp\lib\gcrt2.o</span><br><span class="line">C:\Dev-Cpp\lib\libadvapi32.a</span><br><span class="line">C:\Dev-Cpp\lib\libapcups.a</span><br><span class="line">C:\Dev-Cpp\lib\libbfd.a</span><br><span class="line">C:\Dev-Cpp\lib\libbfd.la</span><br><span class="line">C:\Dev-Cpp\lib\libcap.a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="include-目录"><a href="#include-目录" class="headerlink" title="include 目录"></a>include 目录</h2><p>类似的，/usr/include 目录内容</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/include.png" alt="include 目录"></p>
<p>include 包含程序定义的一些东西的头文件，比如宏，结构定义，函数定义，类型定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Dev-Cpp&gt;dir include &#x2F;s &#x2F;b&#x2F;a &gt;incld.txt</span><br><span class="line">...</span><br><span class="line">C:\Dev-Cpp\include\dos.h</span><br><span class="line">C:\Dev-Cpp\include\errno.h</span><br><span class="line">C:\Dev-Cpp\include\excpt.h</span><br><span class="line">C:\Dev-Cpp\include\exdisp.h</span><br><span class="line">C:\Dev-Cpp\include\exdispid.h</span><br><span class="line">C:\Dev-Cpp\include\fcntl.h</span><br><span class="line">C:\Dev-Cpp\include\fenv.h</span><br><span class="line">C:\Dev-Cpp\include\float.h</span><br><span class="line">...</span><br><span class="line">C:\Dev-Cpp\include\c++\fstream</span><br><span class="line">C:\Dev-Cpp\include\c++\functional</span><br><span class="line">C:\Dev-Cpp\include\c++\iomanip</span><br><span class="line">C:\Dev-Cpp\include\c++\ios</span><br><span class="line">C:\Dev-Cpp\include\c++\iosfwd</span><br><span class="line">C:\Dev-Cpp\include\c++\iostream</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="bin-目录"><a href="#bin-目录" class="headerlink" title="bin 目录"></a>bin 目录</h2><p>同样，/usr/bin 目录内容</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/developmentonlinux/bin.png" alt="bin 目录"></p>
<p>bin 包含可执行文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Dev-Cpp&gt;dir bin &#x2F;s &#x2F;b &#x2F;a &gt;bin.txt</span><br><span class="line">...</span><br><span class="line">C:\Dev-Cpp\bin\g++.exe</span><br><span class="line">C:\Dev-Cpp\bin\g77.exe</span><br><span class="line">C:\Dev-Cpp\bin\gcc.exe</span><br><span class="line">C:\Dev-Cpp\bin\gccbug</span><br><span class="line">C:\Dev-Cpp\bin\gcov.exe</span><br><span class="line">C:\Dev-Cpp\bin\gdb.exe</span><br><span class="line">C:\Dev-Cpp\bin\gprof.exe</span><br><span class="line">C:\Dev-Cpp\bin\ld.exe</span><br><span class="line">C:\Dev-Cpp\bin\make.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这些文件夹是为了区分文件方便而建立的，同一个文件夹下的文件的性质一般是相同的。我们可以看出来： </p>
<ul>
<li>lib 是放 obj 文件的（对 gcc 来说为 .o）；</li>
<li>inlcude 是存放头文件的；</li>
<li>bin 存放的是二进制代码；</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统</title>
    <url>/2017/04/14/DoubSystems/</url>
    <content><![CDATA[<p>双系统，还是虚拟机？如果机器跑虚拟机资源足够（操作并不会明显卡，风扇不会疯狂地转），我会选择后者。双系统带来的问题，在于两个系统的切换需要重新关机重启而且使用图形界面的 Linux 对比 windows 毫无优势，Linux 的优点在于不带图形界面的前提下占用资源少。而如果在 Linux 中使用图形界面不单单耗费资源，而且体验不如 windows。</p>
<p>你可以在虚拟机中不带界面跑 Linux，而双系统的情景下谁会只安装命令行（Linux 不带图形界面）的交互呢？</p>
<p>在接触系统之前，先了解更底层的东西。</p>
<a id="more"></a>

<h1 id="系统之下"><a href="#系统之下" class="headerlink" title="系统之下"></a>系统之下</h1><h2 id="BIOS-legacy-对比-efi-uefi"><a href="#BIOS-legacy-对比-efi-uefi" class="headerlink" title="BIOS(legacy) 对比 efi(uefi)"></a>BIOS(legacy) 对比 efi(uefi)</h2><ol>
<li><a href="http://www.iruanmi.com/what-is-gpt-and-what-is-uefi/">什么是GPT，什么是UEFI？</a></li>
<li><a href="http://jingyan.baidu.com/article/d713063504112013fdf47589.html">win8/win8.1 UEFI + GPT 安装详细图解</a></li>
<li><a href="http://wenku.baidu.com/link?url=bkY8iCaUf8fOxZ3BxIfmgEkS3cQHJ8XBj8n9dejFPER1rXswuNgZQ5QxOh6k0g3ivLbpujWQwekrB8zPm429NlAOfgAkA--YGeLFRXpyIeq">Thinkpad X240使用U盘安装Win7系统</a></li>
<li><a href="http://zhidao.baidu.com/question/582824734443443885.html?qbl=relate_question_0&word=uefi%20legacy%20boot%EF%BF%BD%EF%BF%BD%CA%B2%C3%B4%EF%BF%BD%EF%BF%BD%CB%BC">Legacy 跟UEFI 有什么区别</a></li>
<li><a href="http://zhidao.baidu.com/link?url=9MlMCIMzazG3Xf0Pcj72s3vlWQyTdLG6Bgp3diyx_4HIItpyjgsF_wqC-iSk_z6FIQkvCuqdlKOuBaIg4mK9D_">启动uefi boot装WIN8后,将BIOS的BOOT中的uefi boot变回Legacy boot就无法进入系统，怎么办？</a></li>
</ol>
<h2 id="grub-对比-mbr"><a href="#grub-对比-mbr" class="headerlink" title="grub 对比 mbr"></a>grub 对比 mbr</h2><ol>
<li><a href="http://zhidao.baidu.com/link?url=tiGGUtSqZgLPXwKbHk9rzzZvgwvD9NSSbEMv7yg1xpQ0fMAk09zt-jpJ_oUyAuk94OLaDbC-d_Nv5FpXYwdojq">什么是GRUB 和MBR?</a></li>
<li><a href="http://blog.chinaunix.net/uid-9078996-id-2010311.html">MBR和grub工作原理</a></li>
</ol>
<h2 id="mbr-vs-gpt"><a href="#mbr-vs-gpt" class="headerlink" title="mbr vs. gpt"></a>mbr vs. gpt</h2><p>（略）</p>
<h1 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h1><p>Linux 那么多发行版，选择哪一个呢？菜鸟上手的话，选一个简单的就好。不要犯“旱鸭子学游泳，过一个暑假还没下水”的错误。</p>
<h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><ol>
<li><a href="http://blog.csdn.net/educast/article/details/38315433">CentOS、Ubuntu、Debian三个linux比较异同</a></li>
<li><a href="http://www.zhihu.com/question/19599986">服务器操作系统应该选择 Debian/Ubuntu 还是 CentOS？</a></li>
<li><a href="http://zhidao.baidu.com/question/240548764.html?qbl=relate_question_1&word=linux%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%C4%B8%EF%BF%BD%EF%BF%BD%E6%B1%BE&optimi=4">linux哪个版本好</a></li>
</ol>
<h3 id="安装-Debian"><a href="#安装-Debian" class="headerlink" title="安装 Debian"></a>安装 Debian</h3><ol>
<li><a href="https://www.debian.org/distrib/">获取 Debian</a></li>
<li><a href="https://www.debian.org/releases/stable/amd64/index.html.zh-cn">Debian GNU/Linux 安装手册</a></li>
<li><a href="http://www.mintos.org/distros/debian-install.html">Debian的几种简单安装方法</a></li>
</ol>
<p>如果有兴趣，可以看看 <a href="https://debian-handbook.info/get/">《Debian Jessie from Discovery to Mastery》</a></p>
<h2 id="Win7-安装-Debian"><a href="#Win7-安装-Debian" class="headerlink" title="Win7 安装 Debian"></a>Win7 安装 Debian</h2><ol>
<li><a href="http://www.cppblog.com/niewenlong/archive/2013/01/29/197612.html">win7下硬盘安装debian</a></li>
<li><a href="http://www.2cto.com/os/201412/361206.html">Win7上从硬盘安装Debian</a></li>
<li><a href="http://my.oschina.net/lowkey2046/blog/210102">Window 下U盘安装 Debian</a></li>
</ol>
<h2 id="Win8-安装-Linux"><a href="#Win8-安装-Linux" class="headerlink" title="Win8 安装 Linux"></a>Win8 安装 Linux</h2><ol>
<li><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=77&t=467746">在预装Win8.1的电脑上安装ubuntu</a></li>
<li><a href="http://zhidao.baidu.com/link?url=-UOwMH65heQtk61Os3tQQ4xtj5DOxU0kiyH3Mz77S1Q_msDBLSEFOuQ-CfKQxwKSR_YnqmwJfi3_POjBYcTg4Z9DO4fMTo9jHR4iblHJ2ye">如何在Win8下安装Debian</a></li>
</ol>
<h1 id="系统之上"><a href="#系统之上" class="headerlink" title="系统之上"></a>系统之上</h1><h2 id="gnome-vs-kde"><a href="#gnome-vs-kde" class="headerlink" title="gnome vs. kde"></a>gnome vs. kde</h2><ol>
<li><a href="http://zhidao.baidu.com/link?url=bHe8hUgqDOkRKELjkqb9NDwyvF4QVds9ho8NVP_JlTWgieQ4TtXuaqDHY7rnLkiWM7FsRdZED7Mr9flI3Nyq9q">KDE和GNOME的区别</a></li>
<li><a href="http://blog.csdn.net/dlodj/article/details/6674316">x-window、gnome、kde的区别</a></li>
<li><a href="http://www.jb51.net/LINUXjishu/78428.html">linux桌面环境gnome,kde,xfce,lxde 使用比较</a></li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>Flume &amp; Redis 学习笔记V0.1</title>
    <url>/2016/07/15/Flume%20&amp;%20Redis/</url>
    <content><![CDATA[<h1 id="Flume-学习笔记"><a href="#Flume-学习笔记" class="headerlink" title="Flume 学习笔记"></a>Flume 学习笔记</h1><p><a href="http://shiyanjun.cn/archives/915.html">Flume(NG)架构设计要点及配置实践</a>，在此基础上的扩展：<a href="http://blog.javachen.com/2014/07/22/flume-ng.html">Flume-ng的原理和使用</a></p>
<ol>
<li>Agent 的串联、并联</li>
<li>Source 一般都是单一 Source；Source 一对多 Channel，分为复制（replication）和分流（multiplexing）</li>
<li>Channel 一对多 Sink，实现负载均衡（load balance）和故障转移（failover）</li>
</ol>
<p>在上述中多提到 Avro，在 Flume 的配置文件中也用到此项。<a href="http://blog.javachen.com/2015/03/20/about-avro.html">Avro 介绍</a>，但目前不需要了解。</p>
<blockquote>
<p>Avro 是 Hadoop 中的一个子项目，也是 Apache 中一个独立的项目，Avro 是一个基于二进制数据传输高性能的中间件。</p>
</blockquote>
<h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><p><a href="http://redis.io/topics/quickstart">Redis Quick Start</a></p>
<ol>
<li>在安装过程中，如果缺少依赖项，需要先编译 deps 目录。</li>
<li>将 redis 加入系统启动项，手册中使用 <code>sudo update-rc.d redis_6379 defaults</code>。但此命令只在 Debian 系下使用。</li>
</ol>
<h1 id="70-13x-系列服务器搭建指南"><a href="#70-13x-系列服务器搭建指南" class="headerlink" title="70.13x 系列服务器搭建指南"></a>70.13x 系列服务器搭建指南</h1><ol start="0">
<li><p>先安装 jdk，配置好 JAVA_HOME 环境变量</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/cts/tool/jdk1.6.0_45/</span><br><span class="line"><span class="built_in">export</span> JAVA_BIN=<span class="variable">$JAVA_HOME</span>/bin/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jreb:<span class="variable">$JAVA_HOMEb</span>/tools.jar</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br></pre></td></tr></table></figure></li>
<li><p><a href="http://redis.io/topics/quickstart#installing-redis">安装 redis</a>，<a href="http://redis.io/topics/quickstart#installing-redis-more-properly">启动 redis</a></p>
<ul>
<li>如果需要，可以配置主从 redis</li>
</ul>
</li>
<li><p>使用 cts2Cache-v0.2 程序初始化 redis</p>
<ul>
<li>执行 run-Init.sh 脚本执行初始化，需要修改 cts2Cache-0.1.0.jar 中配置文件 redis IP；</li>
<li>使用 crontab 命令设置定时任务，每日执行 run-update-recv.sh 和 run-update-send.sh 脚本生成次日的节目表；</li>
</ul>
</li>
<li><p>使用 cts2LogGate 程序开启日志网关</p>
<ul>
<li>参考 visio 图</li>
<li>依照 send、recv、mu、lb 顺序开启，使用 kill 命令逆序关闭</li>
<li>开启时可以使用 nohup 命令</li>
<li>怎么关闭呢？</li>
</ul>
</li>
<li><p>向日志网关发送日志</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Git@OSC禁止推送大于100M文件【…Q5】</title>
    <url>/2017/04/18/GitOfOSC/</url>
    <content><![CDATA[<p>2016/2/14 16:15:47</p>
<p>整理这篇笔记总共花费了差不多一个工作日的时间（8h），其他的笔记也很费事。所以我在思考一个问题，我整理笔记的方式是不是有问题？花费如此多的时间是否正常？</p>
<p>以上疑惑留待以后，下面进入正题。</p>
<h1 id="问题描述与思考"><a href="#问题描述与思考" class="headerlink" title="问题描述与思考"></a>问题描述与思考</h1><p>这个标题可能不恰当，稍后修改。</p>
<a id="more"></a>

<p>起因是，前一阵子我开始把从网上找到的一些使用手册（chm格式）、电子书（pdf）等参考学习的资源放到版本控制的文档文件夹中，起初文件都不大，几百 KB，最大的不过 10M 左右，进行本地提交和远程推送都正常。直到，</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/cabf9db1-007f-4c8f-be92-9afbfe6b9051.png" alt="大文件"></p>
<p>这个逾百 M 文件的出现。本地提交正常，可是进行远程推送报错：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/c82407c2-e263-45ff-af61-1bc5c82f4cb2.png" alt="报错信息"></p>
<p>报错给出的提示信息很明确，我使用的开源中国 OSC 的网站限制（暂时不打算更换其他的代码托管服务，更具体的说，目前 OSC 是最适合我的）100M  大小。</p>
<ol>
<li>最开始我以为“git@oschina 网站不允许 single 文件大于 100M 的内容，所以把 C++ Primer 中文第 5 版使用 Adobe Acrobat 9 Pro 拆分后上传”，至于 200M+ 的大文件进行了“删除并添加到忽略列表”且“保留本地复本”，可是推送时依旧报错；</li>
<li>然后我以为“git@oschina 每次上传文件总和不能大于 100M，所以拆分后的 7 个子 pdf（一共 198M）分 3 次上传”，依旧报错。ps：通过在网上看到的一些介绍，以及回顾自己之前的使用经历，后者的猜测应该是错误的，毕竟若真是如此的话，那么在老东家时唐龙科技的整个几百兆的项目又是怎么推送的呢。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/6593750.png" alt="文件清单"></p>
<p>至此，才开始认真考虑“265.pdf is 198.32 MB”这个信息，工作目录中肯定是没有这个文件，那么只能是 .git 隐藏目录了。发现 .git/objects  文件夹有将近 500M，肯定是有些太大了点，从网上搜到一条指令：（ps 通过《Pro Git 第2版》了解 <code>git gc</code> 这个命令，发现在这里使用根本就是驴唇不对马嘴）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#清理本地版本库</span><br><span class="line">$ git gc --prune&#x3D;now</span><br></pre></td></tr></table></figure>
<p>执行完毕后，.git/objects 文件夹缩小到 273M。不过报错依旧。</p>
<p>进一步思考，发现自己还是没有认真思考错误提示，并且对 git 的工作方式的理解不够灵活。最终猜测，“虽然对文件（特指未拆分的大于 200M 的 pdf 文件）进行了删除操作且已再次提交过了，但是作为版本控制库，为了保证还原到上一版本，所以库中肯定是有文件的备份的”，若如此的话，合并新添此文件和删除此文件的两次提交（如果两次提并非相邻提交，则需要合并多个）即可解决问题。也不需要“规避小文件总体超标”（这个错误理解）。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/8283156.png" alt="合并前"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/ee54a94c-8c08-4ff4-9f24-2653c4435591.png" alt="合并，且放弃最新提交后"></p>
<p>再次推送，成功！YES</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gitofosc/865760ef-32f4-4c3f-8dcd-f64e11f37f3e.png" alt="推送成功"></p>
<h2 id="课后总结"><a href="#课后总结" class="headerlink" title="课后总结"></a>课后总结</h2><p>Q1：最好找到开源中国对于代码服务推送文件大小限制的官方说明<br>——找不到，放弃。官方只有关于附件的一个说明，但目前我用不到“上传附件”的功能。</p>
<p>Q2：如果在新的提交上删除了之前提交的文件，库中肯定留有备份。但是如果已经 100% 确认肯定用不到了，那么这种备份如何从库中释放？除了上面合并两者（包含）之间所有的提交这种直接，但是却比较笨的方法，设想如果新添、删除两次提交不相邻，甚至有十几次、几十次提交了，还这么做肯定是不现实的。<br>——参考《Pro Git 第2版》中第7章 重写历史一节的 <code>filter-branch</code> 命令；参考 <a href="http://blog.csdn.net/meteor1113/article/details/4407209">从git中永久删除文件以节省空间</a></p>
<p>Q3：如果是旧的提交中有，后来进行新提交时删除了（同上），而且添加到了 .gitignore 忽略文件，<strong>感觉</strong>应该自动从库中释放备份了呀，但事实上不会（例如上文中）。纠正此错误认知——考虑，其实 .gitignore 文件自身也可以是版本管理目标之一，也就是说如果还原到 A 提交，那么不单单 A、B 两次提交中间删除的文件的要还原，.gitignore 文件也要重置到 A 提交时未新添忽略项时的版本。.gitignore 文件忽略的项并不是时间轴上的全局，并不是一经修改，通吃过去和现在的。此文件只是针对提交的，并不是针对仓库的。<br>——在 D 盘进行试验，参考《Git 权威指南》第 7 章，使用 <code>git reset</code> 重置命令，注意其选项 <code>--mixed</code>、<code>--hard</code>、<code>--soft</code></p>
<p>Q5：将学习材料、阅读材料使用云盘同步，因为这些文档不存在版本控制的问题；清理 OSC 版本库的提交<br>——迁移到了 onedrive 同步盘中。</p>
<h1 id="git文件过大，如何清理"><a href="#git文件过大，如何清理" class="headerlink" title=".git文件过大，如何清理"></a>.git文件过大，如何清理</h1><p>强调一点，上面遇到的问题是代码托管服务平台的限制，所以我需要删除个别大文件，从所有有关提交中删除；.git 文件过大和前者完全是两个不同的问题，前者牵扯 <code>git gc</code> 操作完全是我个人理解上的错误。两者之间唯一的联系其实是“如何从每一个提交移除一个文件”，都使用 <code>filter-branch</code> 命令。</p>
<p>Q4：那么 .git 隐藏目录中的缓存、垃圾之类的是怎么来的？又该如何清理呢？</p>
<h2 id="治标不治本"><a href="#治标不治本" class="headerlink" title="治标不治本"></a>治标不治本</h2><p>——这方面暂时不需要了解。如果觉得 clone 本地版本库时太大，可以指定深度，如下，为 1 即表示只克隆最近一次 commit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;xxoo --depth 1</span><br></pre></td></tr></table></figure>
<p>远程版本库，也可以先删除，然后完全重建版本库。前提是只要结果，过程已无任何价值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -rf .git</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git cm &quot;first commit&quot;</span><br><span class="line">$ git remote add origin &lt;your_github_repo_url&gt;</span><br><span class="line">$ git push -f -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="系统性的清理"><a href="#系统性的清理" class="headerlink" title="系统性的清理"></a>系统性的清理</h2><p>以上只是治标不治本的方法，也有其使用限制。但是胜在快刀斩乱麻，不需要花费大量时间、精力去整理执行。系统性的清理参考以下：<a href="https://blog.eood.cn/how-to-clean-up-git-repo">如何清洗 Git Repo 代码仓库。</a></p>
<p>知乎上看到一个答案，不知道合不合适，仅作参考：<a href="https://www.zhihu.com/question/29769130">如何解决GitHub commit次数过多.git文件过大的问题</a></p>
<h1 id="网络资源"><a href="#网络资源" class="headerlink" title="网络资源"></a>网络资源</h1><p>后期在网上找到以下帖子，和我遇到的问题完全一致：<a href="http://www.cnblogs.com/qmmq/p/4604862.html">处理GitHub不允许上传大于100M文件问题</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Kindle 帖</title>
    <url>/2017/04/14/Kindle/</url>
    <content><![CDATA[<p>2016年1月6日 10:30:20。这篇笔记早就应该写了。其实就是汇总资源，网络链接等。</p>
<p>我记得当初决定购买 kindle 时，在网上查了好多资料。可能是因为 chrome 书签没有同步的问题，公司用的笔记本上找不到有关的网页。</p>
<p><a href="http://kindlefere.com/post/66.html">如何用最简单的方法批量删除 Kindle 云端电子书</a></p>
<p><a href="https://www.zhihu.com/question/27741189">Kindle 有哪些鲜为人知的使用技巧？</a><br>    ！<a href="http://www.douban.com/group/kindlemate/">Kindle标注笔记生词本管理器-Kindle Mate</a></p>
<p><a href="http://tieba.baidu.com/p/1976383035#">kindle 推送四种方式介绍及方法</a></p>
<a id="more"></a>

<h1 id="推送实测"><a href="#推送实测" class="headerlink" title="推送实测"></a>推送实测</h1><p>——使用其中第一种方法发送《软件需求规格说明书.docx》、《软件需求规格说明书.pdf》（后者由前者另存为所得），测试「不使用转换」单纯作为附件发送和「使用转换（将邮件主题写成“convert”）」的实际效果：</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>封面 &amp; 目录</th>
<th>图</th>
<th>表</th>
<th>前往目录</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>第一组</td>
<td>word 在 kindle 中查阅，目录排版合理，支持跳转；</td>
<td>其中 viso 图（非图片格式）不支持中文汉字，全部变为方框；</td>
<td>支持的比较好；</td>
<td>支持多级目录，支持第一级收缩；</td>
<td>不支持图。</td>
</tr>
<tr>
<td>第二组</td>
<td>支持跳转；</td>
<td>正常显示；</td>
<td>正常显示；</td>
<td>不支持；</td>
<td>不支持前往；需要放大。</td>
</tr>
<tr>
<td>第三组</td>
<td>不支持跳转；</td>
<td>没有；</td>
<td>没有；</td>
<td>不支持；</td>
<td>一无是处。</td>
</tr>
</tbody></table>
<ul>
<li>第一组：A0. word（测试的为.docx格式）版本是否将邮件主题写为“convert”，结果都一样，即 word 单纯作为附件发送就可以；（经过 convert 的文件会小一些，在阅读方面效果一致）</li>
<li>第二组：B0. 不进行转换的 pdf 文件，等比例缩小。显示方面一切正常，就是小了很多，好在 kindle 支持多点触控进行放大。</li>
<li>第三组：C0. 发送 pdf 文件，且进行“convert”转换。所有的元素全部变成纯文本，目录的跳转功能丢失，图、表的显示结构丢失。</li>
</ul>
<p>ps 详细效果图见 <a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Kindle/Kindle%E4%BD%BF%E7%94%A8%E9%82%AE%E7%AE%B1%E6%8E%A8%E9%80%81%EF%BC%8C3%E7%A7%8D%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94.rar">附件</a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，建议将 word 和 pdf 作为附件分别发送，word 使用“convert”主题，pdf 千万不要将邮件主题设为“convert”。正常阅读使用 word，如果偶尔遇到无法正常显示的内容，可以切换 pdf 版本。好麻烦的说 /(ㄒoㄒ)/~~</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Kindle/674033d8-471f-42bf-89be-bc460955e500.png" alt="推送结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外，中亚账号暂时不能用 send to kindle 的 web 插件和客户端。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>不同场景下的 Makefile</title>
    <url>/2016/12/09/Makefile2nd/</url>
    <content><![CDATA[<p>姊妹篇 <a href="https://tnie.github.io/2016/09/18/Makefile1st/">《Makefile 入门》</a> 中已经介绍过隐含规则、自动推导。要想在 make &amp; Makefile 上精进，必须了解其隐含规则。它可以让你省去很多繁琐、重复的细节，快速高效地完成项目的编译和链接。</p>
<p>隐含规则依赖同名（同名源文件-同名目标文件-同名可执行文件），一般而言设置好编译器属性、给出必要的头文件目录，就可以使用隐含规则生成同名的目标文件（.o 文件）；但实际项目中很少出现可执行文件由单独一个源文件/目标文件生成的情况，所以生成可执行文件（包括链接库）时一般不能只使用隐含规则达到目的。</p>
<a id="more"></a>

<h1 id="只有一个源文件"><a href="#只有一个源文件" class="headerlink" title="只有一个源文件"></a>只有一个源文件</h1><p>假设目录下只有 test.c 一个源文件。</p>
<h2 id="最简单的方式：（只使用隐含规则）"><a href="#最简单的方式：（只使用隐含规则）" class="headerlink" title="最简单的方式：（只使用隐含规则）"></a>最简单的方式：（只使用隐含规则）</h2><p>不写 Makefile 文件，直接执行 <code>make test</code>。可以看到： make（其实是默认生成的 Makefile 文件） 默认使用 cc 编译器（不是 gcc）。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">test.c</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test</span><br><span class="line">cc     test.c   -o test  ## Makefile 隐含规则生成的 gcc 执行语句，可以看到</span><br><span class="line"><span class="meta">#</span><span class="bash"> Makefile 倾向的书写方式</span></span><br></pre></td></tr></table></figure>
<p>当目录下存在 test.o 文件时直接执行 <code>make test</code> 命令</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">Makefile.bak  test.c  test.o</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test</span><br><span class="line">cc   test.o   -o test</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ </span><br></pre></td></tr></table></figure>
<p>可以看到 Makefile 隐含规则在<strong>生成可执行文件时</strong>倾向于将可执行文件放在命令的最后，即 <code>$&#123;CC&#125; $^ -o $@</code> 的形式。</p>
<p>扩展：我们看到上文中使用的都是 cc 编译器，我们更习惯 gcc/g++ 对不？而且有时候还需要给编译器指定参数，比如使用 c99 标准，怎么做呢？很简单，只需要在当前目录下新建以下 Makefile 文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定编译器和选项</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -std=c99</span><br><span class="line"></span><br><span class="line">CXX=g++</span><br><span class="line">CXXFLAGS=-Wall -std=c++11</span><br></pre></td></tr></table></figure>
<p>再次执行 <code>make test</code> 看看效果吧</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">Makefile  Makefile.bak  test.c  text.cpp</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test</span><br><span class="line">gcc -Wall -std=c99    test.c   -o test</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make text</span><br><span class="line">g++ -Wall -std=c++11    text.cpp   -o text</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$</span><br></pre></td></tr></table></figure>
<p>可以看到：Makefile 隐含规则会自动使用 <code>CC</code> 和 <code>CFLAGS</code> 变量，针对 <code>.cpp</code> 文件则自动使用 <code>CXX</code> 和 <code>CXXFLAGS</code> 变量。</p>
<p>也可以看出，直接使用源文件生成可执行文件时，更准确的格式是 <code>$&#123;CC&#125; $&#123;CFLAGS&#125; $^ -o $@</code>。</p>
<h2 id="最简单的-Makefile-文件："><a href="#最简单的-Makefile-文件：" class="headerlink" title="最简单的 Makefile 文件："></a>最简单的 Makefile 文件：</h2><p>其实最简单的 Makefile 文件就是没有 Makefile文件，其次就是上一节中“只指定编译器及选项”的 Makefile 文件。但也由于其太过简单，在实际生产中并不具备<strong>实用性</strong>。下面来看一个“麻雀虽小，五脏俱全”的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可执行文件</span><br><span class="line">TARGET&#x3D;test</span><br><span class="line"># 依赖目标</span><br><span class="line">OBJS&#x3D; test.o</span><br><span class="line"></span><br><span class="line"># 指定编译器和选项</span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-Wall -std&#x3D;c99</span><br><span class="line"></span><br><span class="line">.PHONEY:all clean</span><br><span class="line"></span><br><span class="line">all:$&#123;TARGET&#125;</span><br><span class="line"></span><br><span class="line"># 目标文件生成可执行文件</span><br><span class="line">$&#123;TARGET&#125;:$&#123;OBJS&#125;</span><br><span class="line">        $&#123;CC&#125; $^ -o $@</span><br><span class="line"></span><br><span class="line"># 使用隐含规则生成目标文件</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        $&#123;RM&#125; $&#123;TARGET&#125; $&#123;OBJS&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>make</code> 命令。可以看到：Makefile 隐含规则在<strong>生成目标文件时</strong>倾向于将源文件放在命令的最后，即 <code>$&#123;CC&#125; $&#123;CLFAGS&#125; -c -o $@ $&lt;</code> 的形式。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make</span><br><span class="line">gcc -Wall -std=c99   -c -o test.o test.c  ## Makefile 倾向的书写方式</span><br><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>
<h1 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h1><p>比如说三个：test.c test-add.c test-sub.c。这种情况下，我们只需要将上述 Makefile 文件中的“依赖目标”稍作修改即可（修改后的 Makefile 依旧适用之前的案例）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可执行文件</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="comment"># 扫描源文件</span></span><br><span class="line">SRCS=$&#123;wildcard *.c&#125;</span><br><span class="line"><span class="comment">#SRCS=test.c test-add.c test-sub.c</span></span><br><span class="line"><span class="comment"># 依赖目标</span></span><br><span class="line">OBJS=$&#123;SRCS:.c=.o&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器和选项</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -std=c99</span><br><span class="line"></span><br><span class="line"><span class="section">.PHONEY:all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:$&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件生成可执行文件</span></span><br><span class="line"><span class="section">$&#123;TARGET&#125;:$&#123;OBJS&#125;</span></span><br><span class="line">        $&#123;CC&#125; <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其隐含规则生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        $&#123;RM&#125; $&#123;TARGET&#125; $&#123;OBJS&#125;</span><br></pre></td></tr></table></figure>
<p><code>make</code> 执行结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">Makefile  test-add.c  test.c  test-sub.c</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make</span><br><span class="line">gcc -Wall -std=c99   -c -o test-add.o test-add.c</span><br><span class="line">gcc -Wall -std=c99   -c -o test-sub.o test-sub.c</span><br><span class="line">gcc -Wall -std=c99   -c -o test.o test.c</span><br><span class="line">gcc test-add.o test-sub.o test.o -o test</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ </span><br></pre></td></tr></table></figure>
<h1 id="目录分级-amp-头文件"><a href="#目录分级-amp-头文件" class="headerlink" title="目录分级 &amp; 头文件"></a>目录分级 &amp; 头文件</h1><p>目录结构如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ tree</span><br><span class="line">.</span><br><span class="line">├── test-add</span><br><span class="line">│   ├── test-add.c</span><br><span class="line">│   └── test-add.h</span><br><span class="line">├── test.c</span><br><span class="line">└── test-sub</span><br><span class="line">    ├── test-sub.c</span><br><span class="line">    └── test-sub.h</span><br><span class="line"></span><br><span class="line">2 directories, 5 files</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$</span><br></pre></td></tr></table></figure>
<p>其中 test.c 文件中如下引入头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test-add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test-sub.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="预处理错误"><a href="#预处理错误" class="headerlink" title="预处理错误"></a>预处理错误</h2><p>如果我们直接 <code>make test</code> 那么一定会报错 <code>test.c:2:22: fatal error: test-add.h: 没有那个文件或目录</code> 找不到头文件。我们可以通过以下方式解决这个错误：</p>
<ol>
<li><p>在 <code>make</code> 命令中指定参数：<code>make test CPPFLAGS=&#39;-Itest-add -Itest-sub&#39;</code>，因为参数中包含空格，所以必须用引号括起来。此时使用的仍然是 cc 编译器，我们可以在命令行中指定 <code>CC=gcc</code> 参数等等。</p>
</li>
<li><p>使用 Makefile 文件：我们延用第一节中的例子</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定编译器和选项</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -std=c99</span><br><span class="line"></span><br><span class="line">CXX=g++</span><br><span class="line">CXXFLAGS=-Wall -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给预处理器传参</span></span><br><span class="line">CPPFLAGS=-I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;</span><br><span class="line"><span class="comment"># CPPFLAGS=-I./test-add -I./test-sub    # 这么写也可以</span></span><br><span class="line"><span class="comment"># CPPFLAGS=&#x27;-I./test-add -I./test-sub&#x27;  # 这么写报错，为什么呢？</span></span><br></pre></td></tr></table></figure>
<p>上述的执行结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">Makefile  test-add  test.c  test-sub</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test</span><br><span class="line">gcc -Wall -std=c99 -I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;   test.c   -o test</span><br><span class="line">（作者备注：以下报错链接错误）</span><br><span class="line">/tmp/ccQlkvYC.o：在函数‘main’中：</span><br><span class="line">test.c:(.text+0x49)：对‘add’未定义的引用</span><br><span class="line">test.c:(.text+0x69)：对‘sub’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">&lt;builtin&gt;: recipe for target &#x27;test&#x27; failed</span><br><span class="line">make: *** [test] Error 1</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$</span><br></pre></td></tr></table></figure>
<h2 id="链接错误"><a href="#链接错误" class="headerlink" title="链接错误"></a>链接错误</h2></li>
</ol>
<p>我们使用第二节中的 Makefile，对“源文件”做相应修改就可：（当然也需要新添 <code>CPPFLAGS</code> 变量）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可执行文件</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="comment"># 扫描源文件</span></span><br><span class="line">SRCS=test.c \</span><br><span class="line">     test-add/test-add.c \</span><br><span class="line">     test-sub/test-sub.c</span><br><span class="line"><span class="comment"># 依赖目标</span></span><br><span class="line">OBJS=$&#123;SRCS:.c=.o&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器和选项</span></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -std=c99</span><br><span class="line">CPPFLAGS=-I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;</span><br><span class="line"></span><br><span class="line"><span class="section">.PHONEY:all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:$&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件生成可执行文件</span></span><br><span class="line"><span class="section">$&#123;TARGET&#125;:$&#123;OBJS&#125;</span></span><br><span class="line">        $&#123;CC&#125; <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其隐含规则生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        $&#123;RM&#125; $&#123;TARGET&#125; $&#123;OBJS&#125;</span><br></pre></td></tr></table></figure>
<p>成功执行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make</span><br><span class="line">gcc -Wall -std=c99 -I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;  -c -o test.o test.c</span><br><span class="line">gcc -Wall -std=c99 -I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;  -c -o test-add/test-add.o test-add/test-add.c</span><br><span class="line">gcc -Wall -std=c99 -I&#x27;./test-add&#x27; -I&#x27;./test-sub&#x27;  -c -o test-sub/test-sub.o test-sub/test-sub.c</span><br><span class="line">gcc test.o test-add/test-add.o test-sub/test-sub.o -o test</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ </span><br></pre></td></tr></table></figure>
<h1 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h1><h2 id="系统共享库"><a href="#系统共享库" class="headerlink" title="系统共享库"></a>系统共享库</h2><p>如果使用到系统共享库又该怎么做呢？我们知道共享库是用在链接阶段的，参考第一节，在隐含规则中 <code>CPPFLAGS</code> 是传给预处理器的，<code>CFLAGS</code> 是传给编译器的，相应的传给链接器的变量是 <code>LDLIBS</code>。</p>
<p>假设 test.c 源文件中调用了 <code>#include &lt;math.h&gt;</code> 的 <code>sin()</code> 函数，那么只需要在链接时指定 <code>LDLIBS=-lm</code> 即可：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">test.c</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test.o  # 编译阶段不需要任何特殊处理</span><br><span class="line">cc    -c -o test.o test.c</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test    # 报链接错误</span><br><span class="line">cc   test.o   -o test</span><br><span class="line">test.o：在函数‘main’中：</span><br><span class="line">test.c:(.text+0x34)：对‘sin’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">&lt;builtin&gt;: recipe for target &#x27;test&#x27; failed</span><br><span class="line">make: *** [test] Error 1</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ make test LDLIBS=-lm  # 使用 libm.so 库</span><br><span class="line">cc   test.o  -lm -o test</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ls</span><br><span class="line">source_learn  test  test.c  test.o</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ ./test </span><br><span class="line">sin(30.00)=0.50</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn$ </span><br></pre></td></tr></table></figure>

<h2 id="自定义共享库"><a href="#自定义共享库" class="headerlink" title="自定义共享库"></a>自定义共享库</h2><p>在使用 make &amp; Makefile 文件生成可执行文件过程中，使用系统共享库和自定义共享库的区别在于：后者需要使用 <code>LDFLAGS</code> 变量指定路径。</p>
<p>运行可执行文件又会有一些区别，关于链接库更多的知识请移步 <a href="https://tnie.github.io/2016/12/09/library-static-dynamic/">《共享库 &amp; 静态库》</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>整篇笔记的结构以及用到源码参考自 <a href="http://blog.csdn.net/xukai871105/article/details/37083675">例说makefile</a>。但此系列笔记有两个不足之处：</p>
<ol>
<li><p>原文中的 <code>DLIBS</code> <code>INC</code> 其实就是 <code>LDLIBS</code> 和 <code>CPPFLAGS</code> 变量。</p>
<ul>
<li>虽说如果不使用隐含规则，只是显式地使用，这些变量随便起什么名字都可以；</li>
<li>但既然使用 Makefile &amp; make，那么完全放弃使用隐含规则有“大器小用”之嫌，和单纯使用 shell 脚本还有区别吗？</li>
<li>使用 Makefile 的隐含规则，就应该使用 <a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">其隐含规则用到的变量</a>（限于 GNU make）；</li>
<li>在 <a href="http://xahlee.info/UnixResource_dir/_/ldpath.html">Why LD_LIBRARY_PATH is bad</a> 中提到的 <code>LD_RUN_PATH </code> 变量，在隐含规则中是否生效？</li>
<li>DLIBS INC 是其他 make （非 GNU make）的预定义变量吗？</li>
</ul>
</li>
<li><p>原文中讲到自定义共享库时并没有细致划分 soname、linker name、real name。这个只是小瑕疵</p>
</li>
</ol>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 执行过程 &amp; include 调用方式</title>
    <url>/2017/04/26/Makefile3rd/</url>
    <content><![CDATA[<p>2015年12月8日 16:48:31</p>
<p>此中测试代码见笔记 <a href="/2016/09/18/Makefile1st/">《Makefile入门》</a></p>
<h1 id="Makefile-之执行过程"><a href="#Makefile-之执行过程" class="headerlink" title="Makefile 之执行过程"></a>Makefile 之执行过程</h1><ol>
<li>依次读取变量“MAKEFILES”定义的 makefile 文件列表 </li>
<li>读取工作目录下的 makefile 文件（根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个） </li>
<li>依次读取工作目录 makefile 文件中使用指示符“include”包含的文件 </li>
<li><em>查找重建所有已读取的 makefile 文件的规则（如果存在一个目标是当前读取的某一个 makefile 文件，则<strong>执行此规则重建此 makefile 文件</strong>，完成以后从第一步开始重新执行）</em> </li>
<li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支 </li>
<li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表 </li>
<li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件） </li>
<li>执行“终极目标”所在的规则</li>
</ol>
<a id="more"></a>

<h1 id="include-调用方式"><a href="#include-调用方式" class="headerlink" title="include 调用方式"></a>include 调用方式</h1><p>Makefile 中 include 的调用方式：（针对 include，不考虑 -include、sinclude）</p>
<ol>
<li><p>首先在指定的目录下搜索被调用文件（如果没有路径，则为当前目录）</p>
</li>
<li><p>如果没有找到，则从 <code>-I</code> 所指定的 include 目录查找，如果还没找到，则从“/usr/gnu/include”“/usr/local/include”等目录查找</p>
</li>
<li><p>最终结果还是没找到，则 Makefile 输出异常信息 “No such file or directory”。</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/1.png" alt="测试"></p>
<p> ps：橙色标注部分，追求细节的话依赖目标不应该空着。</p>
<p> 以上操作对应 Makefile 执行过程中第 3 步，然后执行第 4 步：</p>
</li>
<li><p>Makefile 中<strong>存在一个目标是当前读取的某一个 makefile 文件，执行此</strong>规则来生成对应文件，例如本例中的规则为：</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/2.png" alt="测试"></p>
<p> 则根据该规则生成 .depend 文件。（此步骤亦可理解为：Makefile 会试图寻找匹配规则来生成对应文件）</p>
<p> Makefile 继续执行，此例成功执行完毕。</p>
</li>
<li><p>如果没有对应规则，输出错误信息 “make: *** No rule to make target `non-exit-file’.  Stop.”。Makefile 终止执行。</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/3.png" alt="测试"></p>
</li>
</ol>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>如果弄懂了以上内容，那么应该很轻易能够明白下图中 “all: .depend…” 的写法没有意义。</p>
<p>——因为 “include .depend” 会先于 根据“终极目标”展开依赖关系 执行，且如有必要 include 操作会自主生成 .depend 文件，然后将 .depend 文件中的依赖关系在主 Makefile 中展开。</p>
<p>此后若再重新生成 .depend 文件（？），已经没有操作需要此文件了（clean 可能会）。只有等到下一次执行 Makefile 时用到，却可能造成某种不确定性的干扰。</p>
<p>？：如果 .depend 的依赖目标为空，如以上截图所示，则会重新生成；如果 .depend 的依赖目标如下图所示，为源文件，则不会重新生成。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/4.png" alt="测试"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考：<a href="http://www.cnblogs.com/yyangblog/p/4159778.html">说说Makefile那些事儿</a>、<a href="http://blog.csdn.net/duanbeibei/article/details/2910845">Makefile自动依赖</a>（ps：这篇帖子中提到的“Makefile中include的调用方式：”与我实际验证有出入，已在笔记中说明。）</p>
<p>其中“程序首次编译时肯定不存在.depend文件，但这时makefile也不需要该文件，因为首次编译肯定连接的都是最新文件。也就是说首次编译时生成的.depend文件其实没用上，而是留作以后有了改动，比如更改了.h文件中的宏变量，则此时可根据.depend中的依赖关系只生成对应的.o文件了” 完全是错误的。</p>
<p>makefile需要 .depend文件，在执行gcc 指令之前就已生成了 .depend文件。展开说一下“以后有了改动…”，头文件改动：a. 改动文件名，则 $(SRCS) 中的文件肯定相应改动（不改动生成.o目标文件时报错），则 .depend <strong>和</strong>其中描述的目标文件，即 $(OBJS) 重新生成；b. 改动文件内容，则 .depend 中描述的目标文件，即 $(OBJS) 重新生成。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/5.png" alt="测试"></p>
<p>看一下 .depend文件内容：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/makefile3rd/6.png" alt="测试"></p>
<p>以上足以说明<strong>首次编译时生成的 .depend 文件妥妥的用上了！！</strong></p>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>翻越“伟大的”墙</title>
    <url>/2017/03/26/OverGFW/</url>
    <content><![CDATA[<p>用过哪些梯子？XX-Net、Shadowsocks、eg.</p>
<h1 id="XX-Net"><a href="#XX-Net" class="headerlink" title="XX-Net"></a>XX-Net</h1><p>2016年1月14日 16:43:12</p>
<p>下午花了一个小时左右的时间，重新搭梯子。翻墙成功，很开心。</p>
<p>最开始是因为搭建 Android 开发环境，在线下载更新 Android 版本时，老是失败，前后花费了一周的时间。气急败坏地很是不爽政府为什么要屏蔽谷歌。另外，平时搜索技术性的疑难杂症，百度真心水的一般，谷歌却永远在墙的另一边。</p>
<a id="more"></a>

<ol>
<li><p>那时候初次折腾翻墙，用的 chrome 浏览器，搭配谷歌的 GoAgent。发现世界可以这样，O(∩_∩)O~</p>
<p> 后来因为大陆封锁加强，GoAgent 就不好用了，全是红黄文，连接失败。GoGoTest 也不好用，需要手动操作太多了。</p>
</li>
<li><p>断断续续用自由门，从 7.4 用到了现在的 7.57，所谓一键翻墙，其实弊端也不少。对动态网无感，有些抵触。</p>
<p> 因为大陆的封锁加强，自由门也处于疯癫的状态，成功翻出去的几率 30%。翻出去了还好，关闭的时候系统代理改回默认；没翻出去，系统的代理被改掉，没改回来，你就等着上不去网吧，为知笔记也同步不了（默认使用 IE 代理），dota2 也会出状况……将 ie 重置，电脑重启就好了。</p>
</li>
</ol>
<p>总之，就是梯子不好用，所以从七八月份到最近几天，基本没有爬过梯子，都是在墙内安生的过活，网购、游戏、工作。倒是手机，因为想用 Wikipedia，偶尔使用 VPN 翻过几次，挺顺利的。</p>
<p>很长一段时间在用 kindle 看书，昨天想折腾一下 kindle 更丰富的推送功能，比如 PC 推送、浏览器推送、微信推送等</p>
<ol>
<li>PC 推送黄了，Amazon  官方的Send To Kindle for PC 只适用于 .com 美亚上的设备，哥的 kindle 设备当然是在 .cn 中国亚马逊上。</li>
<li>浏览器推送，官方插件因为同样的原因折了。找到一个 klip.me 插件，折腾了小半天不好用，最终发现也是墙的问题 /(ㄒoㄒ)/~~</li>
<li>微信推送及其他的移动端的就别提了，哥用的 WP，谁会搭理这种小众系统啊</li>
</ol>
<p>所以，今天心里就痒痒了，上网偶然发现 XX-Net 这款工具，在 GitHub 也有版本控制。简直大爱啊。<br>XX-Net 号称接力 GoAgent 的翻墙工具！ <a href="https://github.com/XX-net/XX-Net">https://github.com/XX-net/XX-Net</a> </p>
<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>2016/3/24 9:59:16</p>
<p>更新，在打算正式使用 Dropbox 之后，发现通过 XX-Net 无法进行代理（可能折腾些也可以）。</p>
<p>总结，一年来在翻墙找梯子这件事上投入的时间和精力其实挺多的，主要是墙和梯子互相斗智斗勇，而免费的手段经常会不稳定；而我要用的应用，越来越倾向于国外的，偏偏大多还被墙了，搞不懂政府为什么会屏蔽 Delicious、Dropbox 这些，保护本地互联网企业吗</p>
<p>一个星期之前，在 <a href="http://bandwagonhost.com/">http://bandwagonhost.com/</a> 上花费 18 元/月租了一台 VPS，一键安装 Shadowsocks 之后开启了付费翻墙的大门，目前体验良好。ss 客户端也在笔记本开机启动，常驻后台了，当然使用的 PAC 模式。常用的 QQ、即时通自然使用的是无代理模式，目前唯一疑惑的是 wiz 笔记同步时走的什么流量？不过一个月 500G 妥妥的也是够用的</p>
<p>备注：使用 Shadowsocks 的 PAC 模式，是不需要再重复使用 SwitchOmega 的，两者的定位是重复的。Chrome 减少一个插件也是减负了</p>
<p>也一键安装了 OpenVpn，在电脑和安卓手机上安装客户端并进行配置着实花费了些时间，主要是安卓手机想要翻墙下载些违禁应用真心没有经验。不过目前效果并不理想：</p>
<ol>
<li>PC 上 openvpn 连接不成功时，多尝试几次。如果还是不行，把 SS 关掉再尝试 ~有一次开着 SS 也是连接成功了的</li>
<li>Android 上使用 openvpn 连接未成功；</li>
<li>Android 上开启 SS 后，浏览器成功翻墙，但是 Dropbox 依旧登录不上；</li>
</ol>
<p>另，在一下午的操作过程中，尝试笔记本 wifi 共享也挺折腾的，共享精灵和驱动人生的捆绑软件 160wifi 都失败了，后来使用的猎豹 wifi 共享，其中的原因不想折腾了。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>PKM &amp; GTD</title>
    <url>/2016/08/26/PKM%20&amp;%20GTD/</url>
    <content><![CDATA[<p>个人知识管理（PKM）和时间管理（GTD），是很重要的。日常生活学习中肯定有零散的涉及到，但并无系统性、条理性的认识。有关的概念也是近两年才接触到，网上能搜到的东西很多，但太知识性的、深度的“规范”针对普通人又不具有实用价值，即，适当的掌握概念，按照“规则”整理知识，规划时间做事是有价值的，提升会很明显，但对于普通人来说并无掌握其原理的必要，简单的拿来用就可以了。过犹不及。</p>
<p>最重要的是<strong>坚持</strong>。</p>
<p>无论用什么方式，纸笔也好，还是 APP 也好，重要的是坚持，养成习惯。不能三天打鱼两天晒网。</p>
<p>我自己使用过，或正在使用的工具：</p>
<ol>
<li><p>思维导图工具：<a href="https://www.mindjet.com/mindmanager/">mindjet</a></p>
<p> 最初半年的使用频率非常高，慢慢地到现在一两个月甚至用不上一次。工作、生活过程中记录事情，现在更习惯用列表，是思维固化了？还是这半年涉及的场景不需要发散性的思维？</p>
</li>
<li><p>GTD 工具：<a href="http://doit.im/cn/">doit.im</a>，到 <a href="https://www.any.do/">any.do</a>，再到接触 <a href="http://www.thefabulous.co/">Fabulous</a> 之后简单的使用纸笔记录</p>
<p> 挺好用。坚持得不够，买了一年的会员，高频率使用了半年，闲置了半年之后销户了。直到今天，在 Fabulous 中见到一段话，直戳痛点：</p>
<blockquote>
<p>别掉入<strong>无止境清单症候群</strong>的圈套。换句话说，当你加入太多待办事项，你只会完成最容易的几项。</p>
<p>（而）迅速完成容易的事项会让你有种虚假的成就感。你会发现忙碌了一整天以后，其实并没有在你的终极目标上取得多少进展。</p>
<p>必须养成专注的性格。选择最重要的几件事项，然后除掉其他（相对来说不重要的）。</p>
</blockquote>
<p> doit 我没能坚持下来就是因为错误的使用方式。每天罗列好多的内容，带来虚假的成就感；每天完成一些（大多是最容易的），看着任务打上对勾，被划掉，带来虚假的成就感。甚至为了“打对勾，划掉”写上已经完成的事项，写上不重要的、做不做并无关键区别、随手就能解决、非关键任务等等类似的内容。然后把上午、下午大块大块的完整时间用来处理这些个“自讨的”琐碎任务，以“划掉多少”等价“成就多少”。好脆弱的内心，好虚假的幻想！随着时间的积累（也就是半年），doit 列表中堆积了大量的待办事项，而且都是筛选之后需要花费一定时间、精力并且有意义的事情，积累的越多越是提醒着自己的失败。潜意识里回避真相，现实世界里就做出“不再使用这款工具”的决定。关键问题在于：</p>
<ul>
<li><p>罗列待办事项清单之后，安排事项处理顺序、处理日期不合理，对自身解决问题的能力没有清晰的认识，“拍脑袋”定日期；</p>
<ul>
<li>也就是：不抓重点，或者抓不住重点。精力有限，肯定要做取舍。</li>
</ul>
</li>
<li><p>（因此）计划制定完之后，并不能严格的执行，做不到日清月清，更谈不上总结；</p>
<p>这也是放弃 doit 使用 any.do 之后没多长时间，又放弃 any.do 而使用 Fabulous/纸笔的原因，如果纠正不了根本问题，依旧还会在工具之间跳来跳去，在一个工具上遗留大量的未完事务之后迁移到另一个工具，如此循环，一直得不到解脱。类似的应用层出不穷，上文提到的 3 个是非常棒的了，用好一个就能给生活带来质变，不要因为<strong>错误的习惯</strong>埋没、错过了。</p>
<p>收集任务是前提；<strong>安排任务是关键；</strong>完成任务是目的。不能把时间浪费在“前提”上，在<strong>对自身解决问题的能力有清晰的认识</strong>的基础上，以<strong>量力而行、轻重缓急</strong>为原则<strong>制定当日计划</strong>是重中之重。</p>
<p>制定计划，包含完成时间，还<strong>隐含完成的能力</strong>，而不单单是罗列待办事项，想到的就罗列出来，不管今天能不能完成，今天想到的就列到今天的待办事项里，没有这么无脑操作。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>POD 类型</title>
    <url>/2016/12/15/POD/</url>
    <content><![CDATA[<p>POD 类型是一个神神道道的概念，有点反人类。好在大多时候我们并不需要涉及这个概念，即便在一些场景中用到了，C++11 新增的 3 个与之有关的判断也足够了。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>关于这个概念，在 C++11 之前使用了很多的限定来概括出它（貌似源于《imperfect c++》）。C++11 则给出了新的定义。关于其限定，我整理了 <a href="https://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">维基百科 - pod</a> 得到下图：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/POD%20%E7%B1%BB%E5%9E%8B.jpeg" alt="POD 类型"> </p>
<p>这个其实是用思维导图软件 Mindjet 做的，<a href="https://github.com/tnie/MarkdownPhotos/raw/master/mmap/POD%20%E7%B1%BB%E5%9E%8B.mmap">原稿下载</a>。用思维导图来整理 pod 的概念比 markdown 更合适。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>表达式</th>
<th>POD类型T</th>
<th>non-POD类型T</th>
</tr>
</thead>
<tbody><tr>
<td>new T</td>
<td>不初始化</td>
<td>缺省初始化</td>
</tr>
<tr>
<td>new T()</td>
<td>缺省初始化</td>
<td>缺省初始化</td>
</tr>
<tr>
<td>new T(x)</td>
<td>调用构造函数初始化</td>
<td>调用构造函数初始化</td>
</tr>
</tbody></table>
<p>我们以最简单的 POD 类型（使用内置类型 int）进行举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i；    <span class="comment">// 分配内存，但不进行初始化，其内存块存储为“垃圾值”</span></span><br><span class="line">int i()；  // 如果这种形式存在/正确的话，其执行默认初始化，赋值 someone</span><br><span class="line">           <span class="comment">// 但事实上，语法上更倾向于将其解释成返回 int 的函数声明</span></span><br></pre></td></tr></table></figure>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><p>关于 C++11 对 pod 的重新定义及相关函数，可以参考 <a href="http://blog.csdn.net/aqtata/article/details/35618709">C++11：POD数据类型 - csdn</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否满足平凡的定义</span></span><br><span class="line"><span class="built_in">std</span>::is_trivial&lt;A&gt;::value</span><br><span class="line"><span class="comment">// 是否是标准布局</span></span><br><span class="line"><span class="built_in">std</span>::is_standard_layout&lt;A&gt;::value</span><br><span class="line"><span class="comment">// 是否是 pod 类型</span></span><br><span class="line"><span class="built_in">std</span>::is_pod&lt;A&gt;::value</span><br></pre></td></tr></table></figure>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>从实用性的角度来说，我们更应该关注 pod 类型的用途，而非强调其概念。一方面区分其概念很耗费心力；另一方面，我们已经看到 C++11 提供了函数，我们只需要调用就可以得到结果。我们将繁复的工作交给机器，从而解放头脑和双手。</p>
<blockquote>
<p>POD通常被用在系统的边界处，即指不同系统之间只能以底层数据的形式进行交互，系统的高层逻辑不能互相兼容。</p>
<p>POD类型在源代码兼容于ANSI C时非常重要。POD对象与C语言的对应对象具有共同的一些特性，包括初始化、复制、内存布局、寻址。</p>
<p>POD类型是可以进行二进制拷贝的</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
  </entry>
  <entry>
    <title>父子进程</title>
    <url>/2017/03/17/Parent-Process-Child-xxx/</url>
    <content><![CDATA[<p>2016/6/21 17:52:03</p>
<p>参见 维基百科 词条：<a href="https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B">父进程</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E8%BF%9B%E7%A8%8B">子进程</a></p>
<p>关于僵尸进程和孤儿进程，在上述维基百科中也有提到，更详细的知识参考 <a href="http://www.cnblogs.com/Anker/p/3271773.html">孤儿进程与僵尸进程</a></p>
<a id="more"></a>

<blockquote>
<p>严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p>
</blockquote>
<p>也就是说，<strong>僵尸进程存在的前提是父进程不死</strong>。父进程死，僵尸进程就变成孤儿进程，没有危害 了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>RAII</title>
    <url>/2016/11/03/RAII/</url>
    <content><![CDATA[<p>在学习 C++ 的时候经常见到“资源获取即初始化”这句话。一直困惑这句话要表达的意思，是强调“资源获取”还是强调“初始化”，字面意思：获得系统资源这个行为就是“初始化”。不理解到底是指什么。</p>
<h1 id="维基百科怎么说？"><a href="#维基百科怎么说？" class="headerlink" title="维基百科怎么说？"></a>维基百科怎么说？</h1><p>我们看 <a href="https://zh.wikipedia.org/wiki/RAII">RAII-Wikipedia</a> 中的叙述：</p>
<blockquote>
<p> RAII全称为Resource Acquisition Is Initialization，它是在一些面向对象语言中的一种惯用法。XX 在设计C++异常时，为解决资源管理时的异常安全性而使用了该用法。</p>
</blockquote>
<blockquote>
<p>RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配(获取)，同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p>
</blockquote>
<a id="more"></a>

<p>结合维基百科中给的例子，知道了是怎样的使用形式：<strong>将资源抽象为类，用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。</strong>——而这是之前就接触过得。虽然不知道 RAII，但它一直就在我们编写代码的过程中。</p>
<h1 id="什么是资源？"><a href="#什么是资源？" class="headerlink" title="什么是资源？"></a>什么是资源？</h1><p>参考 <a href="http://www.jellythink.com/archives/101">C++中的RAII机制</a>，</p>
<blockquote>
<p>在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：</p>
<ol>
<li>申请资源；</li>
<li>使用资源；</li>
<li>释放资源；</li>
</ol>
<p>第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。</p>
</blockquote>
<p>多数情况下，资源是不具备拷贝语义的，所以，RAII临时对象一般也<strong>不允许复制和赋值</strong>。网上能够看到的示例代码，包括 <a href="http://www.jellythink.com/archives/101">C++中的RAII机制</a>，大都是将拷贝构造函数、拷贝赋值运算符设置为 <code>private</code> 私有，但在 C++11 新标准中是存在 <code>delete</code> 关键字，可以将此函数设置为 <code>delete</code> 的。</p>
<p>RAII机制是进行资源管理的有力武器，C++程序员依靠RAII写出的代码不仅简洁优雅，而且做到了异常安全。</p>
<h1 id="new-怎么办？"><a href="#new-怎么办？" class="headerlink" title="new 怎么办？"></a>new 怎么办？</h1><p><a href="http://blog.csdn.net/yapian8/article/details/44980949">RAII(资源获取即初始化)详解</a>，这篇介绍中提到：（注意，此篇文章中好多代码示例细节不到位，有错误。而且并没有使用新标准。）</p>
<blockquote>
<p>一般情况下，RAII临时对象不允许复制和赋值，当然<strong>更不允许在heap上创建</strong></p>
</blockquote>
<p>给出的示例中也将 new 操作符设置为 <code>private</code> 私有的。道理是通的，因为 RAII 惯用法就是利用“程序段（栈帧）中放置的对象的析构函数”，如果放在堆上，对象变成持久存在的，不能自动销毁……这样岂不是就又绕回到问题的原点了吗</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-idioms</category>
      </categories>
      <tags>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>事关 Windows 使用的零散备忘</title>
    <url>/2017/03/26/SomeMemosAboutWindows/</url>
    <content><![CDATA[<h1 id="Linux-On-Windows"><a href="#Linux-On-Windows" class="headerlink" title="Linux On Windows"></a>Linux On Windows</h1><p>2016/1/28 18:23:05</p>
<p>我知道标题这么表述是错误的，但要表达意思“在windows操作系统上使用linux特性、linux上的工具”是足够了的。列几个接触到工具：</p>
<ul>
<li><p>MinTTY</p>
</li>
<li><p>MSYS</p>
</li>
<li><p>Cygwin</p>
<blockquote>
<p>2016/3/14 19:30:31 cygwin 这种各方迁就的环境，能不用就不用。想要 *inux特性，直接用虚拟机装 Linux，没必要接触这种折中的方案。</p>
</blockquote>
</li>
</ul>
<p>2016/3/19 18:21:58 实践证明，在Windows上安装虚拟机跑Linux是更好的选择。</p>
<a id="more"></a>

<h1 id="E431-的触控板和-Fn-键"><a href="#E431-的触控板和-Fn-键" class="headerlink" title="E431 的触控板和 Fn 键"></a>E431 的触控板和 Fn 键</h1><p>2016/1/19 15:27:50</p>
<p>在你敲代码的时候，不小心碰触到触控板时间很恶心的事情。怎么关掉它？</p>
<p>跟高效率无关，但总有习惯用那么几个快捷键，比如 F5 刷新，Atl + F4 关闭当前窗口，但 E431 中 F5默认是调低屏幕亮度，坑爹！怎么修改？</p>
<p>首先，如果以下方法中涉及的截图和你电脑显示的不一样，那么你可能需要安装一些驱动。<a href="http://think.lenovo.com.cn/support/driver/newdriversdownlist.aspx?yt=pt&categoryid=11170&CODEName=ThinkPad%20E431&SearchType=0&wherePage=2&osid=243">官方驱动下载</a></p>
<ol>
<li>参考这篇帖子：<a href="http://tieba.baidu.com/p/2932571645">thinkpad E431触控板如何长期关闭</a> 10 楼“开水一直很白”的方法。其实也并不是真的关掉了触控板，只是更改了触控板的模式，使得其不会妨碍到我们。/(ㄒoㄒ)/~~ 如果我能找到开关的方法，我也不愿意用这种这种的方法啊。不过唯一的方法就是最好的方法！</li>
<li>网上如是说：<a href="http://www.gzitw.net/notebook/jiqiao/2014/1224/1524.html">ThinkPad笔记本Fn键关闭与启用</a>，然而并没有什么用啊，重启之后又变回原先的了，有啥用。难道我不会 Fn+Esc 吗？我就是想找一劳永逸的，不想每次开机都切换一下。</li>
<li>至于在 BIOS 中修改这种：<a href="http://jingyan.baidu.com/article/d5a880eb79034313f147cc23.html">联想笔记本如何关闭Fn功能键</a>，哥笔记本 BIOS 可能太弱智了，未提供有关选项。可能和 BIOS 版本有关</li>
</ol>
<p>结论就是，<strong>触控板可以调模式；Fn键你就难受着吧。</strong></p>
<p>总之，也没啥想说的。就一句“联想，你大爷！”</p>
<h1 id="设置输入法"><a href="#设置输入法" class="headerlink" title="设置输入法"></a>设置输入法</h1><p>2015年12月29日 10:18:19</p>
<p>从最开始使用 win8.1，到后来升级到 win10，以及断断续续的折腾，前后至少也有两年了。</p>
<p>从一开始就觉得微软自带的输入法细节方面做得不好，但能够满足日常简单的使用，不然也不会用了一两年才突然要换了。</p>
<p>在特定情境下让使用者非常难受，比如：</p>
<ol>
<li><p>我经常玩 dota2，可是微软中文输入法基本无法让你使用中文和小伙伴聊天。</p>
</li>
<li><p>另外，在 linux 终端以及 vim 编辑器下中英文切换也有问题：在终端或 vim 编辑器中敲入命令，这时输入法是中文，汉字打到一半，原则上按 shift 或 enter 都可以直接出英文的，但操作过程却会卡主机。</p>
<p> ——（要求输入英文，但是输入时未注意到使用的是中文输入法，敲了几个单词之后才发现，这时无论是不敲空格直接敲回车，还是直接点击 shift 切换中英文，都会有一段时间的卡死）</p>
<p> 笔记末尾还给出了一个相关案例。win8 的系统输入法会出现案例中的现象，个人实测。win7 可能没有问题，在网上未看到相关提问。</p>
</li>
<li><p>另一个问题，毕竟还是国外的产品，毕竟做得时间不长，在本土化（比如：词句成语诗词，日常使用语、日常语言习惯）方面，远不能和搜狗输入法相比。</p>
</li>
</ol>
<p>所以就有了以下问题：</p>
<ol>
<li>如何删除 win 系统自带的微软中文输入法？<a href="http://jingyan.baidu.com/article/48b558e3524bcd7f38c09ae1.html">win8.1 下如何删除系统自带输入法！</a></li>
<li>搜狗输入法也有让我不舒服的地方，不然也不会改用微软中文。虽然用了一两年之后还是放弃了，这种放弃主要是因为新工作使用 linux 的开发环境，以及在 dota2 和小伙伴聊天（玩 dota2 也是换工作之后的事）。比如不喜欢搜狗输入法安装包大，也不喜欢 QQ 那么大的安装包，不喜欢安装之后罗里吧嗦的设置，不喜欢桌面上多出来的状态栏…<a href="http://jingyan.baidu.com/article/154b46315d5aac28ca8f4119.html">如何隐藏搜狗输入法的状态栏</a></li>
</ol>
<p>此图截自 <a href="http://bbs.csdn.net/topics/390171529?page=1">vs2010在却换输入法的时候卡主，求解决。</a></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/vs2010-input-no-response.png" alt="问题原因 &amp; 解决方法"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/vs2010-input-no-response-2.png" alt="解决方法"></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>文本编辑器</title>
    <url>/2017/04/18/TextEditor/</url>
    <content><![CDATA[<p>2015年12月22日 14:10:39</p>
<h1 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h1><p>简介：摘自 <a href="https://zh.wikipedia.org/wiki/Notepad%2B%2B">维基百科 - Notepad++</a></p>
<blockquote>
<p>Notepad++是一套为自由软件的纯文本编辑器。该软件以 GPL 发布，有完整的中文化接口及支持多国语言撰写的功能（采用 UTF-8 编码）。它的功能比 Windows 中的记事本（Notepad）强大，除了可以用来制作一般的纯文字的帮助文档，也十分适合用作<strong>撰写计算机程序</strong>的编辑器。由6.2.3版本起，Notepad++的文件默认文字格式由ANSI改为除去BOM的UTF8（UTF8 without BOM）。Notepad++不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的插件。</p>
</blockquote>
<a id="more"></a>

<p>Notepad++ 支持众多计算机程序语言: C，C++，Make处理(Makefile) 等</p>
<h1 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h1><p>简介：谁都知道这款工具的强大。参考 <a href="http://www.ultraedit.cn/products/ultraedit.html">官方介绍</a></p>
<blockquote>
<p>UltraEdit 是理想的文本、HTML 和十六进制编辑器，也是高级 PHP、Perl、Java 和 JavaScript 程序编辑器。</p>
</blockquote>
<p>啰嗦两句，说一下注册的事情：在某个网站找到使用注册机激活的帖子，两篇帖子是姊妹帖。注册机已上传到 <a href="https://github.com/tnie/MarkdownPhotos/raw/master/texteditor/IDM%20All%20Products%20KeyGen%20v3.6.zip">附件</a> 中。</p>
<ul>
<li>开始时参考的是 <a href="">http://www.aiweibk.com/1573.html</a>，输入许可证和密码之后根本就不会出现脱机激活的按钮，当时以为是使用新版本的问题，卸载重装折腾了一中午。还是失败</li>
<li>后来发现姊妹篇 <a href="">http://www.aiweibk.com/1550.html</a>，基本一模一样，唯一的区别就是给出的许可证和密码不一样，成功！</li>
</ul>
<p>以下贴出正确的操作内容：（如果许可证、密码什么时候又不对了，在网上重新找）</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/texteditor/a361155e-14c4-45b9-ba10-d6c6645f86c2.png" alt="操作步骤"></p>
<h1 id="UltraCompare"><a href="#UltraCompare" class="headerlink" title="UltraCompare"></a>UltraCompare</h1><p>同上。使用注册机时，Program项选择“UltraCompare ###”。</p>
<p>以上操作使用的软件版本：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/texteditor/10828218.png" alt="软件版本"></p>
<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>维基百科上有一词条：<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%E5%99%A8%E6%AF%94%E8%BE%83">文件编辑器比较</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>UUID 入门</title>
    <url>/2017/07/04/UUID/</url>
    <content><![CDATA[<p>维基百科中描述：通用唯一识别码（英语：Universally Unique Identifier，简称UUID）的目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。</p>
<blockquote>
<p>目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID）</p>
</blockquote>
<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例：</p>
<pre><code>550e8400-e29b-41d4-a716-446655440000</code></pre>
<p>接下来重点描述在开发中的使用及应用。</p>
<h1 id="在-C-中的使用"><a href="#在-C-中的使用" class="headerlink" title="在 C++ 中的使用"></a>在 C++ 中的使用</h1><p>C++ 原生（C++03、C++11/0x）并不支持 UUID。所以要想在 C++ 代码中生成 UUID，如果要求跨平台推荐使用第三方库 Boost UUID，要么结合各自的平台，使用系统 API。以下方法整理自互联网，除 Boost Uuid 和 libuuid 使用过之外，其他的未亲自试验。</p>
<h2 id="UUID-generation-using-Boost-in-C"><a href="#UUID-generation-using-Boost-in-C" class="headerlink" title="UUID generation using Boost in C++"></a>UUID generation using Boost in C++</h2><p>在 StackOverflow 上的一个例子：<a href="http://stackoverflow.com/questions/3247861/example-of-uuid-generation-using-boost-in-c/3248017">跳转链接</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid.hpp&gt;            // uuid class</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid_generators.hpp&gt; // generators</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid_io.hpp&gt;         // streaming operators etc.</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::uuids::uuid uuid = boost::uuids::random_generator()();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uuid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续两个括号 <code>()()</code> 是什么鬼？是不是打错了？——首先，这么写是正确的。这种使用形式<strong>涉及到的语法意义</strong>要进一步地学习并掌握。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid.hpp&gt;            // uuid class</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid_generators.hpp&gt; // generators</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/uuid/uuid_io.hpp&gt;         // streaming operators etc.</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::uuids::random_generator generator;</span><br><span class="line"></span><br><span class="line">    boost::uuids::uuid uuid1 = generator();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uuid1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boost::uuids::uuid uuid2 = generator();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; uuid2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以上两个简单的例子满足不了你的需求，需要在更复杂的情景下使用，请移步 <a href="http://www.boost.org/doc/libs/1_60_0/libs/uuid/uuid.html">Boost Uuid 官方文档</a>。</p>
<h2 id="Qt-QUuid"><a href="#Qt-QUuid" class="headerlink" title="Qt QUuid"></a>Qt QUuid</h2><p><a href="http://blog.csdn.net/yasi_xi/article/details/9297565">参考来源</a></p>
<p>Qt是一个跨平台的C++编程框架，QUuid类实现了UUID的生成、比较、转换等功能。</p>
<p>函数QUuid createUuid()，可用于生成一个随即UUID。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QUuid&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QUuid uuid = QUuid::createUuid();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; qPrintable(uuid.toString()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linux-下生成-UUID"><a href="#Linux-下生成-UUID" class="headerlink" title="Linux 下生成 UUID"></a>Linux 下生成 UUID</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Unix/Linux环境中大都有一个名为uuidgen的小工具，运行即可生成一个UUID到标准输出。读取文件/proc/sys/kernel/random/uuid即得UUID，例如：</p>
<pre><code>cat /proc/sys/kernel/random/uuid</code></pre>
<h3 id="libuuid"><a href="#libuuid" class="headerlink" title="libuuid"></a>libuuid</h3><p><a href="http://blog.csdn.net/yasi_xi/article/details/9297565">参考来源</a></p>
<p>libuuid是一个用于生成UUID的C库，具体用法参考 <a href="">http://linux.die.net/man/3/libuuid</a>，示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uuid/uuid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uuid_t</span> uuid;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line">    uuid_generate(uuid);</span><br><span class="line">    uuid_unparse(uuid, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Linux下编译时需要链接uuid库</p>
<pre><code>gcc -o uuid uuid.c -luuid</code></pre>
<p><strong>问题： 在什么系统下自带？在什么系统中需要另行安装？</strong></p>
<p>在Ubuntu中，可以用下面的命令安装libuuid：</p>
<pre><code>sudo apt-get install uuid-dev</code></pre>
<h2 id="Windows-下生成-UUID"><a href="#Windows-下生成-UUID" class="headerlink" title="Windows 下生成 UUID"></a>Windows 下生成 UUID</h2><h3 id="CoCreateGuid"><a href="#CoCreateGuid" class="headerlink" title="CoCreateGuid"></a>CoCreateGuid</h3><p><a href="http://blog.csdn.net/yasi_xi/article/details/9297565">参考来源</a></p>
<p>Windows下提供了函数CoCreateGuid用于生成GUID。需要使用的头文件是”objbase.h”，需要链接的库是ole32.lib，函数原型为：</p>
<p>HRESULT CoCreateGuid(GUID *pguid);<br>GUID的原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Data1;</span><br><span class="line">    WORD Data2;</span><br><span class="line">    WORD Data3;</span><br><span class="line">    BYTE Data4[<span class="number">8</span>];</span><br><span class="line">&#125; GUID;</span><br></pre></td></tr></table></figure>
<h3 id="UuidCreate"><a href="#UuidCreate" class="headerlink" title="UuidCreate"></a>UuidCreate</h3><p><a href="http://stackoverflow.com/questions/24365331/how-can-i-generate-uuid-in-c-without-using-boost-library">参考来源</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;rpcrt4.lib&quot;</span>)  <span class="comment">// UuidCreate - Minimum supported OS Win 2000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UUID uuid;</span><br><span class="line">    UuidCreate(&amp;uuid);</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    UuidToStringA(&amp;uuid, (RPC_CSTR*)&amp;str);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    RpcStringFreeA((RPC_CSTR*)&amp;str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在-Java-中使用"><a href="#在-Java-中使用" class="headerlink" title="在 Java 中使用"></a>在 Java 中使用</h1><p>工作中偶尔会写一些 Java 的项目，所以也捎带整理一下。</p>
<h1 id="在-MySQL-中"><a href="#在-MySQL-中" class="headerlink" title="在 MySQL 中"></a>在 MySQL 中</h1><p>MySQL 本身是带有生成 uuid 功能的。也就是我们惯用的整数递增作为主键，其实是可以用 uuid 替代的。可以在一条记录插入之前写触发器，调用 UUID() 函数生成 uuid。</p>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制</title>
    <url>/2017/03/27/VersionControl/</url>
    <content><![CDATA[<p>2016年1月4日 17:23:45，和git有关的链接保存了很多，统一在这篇笔记里整理一下。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="https://git-scm.com/">Git</a></h1><ol>
<li><p>廖雪峰的官方网站之 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a></p>
</li>
<li><p>git@osc 官方推荐的 <a href="https://git-scm.com/book/zh/v2">ProGit</a>（中文版）</p>
<p> 首先推荐！其中对于 Git 的工作原理、工作特性的讲解是很到位的，恰到好处，既不深入以免让读者陷入原理的泥潭，毕竟大多只是把 Git 当做一种工具在用，但对于掌握 Git 的操作又非常有价值。如果熟悉一些 Git 的日常操作，想进一步理解 Git 的工作原理，推荐重点章节 1.3 Git 基础、2.2 记录每次更新到仓库的图2-1、3.1 何谓分支、3.2 分支的新建与合并【后续待定……因为暂时只看到这里】</p>
</li>
</ol>
<a id="more"></a>

<h2 id="Git-学习笔记"><a href="#Git-学习笔记" class="headerlink" title="Git 学习笔记"></a>Git 学习笔记</h2><p>最近想学点小知识，翻出了很久之前收藏的一篇链接-<a href="http://blog.jobbole.com/82633/">有哪些实用的计算机相关技能，可以在一天内学会？</a>。</p>
<p>第一篇是关于 Git 的。虽然我也用 Git，但一直以来都是 TortoiseGit，图形界面的东东，想通过这篇入门级的交互式教程，了解常用的 Git 命令。严格来说这不是学习笔记，只是在老老实实学完+实践完整个教程之后的几句总结，很少的几点。</p>
<ol>
<li><p>刚看前几节的时候，对一个问题比较困惑——“什么状态会是 unstaged 的呢？”</p>
<blockquote>
<p>后来了解了 git add -A./git add/git rm/git reset <filename>/git commit…/git checkout – <target>/ 命令，才明白长期使用图形界面，直接右击“提交”屏蔽了<strong>添加到 staging area</strong> 的细节。严格来说，每次 commit 之前都需要使用 add/rm 命令将修改提交到 staging area，也可以直接使用 commit -a(-all)。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Staging-Area.png"></p>
</blockquote>
</li>
<li><p>在 11 节中提到了 hooks，对此充满了探知的欲望。联想到以前见过的一篇关于 <a href="http://www.flickering.cn/uncategorized/2014/08/%E8%AE%A9-code-review%E6%88%90%E4%B8%BA%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF/">Code Review</a> 的帖子。</p>
</li>
<li><p>关于 <code>git diff</code> 命令知之甚少啊。在 kindle 上对此进行了标注，抽空看。</p>
</li>
<li><p>切换和检出：<code>git checkout branch_name</code> 和 <code>git checkout -- file_name</code>，双横杠的就是为了万一有文件名和分支名相同的情况，使用双横杠保证检出文件，而非切换分支。</p>
</li>
<li><p>在比较旧的系统上使用 git 时，因为无法使用 git 的较新版本，加之系统方面的某些默认配置，使用起来有诸多不便。不便之处及其解决方法，罗列如下：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [使用 git <span class="built_in">log</span>、git diff 命令时出现 ESC[33 和 ESC[m 乱码的解决办法][ref1]</span></span><br><span class="line">git config --global core.pager &quot;less -r&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> [让 git输出颜色变成彩色的方法][ref2]</span></span><br><span class="line">git config --global color.status auto  </span><br><span class="line">git config --global color.diff auto  </span><br><span class="line">git config --global color.branch auto  </span><br><span class="line">git config --global color.interactive auto  </span><br></pre></td></tr></table></figure>
<p> 使用 <code>git log</code>、<code>git diff</code> 命令时出现 <code>ESC[33</code> 和 <code>ESC[m</code> 乱码的<a href="http://blog.yongli1992.com/2015/08/14/git-log-diff-esc-garbled/">解决办法</a>、<a href="http://blog.csdn.net/cloudaice/article/details/7065142">让 git输出颜色变成彩色的方法</a></p>
</li>
<li><p>如何列出已经跟踪的文件？<code>git ls-files</code></p>
</li>
<li><p><code>git merge –squash</code> 合并分支时需要手动提交，给你修改 commit message 的机会（有时候开发分支上提交时非常随意）<a href="https://www.wanglianghome.org/2010/08/05/git-merge-squash/">git merge –squash介绍</a></p>
</li>
</ol>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://github.com/">GitHub</a></h1><ol>
<li><p><a href="https://wuyuans.com/2012/05/github-simple-tutorial">github 简单使用教程</a></p>
</li>
<li><p><a href="http://blog.csdn.net/lishuo_os_ds/article/details/8078475">GitHub 详细教程</a></p>
</li>
<li><p><a href="http://blog.jobbole.com/40097/">学生和教育人士可免费申请 Github 私有仓库</a></p>
<p> 链接：<a href="https://education.github.com/">GitHubEducation</a></p>
</li>
</ol>
<h1 id="Git-OSC"><a href="#Git-OSC" class="headerlink" title="Git@OSC"></a><a href="https://git.oschina.net/">Git@OSC</a></h1><p>在实际生产中碰到的问题： </p>
<ul>
<li><a href="/2017/04/18/GitOfOSC/">“Git@OSC 禁止推送大于 100M 文件”</a></li>
<li><a href="http://git.mydoc.io/?t=130991">commit 关联 issue</a>，其中关闭 issue、评论 issue，无论我怎么尝试都毫无反应。真尼玛坑爹！</li>
</ul>
<p>想用 GitHub，在大陆这样的环境却感觉爱不起。可以两个都喜欢： 将项目同时托管到 Github 和 Git@OSC</p>
<h1 id="Git-对比-SVN"><a href="#Git-对比-SVN" class="headerlink" title="Git 对比 SVN"></a>Git 对比 SVN</h1><p>git 和 svn 有什么不同？写于 2015年12月18日 16:58:27</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>老东家其实是个很没意思的公司，是做测控的，跟软件唯一说得上的关联就是使用 NI 公司的 labview、labwindows/cvi 工具，因为用的对方的 pci、pxi 板卡、工控机等。和 c++ 无关，和 Java 无关，和互联网更是八竿子都擦不上个边。</p>
<p>就上面提到的两个开发的工具，还是个别人员在用，反正我没用。关于做软件，身边没有环境，没有团队，井底之蛙，好好的科班出身，差点就废了。也亏了学校的背景，在两年的“空”软件开发工作经验之后，依然能够有幸找到一家做软件的公司，linux 下的 c++ 开发。</p>
<p>两年里无人引路，自学自用了 git，开始时困于 windows 下 git 服务搭建，后来开始使用网上的版本管理网站，比如 github（不怎么用）、bitbucket（已不再用）、oschina（主要在用）。操作的话使用 tortoise 替代原生的命令操作，也很方便。</p>
<p>新公司用的 svn，目前用的很形式化，也就是说做版本管理大体上是个面子工程，领导让用所以就应付着上传代码，能应付过去就 ok 了。</p>
<p>如果要介绍两者的区别，除了使用者的立场，还应该考虑公司的出发点。</p>
<h2 id="个人使用选择-git，还是-svn？为什么？"><a href="#个人使用选择-git，还是-svn？为什么？" class="headerlink" title="个人使用选择 git，还是 svn？为什么？"></a>个人使用选择 git，还是 svn？为什么？</h2><p>——我选git，因为个人习惯，更因为 svn 不联网居然不能提交，<del>不能做版本管理</del>。svn 单机也可以做版本管理，参考：<a href="http://blog.csdn.net/xgbing/article/details/7393692">不安装 SVN 服务器，使用 TortoiseSVN 创建单机版的 SVN</a>，其实还是个 c/s 结构，在本机上建立个服务目录。</p>
<p>——所以呀，没有明显区别、明显优势的情况下，就是个使用习惯的问题。手头的技能能用、够用，大多数人不愿意花时间、精力去 get 新技能的。</p>
<p>网上百度一下，出现频率最多的应该就是这篇了<a href="http://blog.jobbole.com/31444/">《Git 和 SVN 之间的五个基本区别》</a>：</p>
<ol>
<li>GIT 是分布式的，SVN 不是；</li>
<li>GIT 把内容按元数据方式存储，而 SVN 是按文件；</li>
<li>GIT 分支和 SVN 的分支不同；</li>
<li>GIT 没有一个全局的版本号，而 SVN 有；</li>
<li>GIT 的内容完整性要优于 SVN；</li>
</ol>
<p>另外，个人想卸载掉 TortoiseGit，练习以熟悉 git 的命令行模式，有一点担心的地方在于 差异对比的可视化方面图形界面显然比命令行好很多。</p>
<h2 id="公司选择git，还是svn？又是为什么？"><a href="#公司选择git，还是svn？又是为什么？" class="headerlink" title="公司选择git，还是svn？又是为什么？"></a>公司选择git，还是svn？又是为什么？</h2><p>这方面找到蒋鑫的一篇，<a href="http://blog.jobbole.com/20069/">《蒋鑫：为什么 Git 比 SVN 好》</a>，主要企业用户对 SVN 的迷信和对 Git 的误解，当年刚接触 git 时看的就是他写的关于 git 的一本书。</p>
<p>还有一篇是说 svn 的，<a href="http://developer.51cto.com/art/201312/423195.htm">《SVN 有任何胜过 git 的地方吗？》</a>，作者力证虽然 git 比svn好，但是 svn 也不是一无是处的，怎么感觉怪怪的…</p>
<h1 id="GitSVN"><a href="#GitSVN" class="headerlink" title="GitSVN"></a>GitSVN</h1><p>当 Git SVN 混用（比如终端开发使用 git 管理，但公司要求提交到中心仓库 svn）时，<strong>不要使用</strong> git submodule 特性，不要使用 svn external 特性。另外，删除 submodule 不易。 </p>
<ul>
<li>从 svn 迁出到 git 仓库，git svn 命令相对容易上手</li>
<li>将 git 仓库提交到 svn，<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Pushing an existing Git repository to SVN</a></li>
</ul>
<p>over</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>开发 Java 项目（日志网关）用到的网址汇总</title>
    <url>/2016/11/02/aboutJavaProj/</url>
    <content><![CDATA[<p>不打算在 Java 方向上投入精力，但是工作中又免不了涉及有关的开发任务。在此整理、汇总一些链接，希望给日后有关 Java 的工作带来方便。</p>
<a id="more"></a>

<h1 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><a href="https://www.javacodegeeks.com/2015/03/jdbc%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html">JDBC入门教程 – 终极指南</a></li>
<li><a href="http://blog.csdn.net/gavid0124/article/details/44587209">java中Map和List初始化的两种方法 - csdn</a></li>
<li><a href="http://blog.csdn.net/tjcyjd/article/details/11111401">Java中如何遍历Map对象的4种方法 - csdn</a></li>
<li><a href="http://blog.csdn.net/nvd11/article/details/36727435">数据流DataInput(Output)Stream 和 字节数组流 ByteArrayInput(Output) Stream - csnd</a></li>
</ul>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>跌的很疼的跟头，全部来自 stackoverflow：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/18544830/java-equals-between-string-and-stringbuilder">Java .equals between String and StringBuilder</a></li>
<li><a href="http://stackoverflow.com/questions/18565701/stringbuilder-equals-java">StringBuilder .equals Java</a></li>
</ul>
<h2 id="日志解决方案"><a href="#日志解决方案" class="headerlink" title="日志解决方案"></a>日志解决方案</h2><p>slf4j+log4j，Apache Flume</p>
<h3 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a><a href="http://www.slf4j.org/">slf4j</a></h3><blockquote>
<p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p>
</blockquote>
<ul>
<li><p><a href="http://dyygusi.iteye.com/blog/2118469">slf4j日志的使用</a></p>
<blockquote>
<p> slf4j(simple logging facade for java)是Java的简单的日志门面，它不是具体的日志解决方案，它只服务于各种各样slf4j-logo的日志系统。这里的slf4j-logo可以是log4j,可以是jdk的日志，可以是logback，还可以是slf4j-simple等等。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p>
</blockquote>
</li>
</ul>
<h3 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h3><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-log4j/">使用Log4j进行日志操作 - IBM developerWorks</a></li>
<li><a href="http://blog.csdn.net/evankaka/article/details/45815047">Log4j详细使用教程 - csdn</a></li>
</ul>
<p>关于配置文件的，全部源于 stackoverflow：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/12579468/how-to-set-log4j-property-file">How to set log4j property file?</a></li>
<li><a href="http://stackoverflow.com/questions/2772466/where-to-place-log4j-xml">Where to place log4j.xml</a></li>
<li><a href="http://stackoverflow.com/questions/2594689/external-log4j-xml-file">External log4j.xml file</a></li>
</ul>
<h3 id="Apache-Flume"><a href="#Apache-Flume" class="headerlink" title="Apache Flume"></a><a href="http://flume.apache.org/FlumeDeveloperGuide.html">Apache Flume</a></h3><blockquote>
<p>Apache Flume is a distributed, reliable, and available system for efficiently collecting, aggregating and moving large amounts of log data from many different sources to a centralized data store.</p>
</blockquote>
<ul>
<li><p><a href="http://blog.javachen.com/2014/07/22/flume-ng.html">Flume-ng的原理和使用</a></p>
<blockquote>
<p>Flume NG是Cloudera提供的一个分布式、可靠、可用的系统，它能够将不同数据源的海量日志数据进行高效收集、聚合、移动，最后存储到一个中心化数据存储系统中。</p>
</blockquote>
</li>
<li><p><a href="http://ningg.top/build-flume/">编译flume：使用eclipse查看flume源码</a></p>
</li>
<li><p><a href="http://blog.csdn.net/team77/article/details/44154529">Flume-ng 监控介绍</a></p>
</li>
</ul>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>Maven是一个强大的Java项目构建工具。</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html">Apache Maven 入门篇 ( 上 ) - oracle</a></li>
<li><a href="http://ifeve.com/maven-1/">Maven入门指南（一）</a></li>
<li><a href="http://ningg.top/maven-intro/">maven使用入门</a></li>
<li><a href="http://juvenshun.iteye.com/blog/213959">Maven生命周期详解</a></li>
</ul>
<h3 id="结合-IDE-使用-maven"><a href="#结合-IDE-使用-maven" class="headerlink" title="结合 IDE 使用 maven"></a>结合 IDE 使用 maven</h3><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-maven/">用 Maven 做项目构建 - IBM developerWorks</a></li>
<li><a href="http://blog.csdn.net/xuexin25java/article/details/7970603">【初学maven】eclipse中maven使用 - csdn</a></li>
<li><a href="http://blog.csdn.net/qjyong/article/details/9098213">使用Eclipse构建Maven项目 (step-by-step) - csdn</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于 Java 思路整理</p>
<p>Java 两个重要的框架：Spring、Strut。</p>
<p>Java 的界面：关于 Swing、AWT 和 SWT，参考 <a href="http://zhidao.baidu.com/link?url=XKq0k0562UXzy5tySOyHmeGGruGCrwB2qWcHkCfVhdcmQ7oTifjr6wp3cDyazlTsuqmJ-AoaJ1zWdUtyqrujFK">百度知道的答案</a>。目前，更多的是使用 .net/c# 来做界面。个人感觉单纯做 <strong>Windows</strong> 下的桌面程序（尤其是对<strong>界面</strong>有一定要求时），不建议选择 Java；Java 更多的是企业级应用，跨平台应用，做 web 应用。</p>
<p>另，徐思雨：Spring + ibatis（是一个基于 SQL 映射支持 Java 和 ·NET 的持久层框架），RTC FireFly。</p>
<h1 id="Eclipse-工具"><a href="#Eclipse-工具" class="headerlink" title="Eclipse 工具"></a>Eclipse 工具</h1><p>关于打 jar 包，以及如何使用第三方 jar 包：</p>
<ul>
<li><a href="http://lijun0349-163-com.iteye.com/blog/1026839">Eclipse jar打包详解</a></li>
<li><a href="http://blog.csdn.net/jmyue/article/details/14120387">玩转Eclipse — 添加 JAR 文件 - csdn</a></li>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/3291641.html">Eclipse将引用了第三方jar包的Java项目打包成jar文件的两种方法 - cnblog</a></li>
</ul>
<p>结合其他工具：</p>
<ul>
<li><a href="http://welcome66.iteye.com/blog/1845176">eclipse安装SVN插件的两种方法</a></li>
<li><a href="https://www.zhihu.com/question/20104270">maven 跟 eclipse 是什么关系？ - 知乎</a></li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="http://redis.io/">Redis</a></h1><p>官网还是很有价值的，搜到的中文资源基本上在官网都能找到与之对应的英文描述。</p>
<p>官网推荐的 <a href="http://redis.io/clients">Clients</a>，主流的语言有 Bash C C++ C# Java 等等，还有好多没听过的语言。</p>
<p>把 redis 也放到这里是不合适的。但目前的工作项目是使用 Eclipse 开发的对 redis 进行数据插入、统计的 Java 项目，所以…主要是为工作带来便利。</p>
<h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul>
<li><a href="http://redisdoc.com/">Redis 命令参考</a></li>
<li><a href="http://www.cnblogs.com/xhan/archive/2011/02/02/1948891.html">redis学习笔记之数据类型 - cnblogs</a></li>
<li><a href="http://www.searchdatabase.com.cn/showcontent_52657.htm">浅谈Redis数据库的键值设计</a></li>
</ul>
<h2 id="Java-使用-Redis"><a href="#Java-使用-Redis" class="headerlink" title="Java 使用 Redis"></a>Java 使用 Redis</h2><ul>
<li><a href="https://mavenbrowse.pauldoo.com/central/redis/clients/jedis/2.6.2/jedis-2.6.2-javadoc.jar/-/index.html?overview-summary.html">Jedis 2.6.2 API</a></li>
</ul>
<h2 id="C-C-使用-Redis"><a href="#C-C-使用-Redis" class="headerlink" title="C/C++ 使用 Redis"></a>C/C++ 使用 Redis</h2><p>如果想要掌握一手的资料，还是推荐学习官网上的资源。有些问题在中文教程里找不到解决方案。</p>
<ul>
<li><a href="https://www.zybuluo.com/LIUHUAN/note/364481">hiredis的使用</a></li>
<li><a href="http://blog.csdn.net/kingqizhou/article/details/8104693">redis C接口hiredis 简单函数使用介绍 - csdn</a></li>
<li><a href="http://www.lai18.com/content/6141184.html">Redis学习手册(实例代码)</a></li>
<li><a href="http://www.voidcn.com/blog/Aresiii/article/p-5000495.html">linux下的hiredis的安装和使用</a></li>
<li><a href="http://www.voidcn.com/blog/Aresiii/article/p-5004942.html">linux下的hiredis的安装和使用（二）</a></li>
<li><a href="http://blog.csdn.net/gdutliuyun827/article/details/44339007">Redis客户端连接方式Hiredis简单封装使用,连接池、屏蔽连接细节 - csdn</a></li>
</ul>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/tq-why-choose-redis">为什么使用 Redis及其产品定位</a></li>
<li><a href="http://www.aboutyun.com/blog-1-1924.html">优化Redis内存的9个要点</a></li>
<li><a href="https://segmentfault.com/a/1190000004708270">Redis内存优化</a></li>
<li><a href="https://neway6655.github.io/redis/2016/07/19/redis-memory-optimization-in-practice.html">Redis内存优化实践</a></li>
</ul>
<h2 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a><a href="http://msgpack.org/">MessagePack</a></h2><blockquote>
<p>MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it’s faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves.</p>
</blockquote>
<p>为什么将 MessagePack 放到这个位置？ Messagepack in redis。</p>
<p>关于其协议：</p>
<ul>
<li><a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack specification - github</a></li>
</ul>
<p>其他：</p>
<ul>
<li><a href="http://gaofeihang.cn/archives/177">MessagePack实践总结</a></li>
</ul>
<h3 id="Java-使用案例"><a href="#Java-使用案例" class="headerlink" title="Java 使用案例"></a>Java 使用案例</h3><ul>
<li><a href="https://github.com/msgpack/msgpack-java">msgpack-java</a></li>
<li><a href="https://github.com/msgpack/msgpack-java/blob/develop/msgpack-core/src/test/java/org/msgpack/core/example/MessagePackExample.java">MessagePackExample.java - github</a></li>
</ul>
<p>如何封装对象：</p>
<ul>
<li><a href="https://github.com/msgpack/msgpack-java/blob/develop/msgpack-jackson/README.md">jackson-dataformat-msgpack</a></li>
</ul>
<h3 id="C-C-使用"><a href="#C-C-使用" class="headerlink" title="C/C++ 使用"></a>C/C++ 使用</h3><ul>
<li><a href="https://github.com/msgpack/msgpack-c/issues/254">a possible bug of msgpack-c - github</a></li>
<li><a href="http://stackoverflow.com/questions/13856450/msgpack-messaging-between-c-and-java">msgpack: messaging between C++ and java - stackoverflow</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>asio 网络库</title>
    <url>/2019/01/05/asio/</url>
    <content><![CDATA[<p>asio 封装了平台差异性，在 windows 下本质就是 IOCP。</p>
<h1 id="Overlapped-IO-重叠输入输出"><a href="#Overlapped-IO-重叠输入输出" class="headerlink" title="Overlapped IO 重叠输入输出"></a>Overlapped IO 重叠输入输出</h1><p><a href="https://blog.csdn.net/xiaoding133/article/details/7775139">异步 I/O 技术(Overlapped I/O)，避免使用多线程</a></p>
<ol>
<li><p>激发的文件 handles / 设备内核对象</p>
</li>
<li><p>激发的 event 对象 / 事件内核对象</p>
<blockquote>
<p>IOEvent 用的是 Overlapped IO 模型。使用起来也比较简单，仅需要将 fd buf overlapped(event) 这4者绑在一起，由内核完成数据的收发，并通过 event 通知应用层，应用层再进行数据操作已经完成后的操作，不需要多余的内存拷贝，数据已经在指定的 buf 上了。<a href="https://blog.csdn.net/nightwizard2030/article/details/77602612">C++ SOCKET通信模型（二）IOEvent</a></p>
</blockquote>
</li>
<li><p>异步过程调用 APCs（Asynchronous Procedure Calls）</p>
</li>
<li><p>I/O completion ports（重要）适用于高负载服务器</p>
</li>
</ol>
<a id="more"></a>

<h1 id="IOCP-输入输出完成端口"><a href="#IOCP-输入输出完成端口" class="headerlink" title="IOCP 输入输出完成端口"></a>IOCP 输入输出完成端口</h1><p><a href="https://blog.csdn.net/PiggyXP/article/details/6922277">完成端口(Completion Port)详解</a></p>
<blockquote>
<p>最后，我的建议是，想要使用 基于事件通知的重叠 I/O 和基于完成例程的重叠 I/O 的朋友，如果不是特别必要，就不要去使用了，因为这两种方式不仅使用和理解起来也不算简单，而且还有性能上的明显瓶颈</p>
</blockquote>
<h1 id="ASIO"><a href="#ASIO" class="headerlink" title="ASIO"></a>ASIO</h1><p><a href="https://segmentfault.com/a/1190000007225464">基于 Asio 的 C++ 网络编程</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1056970">Boost asio 官方教程</a></p>
<p><a href="http://think-async.com/Asio/asio-1.12.2/doc/index.html">Documentation (non-Boost)</a></p>
<p>查看 asio 源码，可以学到“错误代码 vs 异常”两种策略；可以学到“同步 vs 异步”两种接口形式。</p>
<p>如果依赖 IO 的结果，（单线程）异步 IO 和同步阻塞 IO 都要等到 IO 完成才能继续执行，那么异步的性能是否更好？如果是，为什么？—— 理解 iocp 之后是否就“豁然开朗”了呢</p>
<blockquote>
<p>有一点也需要注意, 就是从 request 进来到完成, <strong>应用内各个节点和调用流程都要支持异步 io 调用</strong>, 否则一个节点不支持, 就退化成多线程的解决方式。<a href="https://www.cnblogs.com/hucn/p/5725522.html">摘自</a></p>
</blockquote>
<p>ps. 如果某个节点特别耗时，阻塞当前线程，其实也就退化了</p>
<blockquote>
<p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程。<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000">摘自</a></p>
<p>在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p>
</blockquote>
<p>要理解 asio，其实就是 windows 下的 iocp，就是要理解 Proactor</p>
<ul>
<li><a href="https://www.cnblogs.com/qicosmos/p/3836721.html">拨开迷雾见月明-剖析asio中的proactor模式（一）</a></li>
<li><a href="https://www.cnblogs.com/qicosmos/p/3841026.html">拨开迷雾见月明-剖析asio中的proactor模式（二）</a></li>
</ul>
<p>如果要在连续下载文件中使用 asio 异步模型，那么如何将下载后 sqlite3 入库改为嵌入 handler 中？</p>
<h2 id="例子学习笔记"><a href="#例子学习笔记" class="headerlink" title="例子学习笔记"></a>例子学习笔记</h2><p>2019/8/29 16:07:03 因为多数函数都是模板，编码时信息提示本就是短板。结合 <code>co_await</code> 运算符使用时，更是得不到任何提示信息。只能“瞎写”参数数目和类型，编译报错 + 查看源码多次试验究竟怎么写入参。</p>
<p><a href="http://think-async.com/Asio/asio-1.12.2/src/examples/cpp11/futures/daytime_client.cpp">http://think-async.com/Asio/asio-1.12.2/src/examples/cpp11/futures/daytime_client.cpp</a></p>
<p>结合 c++11 <code>std::future</code> 使用 asio 的异步接口，只是在局部提升效率：每个异步接口返回的 <code>future</code>，在其他异步接口中使用时要传入 <code>future::get()</code> 结果，**而非 <code>future</code>**。从全局来看依旧是阻塞的。</p>
<p>当然，有些业务场景恰好如此。一方面想改进每次同步 IO 的阻塞，因为两次 IO 之间可以做些其余工作；另一方面，下一次 IO 调用依赖前一次 IO 的结果。如果为了局部改进，整体改用「异步 + 回调」形式，开发耗时久：“回调地狱”真的很累，难写，看的人也累。</p>
<p>在上述场景中，如果没有 <del>两次 IO 之间可以做些其余工作</del> 的需求，其实再次“退化”改用同步接口即可。</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>Boost ASIO supports 3 co routine types:</p>
<ul>
<li><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/coroutine.html">Stackless Coroutines</a> - Boost ASIO own light weight co routine library using pre-processor macros (been around for a long time now)</li>
<li><a href="https://www.boost.org/doc/libs/1_69_0/doc/html/boost_asio/overview/core/spawn.html">Stackful Coroutines</a> - Uses Boost Coroutine library</li>
<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/boost_asio/overview/core/coroutines_ts.html">Coroutines TS Support</a> (experimental) - Uses CO Routine TS (which is also stackless)</li>
</ul>
<h2 id="无栈协程-☆"><a href="#无栈协程-☆" class="headerlink" title="无栈协程 ☆"></a>无栈协程 ☆</h2><blockquote>
<p>Boost 库中的协程支持两种方式：一种是封装了 Boost.Coroutine 的 <code>spawn</code>，是一个 stackful 类型的协程；一种是 asio 作者写出的 stackless 协程。</p>
</blockquote>
<p>asio 的爸爸通过 <a href="https://bbs.avplayer.org/t/asio/771">Duff’s Device 技术</a> 实现的无栈协程，用到了好多奇技淫巧。结合 <a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/coroutine.html">coroutine 类</a> 的手册和 <a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/http/server4/server.cpp">官方 example</a> 学习过程中有以下问题或心得：</p>
<p><strong>回调签名</strong></p>
<p><code>std::function&lt;&gt;</code> 模板约定的签名是无法适配默认参数的：即 <code>void handler(asio::error_code, size_t len = 0)</code> 是无法赋值给 <code>std::function&lt;void(asio::error_code)&gt;</code> 类型的。</p>
<p>一方面从 c++11 才开始支持 <code>std::function&lt;&gt;</code>，另一方面在 c++03 example 中 <code>async_accept()</code>/<code>async_read_some()</code>/<code>async_write()</code> 竟然全部可以使用回调对象：<code>void operator()( asio::error_code ec = asio::error_code(), std::size_t length = 0)</code> ，要知道 <code>async_accpet()</code> 的回调签名可是 <code>void(asio::error_code)</code></p>
<p>几个关键的伪-关键词，其实都是宏。要知道<strong>宏是不支持断点调试</strong>的，除非手动把所有的宏展开。不过作为成熟的网络库，这些宏都是经过千锤百炼的，调试中根本无需展开。</p>
<p><strong>达夫设备的 fall-through 理解起来太难</strong>了，我能理解简单的使用案例，但前述伪-关键词还是看不懂。查看 <a href="https://zh.cppreference.com/w/cpp/language/attributes/fallthrough">fallthrough </a></p>
<p>成员<strong>全部交给</strong> <code>std::shared_ptr</code> 托管，因为函数对象需要频繁的拷贝：一方面拷贝开销不能太大；另一方面，回调重入时成员必须有效且正确。虽然 <code>fork server(*this)()</code> 浅拷贝，但实际上 <del>所有</del> 智能指针陆续通过 <code>ptr.reset(new xx)</code> 全部新申请了内存，而 <code>socket_</code> 的浅拷贝本就是最佳解决方案。每个主动 socket 封装都携有一份用不到 <code>acceptor_</code> 也只是个瑕不掩瑜的、无法避免的小问题。</p>
<blockquote>
<p>刚刚介绍的协程，不需要任何编译器/底层库的支持。只使用 C 语言本身就许可的 Duff’s Device 技术就能实现。唯一的缺点是局部变量无法跨 yield 。所以所有变量都要定义为函数对象的成员变量。 另外需要把协程定义为函数对象，需要额外编写不少代码。</p>
</blockquote>
<p>更多请参考：<a href="https://blog.csdn.net/guxch/article/details/82804067">Boost中的协程—Boost.Asio中的coroutine类</a></p>
<h2 id="有栈协程-☆☆"><a href="#有栈协程-☆☆" class="headerlink" title="有栈协程 ☆☆"></a>有栈协程 ☆☆</h2><blockquote>
<p>Boost.Context 提供的协程包括两类：非对称型协程 asymmetric_coroutine 的和对称型协程 symmetric_coroutine，前者de协程知道唤醒自己的协程，当需要暂停的时候控制流转换给那个特定的协程；对称协程中所有的协程都是相等的，协程可以把控制流给任何一个其它的协程。</p>
</blockquote>
<p><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp">c++03 examples</a> 和 <a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp">c++11 examples</a> 中 spawn 实例演示涉及的 Boost.Coroutine 库已经 <a href="https://www.boost.org/doc/libs/1_70_0/libs/coroutine/doc/html/coroutine/overview.html">被标记为 Deprecated</a>，推荐使用 Boost.Coroutine2 —— 尴尬的地方在于 <code>asio::spawn()</code> 并未就新的 Boost.Coroutine2 封装新的实现，只能凑合着使用 deprecated 特性。</p>
<ul>
<li>如何使用 Boost.Coroutine2，请参考：<a href="https://blog.csdn.net/guxch/article/details/82803769">Boost中的协程—Boost.Coroutine2</a></li>
<li>如何通过 <code>asio::spawn()</code> 使用 deprecated 的 Boost.Coroutine，请参考：<a href="http://senlinzhan.github.io/2017/10/03/boost-asio-coroutine/">在 Boost.Asio 中使用协程</a></li>
<li></li>
</ul>
<h2 id="Coroutines-TS-Support-☆☆☆"><a href="#Coroutines-TS-Support-☆☆☆" class="headerlink" title="Coroutines TS Support ☆☆☆"></a>Coroutines TS Support ☆☆☆</h2><p>DEMO <a href="https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/examples/cpp17_examples.html">https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/examples/cpp17_examples.html</a></p>
<p>即将进入 c++20 的协程。二百多行代码就能写个聊天室，佩服</p>
<p>查看 <code>co_spawn </code>函数的正式描述，总是理解不了。我个人偏向于认为其用于将协程绑定到指定 <code>asio::io_context</code></p>
<blockquote>
<p>Spawn a new thread of execution. 生成一个新的执行 <del>线程</del> 协程</p>
</blockquote>
<p>在 <a href="https://zh.cppreference.com/w/cpp/language/coroutines">coroutines_ts</a> 中给出了协程的定义等。在 asio 中协程的显著标识是函数返回值：<code>awaitable&lt;void&gt; foo()</code>，</p>
<blockquote>
<p>The return type of a coroutine or asynchronous operation.</p>
</blockquote>
<p>所以 <code>co_spawn()</code> 的第二个入参使用 lambda 时要显式地给定 <code>return xx</code> 语句。</p>
<p><strong>总结</strong>：协程是特异的函数，特征就是返回签名；相应的，协程也不能像普通函数那样直接调用，而是通过 <code>co_spawn()</code> “调用”。</p>
<p>在协程函数体的实现中，当需要 io_context 对象时，既可以（以下理解正确吗？特殊值 <code>this_coro::executor</code> 存在的唯一意义？）</p>
<ul>
<li><p>通过函数参数传进来</p>
</li>
<li><p>也可以通过 <code>asio::executor executor = co_await this_coro::executor</code> 获取。</p>
<p>  无法理解这个“固定用法”里的 <code>co_await</code> 是怎么回事？仍然是“暂停执行，直至恢复”的意义吗？可能需要了解 <code>co_await</code> 实现才行</p>
<p>  空类型 <code>this_coro::executor</code> 是如何移动构造 <code>asio::executor</code> 变量的？</p>
</li>
</ul>
<p>另外两个特殊值，<code>co_spawn()</code> 的第三个参数 <code>asio::detached</code>，和 async_xx() 的末尾参数 <code>asio::use_awaitable</code>，都是固定用法。推测 <code>asio::use_awaitable</code> 是用于模板特例化，并作为当前异步操作的 id。</p>
<blockquote>
<p>上述三个特殊值的类型定义都是空的。类似 <code>std::exception</code> 或 <code>std::error_category</code></p>
</blockquote>
<p>顺序 <code>co_spawn() </code>创建 1-2-3-4 协程，在各协程中 <code>co_await</code> 之前的逻辑也是 1-2-3-4 顺序执行！</p>
<h3 id="协程里外的异常"><a href="#协程里外的异常" class="headerlink" title="协程里外的异常"></a>协程里外的异常</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asio/redirect_error.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">asio::error_code ec;</span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, asio::buffer(msg), asio::redirect_error(use_awaitable, ec) )</span></span>;</span><br><span class="line"><span class="keyword">if</span> (ec)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asio::redirect_err()</code> 的 <a href="https://www.boost.org/doc/libs/1_71_0/libs/outcome/doc/html/recipes/asio-integration-1-70.html">缺点</a> 无伤大雅</p>
<blockquote>
<p>The redirect_error token transformation recovers the option to use the error_code interface, but it suffers from the same drawbacks that <strong>make pure error codes unappealing</strong> in the synchronous case.</p>
</blockquote>
<h3 id="co-await-和线程锁"><a href="#co-await-和线程锁" class="headerlink" title="co_await 和线程锁"></a>co_await 和线程锁</h3><p>协程中禁用线程锁！</p>
<h3 id="不和谐的-疑惑"><a href="#不和谐的-疑惑" class="headerlink" title="不和谐的 / 疑惑"></a>不和谐的 / 疑惑</h3><p><code>asio::async_read()</code> <del>似乎</del> 没有 <code>asio::use_awaitable</code> 版本的重载 (•_•)? 本就是组合函数，很容易实现</p>
<p><code>socket::async_read_some()</code> 无法以 <code>asio::streambuf</code> 作为入参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> size = response_.m_response_buf.size();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> remain = content_length - size;</span><br><span class="line"><span class="comment">//auto len = co_await asio::async_read(*ssocket_, response_.m_response_buf, asio::transfer_at_least(content_length - size),</span></span><br><span class="line"><span class="comment">//    asio::redirect_error(asio::use_awaitable, ec));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> len = <span class="number">0</span>; !ec &amp;&amp; len &lt; remain; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> buf = response_.m_response_buf.prepare(<span class="built_in">std</span>::min(remain, <span class="number">1024ul</span>));</span><br><span class="line">    <span class="keyword">auto</span> bytes = <span class="keyword">co_await</span> ssocket_-&gt;async_read_some(asio::buffer(buf),</span><br><span class="line">        asio::redirect_error(asio::use_awaitable, ec));</span><br><span class="line">    response_.m_response_buf.commit(bytes);</span><br><span class="line">    len += bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 msvc2015 中断点调试无法监视变量 (ÒωÓױ)！</p>
<h3 id="如何编写协程类型"><a href="#如何编写协程类型" class="headerlink" title="如何编写协程类型"></a>如何编写协程类型</h3><p>如果想看懂 asio 如何支持 <code>co_await</code> 的，想更细致地用好协程，就需要了解更基础（同时也是更复杂的）内容。</p>
<ul>
<li><p><a href="https://blog.panicsoftware.com/coroutines-introduction/">COROUTINES INTRODUCTION</a>，需要科学上网，PAC 全局</p>
<p>  文章写得很棒，这个系列作者暂时写了三篇（似乎后续还会继续写），由浅入深，对 C++ 标准中的协程入门只推荐这位作者。</p>
</li>
<li><p><a href="https://lewissbaker.github.io/">C++ Coroutines: Understanding operator co_await</a>，特别推荐的几篇文章</p>
</li>
<li><p><a href="https://owent.net/2019/1904.html">C++20 Coroutine</a></p>
<p>  作者应该也是小白用户，几个关键点都提到了，但展开得不够，轻重也没区分。罗列概念、罗列代码</p>
</li>
<li><p><a href="https://zh4ui.net/tags/coroutine/">TAG : COROUTINE</a></p>
<p>  貌似高屋建瓴，但真的就是“乱拳打死老师傅”。有价值，但对小白入门非常不友好，得自行筛选。</p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其他网络通信库或工具，以及和网络通信相关的加密、压缩等。</p>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>curl 是很活跃的网络通信工具，由 C 语言编写。</p>
<blockquote>
<p>cURL 是一个利用 URL 语法在命令行下工作的文件传输工具，1997 年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称 cURL 为下载工具。cURL 还包含了用于程序开发的 libcurl。</p>
</blockquote>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul>
<li>grpc</li>
<li><a href="https://thrift.apache.org/">Apache Thrift</a></li>
</ul>
<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><p>在 windows 平台使用 openssl 有两种方式：</p>
<ol>
<li><p>下载源码，根据其中的手册通过 nmake 生成动态库 or 静态库。需要 activeperl 和 nasm 环境。</p>
<p> 静态库或导入库名称 libeay32.lib，ssleay32.lib；动态库名称 libeay32.dll，ssleay32.dll。给一篇 <a href="https://blog.devzeng.com/blog/openssl-windows-compile.html">博客</a> 参考。</p>
</li>
<li><p>从网上下载 <a href="https://wiki.openssl.org/index.php/Binaries">第三方编译的结果</a></p>
<p> 其中 grpc 同时也在用的 <a href="https://slproweb.com/products/Win32OpenSSL.html">https://slproweb.com/products/Win32OpenSSL.html</a> 此地址下载内容 VC 目录中文件以 <code>libcrypto32M[TD](d).lib</code> <code>libssl32M[TD](d).lib</code> 命名。</p>
</li>
</ol>
<p><a href="https://github.com/tnie/StockDataLayer/issues/9">OpenSSL 1.1.0+ have changed library names in windows</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>Automake 之 Flat 目录机构</title>
    <url>/2017/04/27/automake2nd/</url>
    <content><![CDATA[<p>2015年12月24日 19:01:26</p>
<p>这个其实是个子篇。整体见 <a href="/2017/04/27/automake1st/">Makefile 自动生成</a></p>
<p>在进入正文之前先通过下图对操作步骤及其中的依赖关系有个大致的概念，理解起来更容易：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake1st/1.png" alt="流程图"></p>
<a id="more"></a>

<h1 id="Flat-目录结构："><a href="#Flat-目录结构：" class="headerlink" title="Flat 目录结构："></a>Flat 目录结构：</h1><ol start="0">
<li><p>创建 hello 目录，在目录下新建一个简单的打印程序 hello.c ；</p>
</li>
<li><p>运行 <code>autoscan</code> 命令，产生 configure.scan 文件（忽略 ./tmp目录）</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/2.png" alt="configure.scan"></p>
<p> 执行后在 hello 目录下会多出两个文件：configure.log 和 configure.scan。对我们有用的是后者，我们可以拿它作为 configure.in 的蓝本。（为了下文中容易对比，将 autoscan.log 文件删除）</p>
</li>
<li><p>将 configure.scan 文件重命名为 configure.in，并修改 configure.in 文件。按下面的内容修改：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line">#AC_INIT([2.63])</span><br><span class="line">AC_INIT([hello], [1.0], [**@126.com])</span><br><span class="line">AC_CONFIG_SRCDIR([hello.c])</span><br><span class="line">#AC_CONFIG_HEADERS([config.h])</span><br><span class="line">AM_INIT_AUTOMAKE(hello, 1.0)</span><br><span class="line"># Check for programs</span><br><span class="line">AC_PROG_CC</span><br><span class="line"># Check for libraries</span><br><span class="line"># Check for header files</span><br><span class="line"># Check for typedefs, structures, and compiler characteristics.</span><br><span class="line"># Check for library functions.</span><br><span class="line">AC_OUTPUT(Makefile)</span><br></pre></td></tr></table></figure></li>
<li><p>运行 <code>aclocal</code> 命令，产生 aclocal.m4 文件</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/3.png" alt="aclocal.m4"></p>
<p> 执行后在 hello 目录下多出两个文件/文件夹：aclocal.m4 和 autom4te.cache。对我们有用的是前者，（为了下文中容易对比，将 autom4te.cache 删除）</p>
</li>
<li><p>运行 <code>autoconf</code> 命令，产生 confingure 文件</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/4.png" alt="confingure"></p>
<p> 执行后在 hello 目录下生成了 configure，（为了下文中容易对比，将 <del>aclocal.m4</del> 、autom4te.cache 和 <del>configure.in</del> 删除）</p>
</li>
<li><p>在 hello 目录下新建 Makefile.am 文件，内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">bin_PROGRAMS&#x3D;hello</span><br><span class="line">hello_SOURCES&#x3D;hello.c</span><br></pre></td></tr></table></figure></li>
<li><p>运行 <code>automake -a</code> 命令（也可 <code>automake --adding-missing</code>）</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/5.png" alt="automake"></p>
<p> 执行后，产生一些文件，其中最重要的是 Makefile.in。此命令除了依赖 Makefile.am 和 configure.in 文件，还依赖 aclocal.m4 文件。（见本节末尾最后一张图）</p>
</li>
<li><p>运行 <code>./confiugre</code> 脚本，产生 Makefile 文件</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/6.png" alt="Makefile"></p>
<p> 我们要的 Makefile 文件终于现身了。</p>
</li>
<li><p>执行 <code>make</code> 命令</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/7.png" alt="hello"></p>
</li>
</ol>
<p>到此正式结束。另外，<code>make</code> 命令依赖以下几个文件（见本节末尾倒数第二张图）</p>
<p>综上，在执行每个步骤时，之前的所有步骤生成的文件基本上都有用，没有文件是可以删除、需要删除的。就这么乱着吧。</p>
<p>整理此节笔记参考：<a href="http://www.laruence.com/2009/11/18/1154.html">automake,autoconf使用详解</a>、（其中关于.in文件语法，命令参数意义等还需整理）</p>
<p>图1</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/8.png" alt="图1"></p>
<p>图2</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/automake2nd/9.png" alt="图2"></p>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 自动生成 - configure &amp; make</title>
    <url>/2017/08/24/automake3rd/</url>
    <content><![CDATA[<h1 id="执行脚本-configure"><a href="#执行脚本-configure" class="headerlink" title="执行脚本 ./configure"></a>执行脚本 ./configure</h1><p>configure：它能根据不同的系统，产生不同的 Makefile，从而使我们的程序具有可移植性。它还有一些参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–cache-file=FILE</td>
<td>测试系统的特性，并将结果放到FILE中</td>
</tr>
<tr>
<td>–help</td>
<td>输出帮助信息</td>
</tr>
<tr>
<td>–no-create</td>
<td>阻止其生成输出文件</td>
</tr>
<tr>
<td>–quiet</td>
<td>执行是不做输出</td>
</tr>
<tr>
<td>–silent</td>
<td>同上，若设置则不会有任何输出到屏幕</td>
</tr>
<tr>
<td>–version</td>
<td>输出automake的版本号</td>
</tr>
</tbody></table>
<a id="more"></a>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–prefix=PEWFIX</td>
<td>安装位置设置（常用）</td>
</tr>
<tr>
<td>–exec-prefix=EPREFIX</td>
<td>设置结构倚赖的文件的安装位置</td>
</tr>
<tr>
<td>–bindir=DIR</td>
<td>指定可执行文件的安装位置.</td>
</tr>
<tr>
<td>–sbindir=DIR</td>
<td>指定超级用户可执行的安装位置.</td>
</tr>
<tr>
<td>–libexecdir=DIR</td>
<td>指定可执行支持文件的安装位置.</td>
</tr>
<tr>
<td>–datadir=DIR</td>
<td>指定通用数据文件的安装位置.</td>
</tr>
<tr>
<td>–sysconfdir=DIR</td>
<td>指定只读数据的安装位置.</td>
</tr>
<tr>
<td>–sharedstatedir=DIR</td>
<td>指定共享的可写数据的安装位置.</td>
</tr>
<tr>
<td>–localstatedir=DIR</td>
<td>指定（非共享）可写数据的安装位置.</td>
</tr>
<tr>
<td>–libdir=DIR</td>
<td>指定库文件的安装位置.</td>
</tr>
<tr>
<td>–includedir=DIR</td>
<td>指定C头文件的安装位置.</td>
</tr>
<tr>
<td>–oldincludedir=DIR</td>
<td>指定为除GCC外编译器安装的C头文件的安装位置.</td>
</tr>
<tr>
<td>–infodir=DIR</td>
<td>指定Info格式文档的安装位置.</td>
</tr>
<tr>
<td>–mandir=DIR</td>
<td>指定手册页的安装位置.</td>
</tr>
<tr>
<td>–srcdir=DIR</td>
<td>源码的位置</td>
</tr>
<tr>
<td>–program-prefix=PREFIX</td>
<td>增加安装程序名字前缀.</td>
</tr>
<tr>
<td>–program-suffix=SUFFIX</td>
<td>增加安装程序名字后缀.</td>
</tr>
<tr>
<td>–program-transform-name=PROGRAM</td>
<td>产生安装名</td>
</tr>
<tr>
<td>–build=BUILD</td>
<td>指定软件包安装的系统平台.</td>
</tr>
<tr>
<td>–host=HOST</td>
<td>指定软件运行的系统平台.</td>
</tr>
<tr>
<td>–target=GARGET</td>
<td>指定软件面向的系统平台</td>
</tr>
<tr>
<td>–disable-FEATURE</td>
<td>提供为大型选项的编译时配置</td>
</tr>
<tr>
<td>–enable-FEATURE[=ARG]</td>
<td>提供了一些默认被禁止的特性</td>
</tr>
<tr>
<td>–enable-FEATURE=no</td>
<td>同–disable-FEATURE</td>
</tr>
<tr>
<td>–with-PACKAGE[=ARG]</td>
<td>使用已有软件包和库</td>
</tr>
<tr>
<td>–with-PACKAGE=no</td>
<td>–without-PACKAGE同义</td>
</tr>
<tr>
<td>–without-PACKAGE</td>
<td>禁止软件包与系统已有的软件包交互</td>
</tr>
<tr>
<td>–x-includes=DIR</td>
<td>–with-PACKAGE的一个特例</td>
</tr>
<tr>
<td>–x-libraries=DIR</td>
<td>向configure脚本指明包含X11库的目录</td>
</tr>
</tbody></table>
<p>在运行 configure 时收集了系统的信息，用户可以在 configure 命令中对其进行方便地配置。</p>
<p>在 ./configure 的自定义参数有两种，一种是开关式（–enable-XXX 或 –disable-XXX），另一种是开放式，即后面要填入一串字符（–with-XXX=yyyy）参数。</p>
<h1 id="如何使用产生的-Makefile-文件"><a href="#如何使用产生的-Makefile-文件" class="headerlink" title="如何使用产生的 Makefile 文件"></a>如何使用产生的 Makefile 文件</h1><p>执行 configure 脚本文件所产生的 Makefile 文件有几个预定的选项可供使用： </p>
<ul>
<li>make all：产生设定的目标，即生成所有的可执行文件。使用 make 也可以达到此目的。 </li>
<li>make clean：删除之前编译时生成的可执行文件及目标文件（形如 *.o 的中间文件）。 </li>
<li>make distclean：除了删除可执行文件和目标文件以外，把 configure 所产生的 Makefile 文件也清除掉。通常在发布软件前执行该命令。 </li>
<li>make install：将使用 make all 或 make 命令产生的可执行文件以软件的形式安装到系统中。若使用 bin_PROGRAMS 宏，程序将会被安装到 /usr/local/bin 下，否则安装到预定义的目录下。 </li>
<li>make dist：将程序和相关的文档包装为一个压缩文档以供发布。执行完该命令，在当前目录下会产生一个名为 PACKAGE-VERSION.tar.gz 的文件。PACKAGE 和 VERSION 这两个参数是来自 <del>configure.in</del> configure.ac 文件中的 AM_INIT_AUTOMAKE(PACKAGE,VERSION)。如在上个例子中执行 make dist 命令，会产生名为 “hello-1.0.tar.gz” 的文件。 </li>
<li>make distcheck：与 make dist 类似，但是加入了检查包装以后的压缩文件是否正常。</li>
</ul>
<p>按照以上步骤操作完毕，例子在执行 dist 相关命令时报错：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/5.png" alt="报错信息"><br>【rx 例子正确执行】</p>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 自动生成 - 渣滓</title>
    <url>/2017/08/24/automake4th/</url>
    <content><![CDATA[<h1 id="Configure-ac-文件解析"><a href="#Configure-ac-文件解析" class="headerlink" title="Configure.ac 文件解析"></a>Configure.ac 文件解析</h1><p>原理：Autoconf 是用来产生 “configure” 文档的工具。“configure” 是一个 shell script，它可以自动设定原始程序以符合各种不同平台上 Unix 系统的特性，并且根据系统参数及环境产生合适的 Makefile 文档或是 C 的标头档 (header file)，让原始程序可以很方便地在这些不同的平台上被编译出来。Autoconf 会读取 <del>configure.in</del> configure.ac 档然后产生 “configure” 这个 shell script。</p>
<p><del>configure.in</del> configure.ac 文档的内容是一连串 GNU m4 的巨集，这些巨集经过 autoconf 处理后会变成检查系统特征的 shell script。<del>configure.in</del> configure.ac 内巨集的顺序并没有特别的规定，但是每一个 <del>configure.in</del> configure.ac 档必须在所有巨集前加入 AC_INIT 巨集，然後在所有巨集的最后面加上 AC_OUTPUT 巨集。</p>
<p>一般先用 autoscan 这个工具扫描原始文件以产生一个 configure.scan 文件，再对 configure.scan 作些修改，从而生成 <del>configure.in</del> configure.ac 文件。</p>
<a id="more"></a>

<p>先来看一下 confiugre.scan 文件：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/2.png" alt="configure.scan 文件"></p>
<p>部分宏的意义如下：</p>
<ul>
<li>AC_PREREQ 宏：声明本文件要求的 autoconf 版本，这里使用的是 2.63</li>
<li>AC_INIT 宏：用来定义软件的名称和版本等信息，BUG-REPORT-ADDRESS，一般为作者的 E-mail。</li>
<li>AC_CONFIG_SRCDIR 宏：用来检测指定的源文件是否存在，来确定源码目录的有效性，在此处为当前目录下的 hello.c。如果有多个源文件，按其默认或只写文件中的任意一个就好了，只是测试。也可以全写上，但文件很多时，完全没有必要。</li>
<li>AC_CONFIG_HEADERS 宏：用于生成 config.h 文件，以便 autoheader 使用。【怀疑这个解释的准确性？实际中并未生成。实际效果此条宏影响的是 automake 指令，AC_CONFIG_SRCDIR 用于检测源代码目录下的 config.h 文件。AC_CONFIG_HEADER 表示你想要使用一个配置头文件。】</li>
<li>AC_CONFIG_FILES 宏：<strong>用于生成相应的 Makefile 文件</strong>。【和 AC_OUTPUT(Makefile) 效果相同？】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line">AC_OUTPUT(Makefile head&#x2F;Makefile)</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line">AC_CONFIG_FILES(Makefile head&#x2F;Makefile)</span><br><span class="line">AC_OUTPUT</span><br><span class="line"></span><br><span class="line">#上述两种书写方式效果一致？后者更规范，理由如下</span><br></pre></td></tr></table></figure>
<p>经过实际测试验证，当前目录或其子目录存在 Makefile.am 或/和 Makefile.in 文件时，autoscan 命令生成 configure.scan 包含 AC_CONFIG_FILES(Makefile1 Makefile2 …)；否则，无此宏。<br>如图，autoscan 自动生成 .scan 文件内容：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/3.png" alt="configure.scan 文件"></p>
<p>所以，<strong>更有效/规范的操作顺序是，创建 Makefile.am 文件应该早于执行 autoscan 命令！</strong></p>
<p>——这个地方真的花费了一些时间才整明白，因为网上看到的所有资料要么说 AC_CONFIG_FILES 宏是手动添加的，要么就是按照这篇笔记之前描述的操作顺序，可是配的图片却包含此宏（可实际是不可能的，如果在新添 Makefile.am 文件之前执行 autoscan 命令，生成的 configure.scan 不可能有这条宏）。简单来说，跟着网上的帖子学可以达到生成 makefile，执行 make 的目的，但是真心太粗糙了。</p>
<p>每个 configure.scan 文件都是以 AC_INIT 开头，以 AC_OUTPUT 结束。从文件中的注释可以看出 confiugre.in 文件的一般布局：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AC_INIT</span><br><span class="line">测试程序</span><br><span class="line">测试函数库</span><br><span class="line">测试头文件</span><br><span class="line">测试类型定义</span><br><span class="line">测试结构</span><br><span class="line">测试编译器特性</span><br><span class="line">测试库函数</span><br><span class="line">测试系统调用</span><br><span class="line">AC_OUTPUT</span><br></pre></td></tr></table></figure>
<p>上面的调用次序只是建议性质的，但还是强烈建议不要随意改变对宏调用的次序。</p>
<p><del>configure.in</del> configure.ac 文件中一些宏的含义如下：</p>
<table>
<thead>
<tr>
<th>#或dnl</th>
<th>#或dnl后面的内容作为注释不会被处理，它们是注释的起始标志</th>
</tr>
</thead>
<tbody><tr>
<td>AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])</td>
<td></td>
</tr>
<tr>
<td>AM_INIT_AUTOMAKE(PACKAGE,VERSION)</td>
<td>这个是后面运行 automake 命令所<strong>必需的宏</strong>，PACKAGE 指明要产生软件的名称，VERSION 是其版本号</td>
</tr>
<tr>
<td>AC_PROG_CC</td>
<td>检查系统可用的 C 编译器，若源代码是用 C 语言编写的就需要这个宏</td>
</tr>
<tr>
<td>AC_OUTPUT(FILE)</td>
<td>设置 configure 命令所要产生的文件。我们最终期望产生 Makefile 这个文件，因此一般将其设置为 AC_OUTPUT(Makefile)</td>
</tr>
</tbody></table>
<p>AM_INIT_AUTOMAK E宏：需要自己增加，它是 automake 所必备的宏，其参数与 AC_INIT 宏的参数一样，分别是软件名称和版本编号。</p>
<p>【是需要描述一下 aclocal 命令，但感觉应该是由 autoconf 引出，不该是 automake 啊】</p>
<p><del>在运行 automak e命令时，还需要一些其他的宏，这些额外的宏由 aclocal 产生。执行 aclocal 会产生 aclocal.m4 文件，如果没有特别的要求，无需修改它。用 aclocal 产生的宏将会提示 automake 如何动作。</del></p>
<p><del>另一个重要的文件是 Makefile.am。automake 根据 configure.in 中的宏并在 perl 的帮助下把 Makefile.am 转成 Makefile.in 文件。Makefile.am 文件定义所要产生的目标。</del></p>
<h1 id="实战-Makefile-am"><a href="#实战-Makefile-am" class="headerlink" title="实战 Makefile.am"></a>实战 Makefile.am</h1><p>Makefile.am 是一种比 Makefile 更高层次的规则。只需指定要生成什么目标，它由什么源文件生成，要安装到什么目录等构成。</p>
<p>一般情况是在最上层目录下写一个 Makefile.am，然后在每一个子目录下分别写一个 Makefile.am 文件。automake 会从最上层开始递归处理各个 Makefile.am，每个 Makefile.am 相应生成一个 Makefile.in。</p>
<p>bin_PROGRAMS 定义要产生的可执行文件名，如果要产生多个执行文件，每个文件名用空格隔开。</p>
<p>main_SOURCES 定义“main”这个执行程序所需要的原始文件，如果“ main”这个程序是由多个原始文件所产生的，则必须把它所用到的所有原始文件都列出来，并用空格隔开。要注意的是，如果要定义多个执行文件，则对每个执行程序都要定义相应的 file_SOURCES。</p>
<p>下表列出了可执行文件、静态库、头文件和数据文件，四种书写Makefile.am文件个一般格式。</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/table1.gif" alt="Makefile.am 一般格式"></p>
<p>对于可执行文件和静态库类型，如果只想编译，不想安装到系统中，可以用 noinst_PROGRAMS 代替 bin_PROGRAMS，noinst_LIBRARIES 代替 lib_LIBRARIES。</p>
<p>Makefile.am 还提供了一些全局变量供所有的<strong>目标体</strong>使用：（目标体是啥？没说明白啊）</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/table2.gif" alt="Makefile.am 中可用的全局变量"></p>
<p>整理此节笔记参考：<a href="http://www.ibm.com/developerworks/cn/linux/l-makefile/">例解 autoconf 和 automake 生成 Makefile 文件</a></p>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>Bandwagon 搭建备忘</title>
    <url>/2017/03/10/bandwagon/</url>
    <content><![CDATA[<p>2016/4/11 9:33:05 昨天晚上重装了系统，将CentOS 6 换成了Debian 8。以下记录在Debian 上的配置修改、安装用具等操作。</p>
<p>2016/8/1 14:32:28 大概在两个月前，我又重新将 Debian 8 的系统还原回了 Bandwagon 官方推荐的 CentOS 6，因为翻墙是刚需，当时不单单需要 ShadowSocks，还需要 OpenVPN（使用 Google 的 Music Play 上传音乐用，生活在墙内，/(ㄒoㄒ)/~~）。另外，服务器毕竟是入门级配置，实际操作不太流畅。更换 CentOS 6 之后只配了 SS 服务器，再也没折腾过。</p>
<h1 id="为什么换-Debian？"><a href="#为什么换-Debian？" class="headerlink" title="为什么换 Debian？"></a>为什么换 Debian？</h1><p>虽然在网上参考了很多，尤其是 <a href="https://www.zhihu.com/question/19599986/answer/25433641">服务器操作系统应该选择 Debian/Ubuntu 还是 CentOS？ - <em>袁昊洋</em></a> 的回答，作为服务器第一优选 RHEL/CentOS。我为什么还非得要更换成 Debian 系统呢？其实只是喜欢，也因为是个人的机器，目前除了<strong>科学上网</strong>就是<strong>熟悉系统、练习开发</strong>，折腾坏了宕机都是没有影响的，写这篇备忘录也是为了重装系统时更轻松快捷。</p>
<a id="more"></a>

<h1 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h1><p>使用 CentOS 系统，Bandwagon 提供了一键安装 Shadowsocks 的便捷操作；使用 Debian 就需要自行解决了，参考 <a href="https://teddysun.com/358.html">Debian下shadowsocks-libev一键安装脚本</a>，操作也很傻瓜，我使用的也是这个。如果有进一步的需求，参考 <a href="https://blog.linuxeye.com/423.html">Shadowsocks一键安装脚本（CentOS6,7、Ubuntu、Debian）</a>。</p>
<p>当然，这两个都是需要翻墙才能看到的，推荐 <a href="http://www.shadowsocks.asia/mianfei/10.html">免费shadowsocks账号分享</a>。因为现在手机、PC 对翻墙的需求基本是全天候 24 小时的，所以决定付费租 VPS，自己搭建 SS 服务端。</p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>首先强调，国外的机器是不用修改源的，使用默认的（即官方的）即可。国内不行是因为防火长城的存在。</p>
<p>参考以前写的《linux 的 distribution》中 Debian一节搭建开发环境时，发现已经存在了，可能是系统自带，更可能的是 SS 一键安装脚本时安装的。</p>
<h1 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h1><p>以 root 权限，根据 <a href="https://git-scm.com/download/linux">官方的</a> 说明使用 <code>apt-get install git</code> 直接安装，几秒钟的时间。未使用 <a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">源码编译安装</a>，虽然可以安装最新 <a href="https://www.kernel.org/pub/software/scm/git/">版本</a>。</p>
<p>安装的 git 版本为 2.1.4</p>
<h1 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h1><p><strong>忌</strong>安装 <a href="https://github.com/spf13/spf13-vim">spf13-GitHub</a>，个中转变见《Vim 操作及其配置.md》。</p>
<h1 id="Shell-配置"><a href="#Shell-配置" class="headerlink" title="Shell 配置"></a>Shell 配置</h1><p><strong>忌</strong>安装 <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>，因为这个是 Zsh，不是 bash。</p>
<h1 id="安装-Boost-吗？"><a href="#安装-Boost-吗？" class="headerlink" title="安装 Boost 吗？"></a>安装 Boost 吗？</h1><p>目前只是练习《C++ Primer》中的知识，暂且用不到；且 Boost 库也是挺大的。</p>
<h1 id="中文环境"><a href="#中文环境" class="headerlink" title="中文环境"></a>中文环境</h1><p>通过 <a href="http://bxbx258.blog.51cto.com/339450/744992">Debian中文环境配置及几种中文编码的探究</a> 对中文环境有一个模糊的认识，具体的配置参考 <a href="http://wenku.baidu.com/view/dbe45bd476a20029bd642d6e.html">Debian Linux最小化安装下添加中文支持</a> 和 <a href="http://www.cnblogs.com/pengdonglin137/p/3280663.html">debian添加中文支持</a> 两篇帖子。</p>
<p>因为我只在 xShell 中远程连接操作，所以并不需要安装美化层面的字体，不需要安装输入法等。也就是说只要参考帖子中关于 locales 的配置，以及安装基本字体，保证中文正常显示就可以了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM 字节顺序标记</title>
    <url>/2019/11/04/bom/</url>
    <content><![CDATA[<p>BOM，就是 utf8-bom 中的 bom。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">字节顺序标记</a>（英语：byte-order mark，BOM）是位于码点 <code>U+FEFF</code> 的统一码字符的名称。统一码中，值为 <code>U+FFFE</code> 的码位被保证将不会被指定成一个统一码字符。Unicode 的编码点是唯一的，但表达方式（存储方式）多样。表达方式涉及 utf8,utf16 等；存储方式除了前者还涉及 <a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节顺序</a>。在 UTF-16 中：</p>
<ul>
<li>大尾序存储形式：数值的低有效位存储在存储地址高的位置。即 <code>0xFE,0xFF</code></li>
<li>小尾序存储形式：数值的低有效位存储在存储地址低的位置。即 <code>0xFF,0xFE</code></li>
</ul>
<p>UTF-8 是否应该携有 BOM 是历史问题，不做讨论。当其携有 BOM 时，按照其 <a href="https://zh.wikipedia.org/wiki/UTF-8#UTF-8%E7%9A%84%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F">编码方式</a>，码点 <code>U+FEFF(1111,1110,1111,1111)</code> 会被存储为三个字节 <code>1110(1111),10(111011),10(111111)</code>，即 <code>0xef,0xbb,0xbf</code>。虽然携有 BOM，但</p>
<blockquote>
<p>它只用来标示一个 UTF-8 的文件，而不用来说明字节顺序</p>
</blockquote>
<a id="more"></a>

<p>另外，在 c++11 起，新增了两个 <a href="https://zh.cppreference.com/w/cpp/language/escape">转义字符</a>：</p>
<ul>
<li><code>\unnnn</code>，    通用字符名（任意 Unicode 值）可能生成多个字符，表示编码点 <code>U+nnnn</code></li>
<li><code>\Unnnnnnnn</code>，通用字符名（任意 Unicode 值）可能生成多个字符，表示编码点 <code>U+nnnnnnnn</code></li>
</ul>
<p>因为 <a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">BMP 基本多文种平面</a> 基本包含了我们目前接触到的所有字符，所以 <code>\U</code> 大写的转移字符一般是用不到的。</p>
<p>由此，如果我们想通过 C++ 的输出流创建 utf8-bom 文件并写入 <code>niel水</code> 有多样的代码可选：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UTF-8 data with BOM</span></span><br><span class="line"><span class="built_in">std</span>::ofstream(<span class="string">&quot;text.txt&quot;</span>) &lt;&lt; <span class="string">u8&quot;\ufeff&quot;</span> &lt;&lt; <span class="string">u8&quot;niel\u6c34&quot;</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">std</span>::ofstream(<span class="string">&quot;text.txt&quot;</span>) &lt;&lt; <span class="string">&quot;\xef\xbb\xbf&quot;</span> &lt;&lt; <span class="string">u8&quot;niel水&quot;</span>;</span><br><span class="line"><span class="comment">// 两者并无本质区别：我们优先做了转码工作或者交给预处理器去做</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>构建 build</title>
    <url>/2016/08/13/build/</url>
    <content><![CDATA[<p>整理为知笔记中和 make makefile automake 有关内容，成此篇。</p>
<h1 id="从-gcc-说起"><a href="#从-gcc-说起" class="headerlink" title="从 gcc 说起"></a>从 <a href="https://gcc.gnu.org/">gcc</a> 说起</h1><p>在介绍 make 之前，首先要保证你会使用 gcc/g++ 编译。了解 gcc 执行的四个阶段，知道预编译阶段、链接阶段需要什么，做什么操作；知道预编译时找不到头文件，链接时缺少库文件怎么处理；知道动态库、静态库的区别，怎么创建并使用它们。以上是必需的！只有掌握了上面的内容，才能保证面对一个简单的项目（可能包含头文件、源文件和链接库）知道怎么组织，最终得到可执行文件。</p>
<p>维基百科的描述：</p>
<blockquote>
<p>GNU编译器套装（英语：GNU Compiler Collection，缩写为 <a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>），一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p>
</blockquote>
<h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>预处理、编译、汇编和链接。学习 gcc，比较重要的是预处理和链接：</p>
<p>参考 <a href="http://www.cnblogs.com/youxin/p/3181214.html">gcc编译4个阶段</a></p>
<ol>
<li><p>预处理阶段</p>
<blockquote>
<p>预处理器（cpp）根据以字符#开头的命令（directives），修改原始的C程序。</p>
</blockquote>
<p> 也就是说预处理阶段，会查找并加载头文件生成一个新的C程序。</p>
</li>
<li><p>编译阶段</p>
<p> 编译阶段会将代码翻译成汇编语言。</p>
<blockquote>
<p>汇编语言是非常有用的，它为不同高级语言不同编译器提供了 通用的语言。如：C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
</blockquote>
</li>
<li><p>汇编阶段</p>
<p> 汇编阶段将汇编语言程序转换成为目标文件，也就是二进制机器码。</p>
</li>
<li><p>链接阶段</p>
<p> 该阶段将用到的一个或多个目标文件（库文件）链接生成可执行文件。</p>
<blockquote>
<p>在预编译阶段包含进来的“stdio.h”中只有“printf”函数的声明，而没有函数的实现，那么，是在哪里实现的“printf”函数呢？答案是：系统把这些函数实现都做到名为libc.so.6的库文件中去了，链接阶段gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf” 了，而这也就是链接的作用。</p>
</blockquote>
<p> 从上面可以看出，链接时需要目标文件的名称及其所在目录。</p>
</li>
</ol>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>知道了预处理器（cpp）要读取头文件，那么报错“xxx.h:No such file or directory”就需要确认我们是不是指定了查找目录，或者核对我们指定的路径是否包含该头文件；同样的道理，链接器（ld）需要链接目标文件，和前者稍有不用的地方在于：头文件一般都写在源代码中，我们只需要指定头文件路径；而链接目标文件时，既需要我们指出目标文件所在的目录，同时还需要我们指定使用目标路径下的哪个文件。</p>
<p>以上算是原理。知其所以然之后，我们来看工具具体的使用方法：</p>
<ol>
<li>头文件相关的： -I 后跟绝对路径或相对路径，例如 <code>-I ./include</code>。预处理器会优先在 @搜索路径</li>
<li>链接过程： -L 后跟绝对路径或相对路径，例如 <code> -L ./lib</code>， -l 后跟库名，例如 <code>-lmath</code>，对应库文件 libmath.a 或 libmath.so</li>
<li>-c：使用源文件生成对应的目标文件，而不进行链接，使用  ，例如 <code>g++ -c main.cpp -o main.o</code></li>
<li>-Wall：使 gcc 产生尽可能多的警告信息，并非全部。</li>
<li>-Werror：把警告当做错误处理，即产生 warning 时就停止编译操作。</li>
</ol>
<p>特殊的参数：</p>
<ol>
<li><p>-nostdinc：使编译器不在系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置。</p>
</li>
<li><p>-Wl,-rpath：在<strong>编译过程</strong>指定程序在<strong>运行时</strong>动态库的搜索路径，示例：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔</span><br><span class="line">gcc -Wl,-rpath,libPath -L libPath -ltest hello.c</span><br></pre></td></tr></table></figure>
<p> 将搜索路径信息写入可执行文件(rpath代表runtime path)。这样就不需要设置环境变量。坏处是，如果库文件移动位置，我们需要重新编译test。</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>更多的参数，更详细的使用说明可以查看 <a href="https://gcc.gnu.org/onlinedocs/6.1.0/">官方手册</a>，或者使用 man info –help 等方式获取。</p>
<h3 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h3><p>测试环境：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/code/test_search$ uname -a</span><br><span class="line">Linux debian8light 3.16.0-4-amd64 <span class="comment">#1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29) x86_64 GNU/Linux</span></span><br><span class="line">vimer@debian8light:~/code/test_search$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Debian</span><br><span class="line">Description:	Debian GNU/Linux 8.3 (jessie)</span><br><span class="line">Release:	8.3</span><br><span class="line">Codename:	jessie</span><br><span class="line">vimer@debian8light:~/code/test_search$ </span><br></pre></td></tr></table></figure>
<p>在 gcc version 4.9.2 (Debian 4.9.2-10) 环境下实际测试，linux 编译时头文件的搜索路径：</p>
<ol>
<li>搜索会从 -I 开始</li>
<li>再找 /usr/lib/gcc/x86_64-linux-gnu/4.9/include</li>
<li>再找 /usr/local/include/</li>
<li>查找 /usr/include/</li>
</ol>
<p>此测试只是确定以上 4 者相对的先后。测试时未包含更多的潜在的搜索路径，比如 gcc 的环境变量 C_INCLUDE_PATH、CPLUS_INCLUDE_PATH、OBJC_INCLUDE_PATH</p>
<p>两种不类型的头文件 <code>#include&lt;&gt;</code> 和 <code>#include&quot;&quot;</code> 搜索规则：</p>
<ol>
<li>使用&lt;&gt;包含的头文件一般会先搜索-I选项后的路径（即用gcc编译时的-I选项，注意是大写），之后就是标准的系统头文件路径。</li>
<li>而用””号包含的头文件会首先搜索当前的工作目录，之后的搜索路径才是和&lt;&gt;号包含的头文件所搜索的路径一样的路径。</li>
</ol>
<p><strong>事实上，知道上述提及的搜索路径即可。不必学究式地死记硬背之间的搜索顺序，能有多少意义呢？。</strong></p>
<p>更直接、简单的方式，确认查找头文件时的路径搜索顺序。参考 <a href="http://blog.csdn.net/maximuszhou/article/details/38559963">使用gcc时头文件路径和动态链接库路径</a>， 通过使用 -v 参数看到：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;...&quot; search starts here:</span></span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> ./include</span><br><span class="line"> /usr/include/c++/4.9</span><br><span class="line"> /usr/include/x86_64-linux-gnu/c++/4.9</span><br><span class="line"> /usr/include/c++/4.9/backward</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include</span><br><span class="line"> /usr/<span class="built_in">local</span>/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>在此不再具体测试编译过程中链接库文件时的搜索顺序、运行时动态库的搜索顺序，真正需要用之间的搜索顺序时再写代码测试。</p>
<h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><p>在“链接阶段”一节中出现了库文件“libc.so.6”。@Linxu 中动态库</p>
<p>@引出静态库</p>
<p>@动态链接和静态链接</p>
<h1 id="make-和-Makefile"><a href="#make-和-Makefile" class="headerlink" title="make 和 Makefile"></a><a href="https://www.gnu.org/software/make/">make</a> 和 Makefile</h1><p>make 命令用来解释、执行 Makefile文件。针对开发 C++ 程序来说：Makefile 文件是对项目文件（以源文件、链接库为主，也包括头文件）依赖关系的描述，是对 gcc 命令的有效组织。抛开依赖关系，如果项目不复杂，你也可以用 shell 脚本来组织 gcc 命令，前提是根据依赖关系调整好编译命令的排序。虽然能够得到同样的结果，但是执行的效率不如前者，容错的能力不如前者，耗费的精力更是项目越大越难以承受。事实上：</p>
<blockquote>
<p>在make诞生之前，编译工作主要依赖于操作系统里面的类似于“make”、“install”功能的shell脚本。</p>
</blockquote>
<p>来看看维基百科中的描述：</p>
<blockquote>
<p>在软件开发中，<a href="https://zh.wikipedia.org/wiki/Make">make</a> 是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。</p>
<p>它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。</p>
<p>它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。</p>
</blockquote>
<p>需要注意的是我们在 Linux 上用的一般是 make 的重写/改写版本 <a href="https://www.gnu.org/software/make/">GNU Make</a>，除此之外还有 BSD Make 等。</p>
<p>我们来看怎么写 Makefile 文件。</p>
<h1 id="automake"><a href="#automake" class="headerlink" title="automake"></a><a href="https://www.gnu.org/software/automake/">automake</a></h1><p>人工写 Makefile 文件已经满足不了我们了。事实是人越来越懒，项目也越来越大，我们希望电脑帮我们做更多的工作。引用 Wikipedia 中的描述：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Automake">GNU Automake</a> 是一种编程工具，可以产生供 make 程式使用的 Makefile，用来编译程式。它是自由软件基金会发起的 GNU 计划的其中一项，作为 GNU 构建系统的一部分。automake 所产生的Makefile 符合 GNU 编程标准。</p>
<p>automake 是由 Perl 语言所写的，必须和 GNU autoconf 一并使用。</p>
</blockquote>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>以下概念当做扩展知识保留下来，如果有兴趣可以展开学习：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Portable_Executable">PE 文件</a> 和 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F">ELF 文件</a></li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>c++20 特性</title>
    <url>/2020/12/25/c++20/</url>
    <content><![CDATA[<p>学习 c++20 首先要有支持相关特性的编译器</p>
<p>msvc2019 如果和工作用的 msvc2015 安装在同一台机器上，在使用 vcpkg 时会产生冲突</p>
<p>clang 在 windows 下的使用并不平滑，如果初衷是 c++20，就不要舍本逐末。在熟悉 c++20 后回头折腾 clang</p>
<p>虚拟机上安装 msvc2019，Hyper-V 是好的选择吗？如果要用 VMware 还是躲开 Hyper-V</p>
<a id="more"></a>

<p>安装 msvc2019 对 win10 版本有要求，直接使用两者的在线安装包是省心省力（耐心等下载）的选择。</p>
<p>c++20 的模块 module 如何处理预编译选项的，比如如何处理标准库 <string> 中 Debug/Release 的不同定义</p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/modules-cpp?view=msvc-160">Overview of modules in C++</a></p>
<blockquote>
<p>Visual Studio 中的模块接口文件需要 ixx 扩展名</p>
</blockquote>
<p>编译器在处理头文件和模块的关系时，引入了 global module fragment （全局模块片段）的概念</p>
<p>单独使用 module 关键字：用于文件开头，标识内容归属<br>使用 export module 关键字：用于模块接口文件 .ixx<br>单独使用 export 关键字：导出什么<br>import 关键词：先包含头文件，再导入模块</p>
<blockquote>
<p>The import declaration must appear after the module declaration and after any #include directives, but before any declarations in the file.</p>
</blockquote>
<p>模块声明和头文件？</p>
<p>c++20 的三大块：concepts, modules, coroutines</p>
<p><a href="https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine/">C++20 - 下一个大版本功能确定</a></p>
<p>兜兜转转大半年，还是再次碰上协程，啊哈</p>
<p>我接触协程起始于 asio 库，当时不得其法，异步 io 叠加其中的三类协程，弯弯绕绕很混乱。这次单纯地从 <a href="https://en.cppreference.com/w/cpp/language/coroutines">c++20 的协程</a> 入手，慢慢理解。以下的“协程”，狭义的特指 C++20 标准引入的无栈协程，而非更宽泛意义上的概念。</p>
<p>概念上，协程就是能够重入的函数。具体实现上，多种多样，复杂程度和理解难度也不一。</p>
<blockquote>
<p>Coroutines are <strong>stackless</strong>: they suspend execution by returning to the caller and the data that is required to resume execution is stored <strong>separately from the stack</strong>.</p>
</blockquote>
<ol>
<li>协程暂停执行，控制权返回给调用者</li>
<li>为了恢复执行保存的状态和数据，不在栈上。</li>
</ol>
<p>c++20 中什么样子的函数才是协程呢？</p>
<ol>
<li>函数定义使用了 co_await co_yield co_return</li>
<li>函数返回值满足以下要求：??????? 定义了某些特定方法的类型。</li>
</ol>
<blockquote>
<p>协程的返回值并不是普通的值而是一个可以和另外一个协程相互协作的对象</p>
</blockquote>
<p>每个协程关联了 promise object , coroutine handle, coroutine state. 这里的 promise object 和 <code>std::promise</code> 无关</p>
<ul>
<li>the promise object, manipulated from inside the coroutine.</li>
<li>the coroutine handle, manipulated from outside the coroutine.</li>
<li>the coroutine state, which is an internal, <strong>heap-allocated object</strong> that contains the promise object, …</li>
</ul>
<blockquote>
<p>The Promise type is determined by the compiler from <strong>the return type of the coroutine</strong> using std::coroutine_traits.</p>
</blockquote>
<p>作为一名普通的程序员，我大概率是只是用别人写好的协程库，不会自己写的。</p>
<blockquote>
<p>封装异步接口：用户的便利建立在库开发者的辛苦之上</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>为什么不能销户呢？</title>
    <url>/2017/04/17/cancelaccount/</url>
    <content><![CDATA[<p>2015年12月31日 15:40:20</p>
<p>不知道和自己是学计算机的有没有关系，总之我如果手机号不用了我要销号，银行卡不用了我要销卡。同样的，好多网络上的账户（最主要的就是邮箱和社交平台）我也希望能够有借有还，注册注销闭环操作。可惜就我目前了解到的，网易不同，百度各种账号/平台不提供……</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/cancelaccount/1b1f9566-5e1d-4eb8-a798-2eb0925ae2d4.png" alt="注销账户"></p>
<a id="more"></a>

<p>以后新注册什么东东的时候，先想</p>
<ol>
<li>必需注册吗？注册了用来干什么？不注册有什么影响？</li>
<li>注册之后的使用频率高吗？</li>
<li>注册信息敏感吗？涉及个人身份信息吗？</li>
<li>注册账号有成长价值吗？</li>
<li>尽量不注册新账户；尽量使用废弃邮箱操作。</li>
</ol>
<p><a href="http://www.douban.com/note/156998420/">如何永久注销不想用的邮箱</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>职业</title>
    <url>/2017/04/19/career/</url>
    <content><![CDATA[<h1 id="要有主动性"><a href="#要有主动性" class="headerlink" title="要有主动性"></a>要有主动性</h1><p>L<br>工作态度是第一位的，工作能力其次。<br>工作过程中要有主动性，不能让主管耳提面命的，整天催着才干活。<br>要有责任心。</p>
<p>W<br>做产品和做研发不一样。<br>做研发关注技术，关注深度。新员工有人指点技术？。<br>做产品，强调解决问题。对技术、框架有丰富的了解（强调数目），在众多的技术和框架中找到解决问题的最优方案，然后可能才是深挖这个技术怎么用。所以哪怕是老员工，也都是在接手新任务，了解新框架，学习代码……所以，有时间多了解新技术、新框架，在有新产品，新任务的时候才能有<strong>做选择</strong>的资本。</p>
<a id="more"></a>

<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>和同事、上司之间要注意沟通技巧，即使没有技巧可言，沟通过程让自己感到压抑、不愉快，也要<strong>坚持</strong>弄清楚工作任务，甚至任务细节之后再行动，不懂就要问。<strong>不得退缩，不得拖拖拉拉。沟通成本太大。</strong></p>
<h1 id="得过且过"><a href="#得过且过" class="headerlink" title="得过且过"></a>得过且过</h1><p>2016/4/8 9:33:31</p>
<p>对比丫头的工作，愈发感觉“尸位素餐”</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/career/551b1948-fc1e-4a43-bf99-a8e034e202c0.jpg" alt="聊天截图"><br>我在新公司已半年，在接下来的一年或者一年半里有什么目标和计划？不能像目前这个样子，混沌地如无头苍蝇般，且每个月就拿6K的固定数目的工资。最主要的就是消费压力，可是最重要的是职业规划。要找出路的。</p>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>C、C++ 和 VC++ 中的字符串</title>
    <url>/2016/11/08/char-string-CString/</url>
    <content><![CDATA[<p>我们先从使用的角度，从最直观的数据类型说起。</p>
<p>ps 这一篇笔记并不显式地涉及 <code>wchar_t</code>，也不包含字符（串）之间如何转换。更多内容请跳转 <a href="https://tnie.github.io/2016/11/16/char-wchar-t/">字符（串）之间的转换</a></p>
<h1 id="类型：char-char-string-CString"><a href="#类型：char-char-string-CString" class="headerlink" title="类型：char[]\char*\string\CString"></a>类型：char[]\char*\string\CString</h1><p>转帖来源：<a href="http://blog.csdn.net/conanswp/article/details/23341901">C++中的字符串</a></p>
<p>C++支持两种字符串：C风格字符串和string。之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为它和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，它集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 <code>=</code> 进行赋值操作，<code>==</code> 进行比较，<code>+</code> 做串联（是不是很简单:-D）。我们尽可以把它看成是C++的基本数据类型。此外，CString类在MFC中广泛应用，简化了字符串的处理。</p>
<a id="more"></a>

<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;		//如果是C++代码，用cstring；如果是写C 请用string.h</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;							<span class="comment">//字符串数组  </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str1)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str1)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//sizeof计算占用的空间，包括\0  </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;strlen(str1)=&quot;</span>&lt;&lt;<span class="built_in">strlen</span>(str1)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//strlen计算字符串长度，不包括\0  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span>* str2 = <span class="string">&quot;Hello&quot;</span>;							<span class="comment">//字符串指针  </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str2)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str2)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//sizeof计算指针=4  </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;strlen(str2)=&quot;</span>&lt;&lt;<span class="built_in">strlen</span>(str2)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//strlen计算字符串长度，不包括\0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:如果操作系统是32位,则指针（无论是什么类型的指针）是按32位寻址的,一个字节8位,所以得出其长度为32/8=4</p>
<p>延伸阅读：<a href="http://blog.csdn.net/kangroger/article/details/20653255">sizeof(数组名)和sizeof(指针)</a> 、<a href="http://blog.csdn.net/yhm_js/article/details/6140779">C++指针长度size</a></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">//2.string类  </span></span><br><span class="line"><span class="comment">//a.定义和初始化  </span></span><br><span class="line"><span class="built_in">string</span> s1;                          <span class="comment">//默认无参构造，空串  </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;                      <span class="comment">//拷贝构造  </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2,<span class="number">0</span>)</span></span>;                    <span class="comment">//s2内位置字符初始化s3  </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(str1)</span></span>;                    <span class="comment">//使用c风格字符串初始化  </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;                  <span class="comment">//生成10个a的字符串  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//b.常用操作  </span></span><br><span class="line">s1 = s5;                            <span class="comment">//赋值，也可使用assign。s1内容清空，然后将s5的内容拷贝到s1处  </span></span><br><span class="line">s1 += s5;                           <span class="comment">//尾部添加，也可使用push_back，append  </span></span><br><span class="line">s1.insert(<span class="number">0</span>,str2);                  <span class="comment">//插入字符串  </span></span><br><span class="line">s1.size();                          <span class="comment">//返回字符数量，也可用length  </span></span><br><span class="line">s1.c_str();                         <span class="comment">//返回C风格字符串，data()返回字符数组不包括\0,c_str()包括\0，  </span></span><br><span class="line">                                    <span class="comment">//copy()则把字符串的内容复制或写入既有的c_string或字符数组内  </span></span><br><span class="line">s1.empty();                         <span class="comment">//检测是否为空  </span></span><br><span class="line"><span class="built_in">string</span>::iterator iter = s1.begin(); <span class="comment">//返回迭代器，rbegin为逆向迭代器  </span></span><br><span class="line"></span><br><span class="line">s1.compare(s2);                     <span class="comment">//比较  </span></span><br><span class="line">s1.find(<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>);                     <span class="comment">//从位置0开始查找a,返回位置  </span></span><br><span class="line">s1.replace(<span class="number">0</span>,<span class="number">10</span>,str2);              <span class="comment">//用str2替换从位置0开始的10个字符  </span></span><br><span class="line">s1.erase(<span class="number">0</span>,<span class="number">10</span>);                     <span class="comment">//删除从位置0开始的10个字符</span></span><br></pre></td></tr></table></figure>
<p>延伸阅读：<a href="http://www.cnblogs.com/qlwy/archive/2012/03/25/2416937.html">string中c_str()、data()、copy(p,n)函数的用法</a></p>
<h2 id="CString类"><a href="#CString类" class="headerlink" title="CString类"></a>CString类</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CString str;</span><br><span class="line"><span class="function">CString <span class="title">str1</span><span class="params">(_T(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line">CString str2 = _T(<span class="string">&quot;defg&quot;</span>);</span><br><span class="line"> </span><br><span class="line">TCHAR szBuf[] = _T(<span class="string">&quot;kkk&quot;</span>);</span><br><span class="line"><span class="function">CString <span class="title">str3</span><span class="params">(szBuf)</span></span>;</span><br><span class="line">CString str4 = szBuf;</span><br><span class="line"> </span><br><span class="line">TCHAR *p = _T(<span class="string">&quot;1k2&quot;</span>);</span><br><span class="line"><span class="comment">//TCHAR * 转换为 CString</span></span><br><span class="line"><span class="function">CString <span class="title">str5</span><span class="params">(p)</span></span>;</span><br><span class="line">CString str6 = p;</span><br><span class="line"> </span><br><span class="line"><span class="function">CString <span class="title">str7</span><span class="params">(str1)</span></span>;</span><br><span class="line">CString str8 = str7;</span><br></pre></td></tr></table></figure>
<h3 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h3><ul>
<li><p>长度：<code>GetLength();</code></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(_T(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> len = str.GetLength(); <span class="comment">//len == 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>是否为空，即不含字符：<code>IsEmpty();</code></p>
</li>
<li><p>清空字符串：<code>Empty();</code></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(_T(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line">BOOL mEmpty = str.IsEmpty(); <span class="comment">//mEmpty == FALSE</span></span><br><span class="line">str.Empty();</span><br><span class="line">mEmpty = str.IsEmpty(); <span class="comment">//mEmpty == TRUE</span></span><br></pre></td></tr></table></figure></li>
<li><p>转换大小写：<code>MakeUpper</code>、<code>MakeLower</code></p>
</li>
<li><p>转换顺序：<code>MakeReverse</code></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(_T(<span class="string">&quot;Abc&quot;</span>))</span></span>;</span><br><span class="line">str.MakeUpper(); <span class="comment">//str == ABC</span></span><br><span class="line">str.MakeLower(); <span class="comment">//str == abc</span></span><br><span class="line">str.MakeReverse(); <span class="comment">//str == cba</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串的连接：<code>+</code>、<code>+=</code></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(_T(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line">str = _T(<span class="string">&quot;de&quot;</span>) + str + _T(<span class="string">&quot;kp&quot;</span>);<span class="comment">//str == deabckp</span></span><br><span class="line">str += _T(<span class="string">&quot;123&quot;</span>); <span class="comment">//str == deabckp123</span></span><br><span class="line">TCHAR szBuf[] = _T(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">str += szBuf; <span class="comment">//str == deabckp123789</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串的比较：<code>==</code>、<code>!=</code>、(<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 不常用)、<code>Compare</code>(区分大小写)、<code>CompareNoCase</code>(不区分大小写)</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str1</span><span class="params">(_T(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line">CString str2 = _T(<span class="string">&quot;aBc&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (str1 == str2)&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;str1 等于 str2&quot;</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;str1 不等于 str2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延伸阅读：<a href="http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html">CString 成员函数用法大全</a></p>
</li>
</ul>
<h1 id="头文件：string-cstring-string-h"><a href="#头文件：string-cstring-string-h" class="headerlink" title="头文件：string\cstring\string.h"></a>头文件：string\cstring\string.h</h1><p>接下来我们再深入一点，说说有关的头文件。（不涉及 Windows）</p>
<h2 id="先上结论"><a href="#先上结论" class="headerlink" title="先上结论"></a>先上结论</h2><p>参考自：<a href="http://blog.sina.com.cn/s/blog_6ce6d0bf010145or.html">cstring,string,string.h 区别比较</a></p>
<p>首先，要明确的是<strong>cstring, string, string.h 是三个文件名，而不是类名</strong>，如果你将vs 2010（或者其它版本）安装在默认路径下，这三个文件可以在 C:\Program Files\Microsoft Visual Studio 10.0\VC\include 路径下找到，查看每个文件里面的内容，结合网上看的一些帖子，我得出以下结论：</p>
<ol>
<li><p>string.h 是C标准库下的文件，C++向下兼容C，所以包含了该文件，这个文件应该是原封不动的与C标准库下一致的。类似这样的文件还有math.h，setjmp.h，stdlib.h，stddef.h等等C标准库下的头文件；</p>
</li>
<li><p>cstring 是C++对string.h的简略升级与包装，并将它放置在命名空间 <code>std</code> 下，该文件的所有代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cstring standard header</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CSTRING_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CSTRING_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;yvals.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _STD_USING</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">undef</span> _STD_USING</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> _STD_USING</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* _STD_USING */</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _STD_USING */</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> _GLOBAL_USING &amp;&amp; !defined(RC_INVOKED)</span></span><br><span class="line">_STD_BEGIN</span><br><span class="line"><span class="keyword">using</span> _CSTD <span class="keyword">size_t</span>; <span class="keyword">using</span> _CSTD <span class="built_in">memchr</span>; <span class="keyword">using</span> _CSTD <span class="built_in">memcmp</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _CSTD <span class="built_in">memcpy</span>; <span class="keyword">using</span> _CSTD memmove; <span class="keyword">using</span> _CSTD <span class="built_in">memset</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD <span class="built_in">strcat</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strchr</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strcmp</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD strcoll; <span class="keyword">using</span> _CSTD <span class="built_in">strcpy</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strcspn</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD strerror; <span class="keyword">using</span> _CSTD <span class="built_in">strlen</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strncat</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD <span class="built_in">strncmp</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strncpy</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strpbrk</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD <span class="built_in">strrchr</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strspn</span>; <span class="keyword">using</span> _CSTD <span class="built_in">strstr</span>;</span><br><span class="line"><span class="keyword">using</span> _CSTD strtok; <span class="keyword">using</span> _CSTD strxfrm;</span><br><span class="line">_STD_END</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _GLOBAL_USING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _CSTRING_ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.</span></span><br><span class="line"><span class="comment"> * Consult your license regarding permissions and restrictions.</span></span><br><span class="line"><span class="comment">V5.20:0009 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 所以，使用 cstring 时要用 <code>using namespace std</code>，cstring 里的内容与方法，应该与 C 标准库下的 string.h 一致。</p>
</li>
<li><p>而string就与前面两个有本质差别了。它是C++自己开发封装的类，同样用于字符串操作，其中用到了很多的操作符重载等方法，实现方法和C标准库中的string.h有很大差别。</p>
</li>
<li><p>另外容易混淆的是，<strong>在MFC中，还有CString类，它与cstring是有本质区别的</strong>（形式上区分大小写），前者是类名，使用时包含头文件 afx.h，后者是文件名，两者实现的方法也大相径庭。</p>
</li>
</ol>
<h2 id="再讲故事"><a href="#再讲故事" class="headerlink" title="再讲故事"></a>再讲故事</h2><p>参考自：<a href="http://blog.sina.com.cn/s/blog_6e7fed390100y2xx.html">string.h cstring string的关系</a></p>
<p>延伸看一下，C++ 标准库。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Cpp-Standard-Library.gif"></p>
<p>C++标准库很大。非常大。难以置信的大。怎么个大法？这么说吧：在C++标准中，关于标准库的规格说明占了密密麻麻300 多页，这还不包括标准C 库，后者只是”作为参考”（老实说，原文就是用的这个词）包含在C++库中。当然，并非总是越大越好，但在现在的情况下，确实越大越好，因为大的库会包含大量的功能。标准库中的功能越多，开发自己的应用程序时能借助的功能就越多。C++库并非提供了一切（很明显的是，没有提供并发和图形用户接口的支持），但确实提供了很多。几乎任何事你都可以求助于它。</p>
<p>在归纳标准库中有些什么之前，需要介绍一下它是如何组织的。因为标准库中东西如此之多，你（或象你一样的其他什么人）所选择的类名或函数名就很有可能和标准库中的某个名字相同。为了避免这种情况所造成的名字冲突，实际上标准库中的一切都被放在名字空间 <code>std</code> 中。但这带来了一个新问题。无数现有的C++代码都依赖于使用了多年的伪标准库中的功能，例如，声明在 <code>&lt;iostream.h&gt;</code>，<code>&lt;complex.h&gt;</code>，<code>&lt;limits.h&gt;</code> 等头文件中的功能。现有软件没有针对使用名字空间而进行设计，如果用 <code>std</code> 来包装标准库导致现有代码不能用，将是一种可耻行为。（这种釜底抽薪的做法会让现有代码的程序员说出比”可耻” 更难听的话）慑于被激怒的程序员会产生的破坏力，标准委员会决定为包装了 <code>std</code> 的那部分标准库构件创建新的头文件名。</p>
<p><strong>生成新头文件的方法仅仅是将现有C++头 文件名中的.h 去掉</strong>，方法本身不重要，正如最后产生的结果不一致也并不重要一样。所以 <code>&lt;iostream.h&gt;</code> 变成了 <code>&lt;iostream&gt;</code>，<code>&lt;complex.h&gt;</code> 变成了 <code>&lt;complex&gt;</code> 等等。<strong>对于C 头文件，采用同样的方法，但在每个名字前还要添加一个C。</strong>所以 C 的 <code>&lt;string.h&gt;</code> 变成了 <code>&lt;cstring&gt;</code>，<code>&lt;stdio.h&gt;</code> 变成 <code>&lt;cstdio&gt;</code>。最后一点是，旧的C++头文件是官方所反对使用的（即，明确列出不再支持），但旧的 C 头文件则没有（以保持对 C 的兼容性）。实际上，编译器制造商不会停止对客户现有软件提供支持，所以可以预计，旧的C++头文件在未来几年内还是会被支持。</p>
<p>所以，实际来说，下面是C++头文件的现状：</p>
<ul>
<li>旧的 C++ 头文件名如 <code>&lt;iostream.h&gt;</code> 将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在名字空间 <code>std</code> 中。</li>
<li>新的 C++ 头文件如 <code>&lt;iostream&gt;</code> 包含的基本功能和对应的旧头文件相同，但头文件的内容在名字空间 <code>std</code> 中。（在标准化的过程中，库中有些部分的细节被修改了，所以旧头文件和新头文件中的实体不一定完全对应。）</li>
<li>标准 C 头文件如 <code>&lt;stdio.h&gt;</code> 继续被支持。头文件的内容不在 <code>std</code> 中。</li>
<li>具有 C 库功能的新 C++ 头文件具有如 <code>&lt;cstdio&gt;</code> 这样的名字。它们提供的内容和相应的旧 C 头文件相同，只是内容在 <code>std</code> 中。</li>
</ul>
<h2 id="重申结论"><a href="#重申结论" class="headerlink" title="重申结论"></a>重申结论</h2><p>重要的事情放在最后：</p>
<ol>
<li><p><code>&lt;string.h&gt;</code> 是 C 标准库中的字符串处理函数的头文件 如 <code>strcmp</code> <code>strcat</code> 等等函数</p>
</li>
<li><p><code>&lt;cstring&gt;</code> 是与 C 标准库的 <code>&lt;string.h&gt;</code> 相对应的，但被加入到 <code>std</code> 名字空间的版本。</p>
<p> cstring 是 C++ 的组成部分，它可以说是把 C 的 string.h 的升级版，但它不是 C 的组成部分。</p>
<p> 所以<strong>如果你用的是 C++，那么请用 cstring；如果你用的是 C 请用 string.h。</strong></p>
</li>
<li><p><code>&lt;string.h&gt;</code> 和 <code>&lt;string&gt;</code></p>
<p> string.h 和 C++中的string类是有很大区别的，<code>&lt;string&gt;</code> 并非 <code>&lt;string.h&gt;</code> 的“升级版本”，他们是毫无关系的两个头文件。</p>
<p> string，它是C++定义的 <code>std::string</code> 所使用的文件，是string类的头文件，属于 STL 范畴。它有很多对字符串操作的方法。</p>
</li>
<li><p>string 与 cstring: 看了以上3点，这两者的区别大家应该很明白了，唯一的联系就是都是 C++ 组成部分。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>字符（串）之间的转换</title>
    <url>/2016/11/16/char-wchar-t/</url>
    <content><![CDATA[<p>字符串之间的转换分为两类：</p>
<ol>
<li>底层字符集之间的转换，表现为 <code>char</code> <code>wchar_t</code> 之间的转换，<code>string</code> <code>wstring</code> 之间的转换；</li>
<li>在此之上牵扯到 Windows 平台下的各种字符串之间的转换；去伪存真，归根到底还是第一种转换。</li>
</ol>
<p>为了“知其然，也要知其所以然”，我们在描述相互转换之前，先介绍一些相关的类型。上层所有的字符串类型归根到底都是对底层 <code>char</code> 或者 <code>wchar_t</code> 类型的封装，如果真有刨根问底的兴趣，就需要了解 <code>char</code> <code>wchar_t</code> 的关联和区别。我们比较熟悉 <code>char</code>，接下来看一下 <code>wchar_t</code>。</p>
<a id="more"></a>

<h1 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h1><p>虽然我们大多是在 windows 下开发时接触过 <code>wchar_t</code>，但它其实是 C 标准（但不是内置类型）。类 Unix 环境下使用 <code>wchar_t</code> 并不广泛。</p>
<p>我们看一下 <a href="https://zh.wikipedia.org/wiki/%E5%AF%AC%E5%AD%97%E5%85%83">维基百科中对“宽字符”的解释</a>：</p>
<blockquote>
<p>宽字符（Wide character） 是程序设计的术语。它是一个抽象的术语（<strong>没有规定具体实现细节</strong>），用以表示比8位字符还宽的数据类型。它<strong>不同于 Unicode</strong>。</p>
</blockquote>
<p>尴尬的是标准并未规定具体的实现细节，而 Windows 下的 <code>wchar_t</code> 是破坏（不符合）了ANSI/ISO C标准的。</p>
<blockquote>
<p><code>wchar_t</code> 的宽度属于编译器的特性，且可以小到8位。所以程序若需要跨过所有 C 和 C++ 编译器的可携性，就不应使用 <code>wchar_t</code> 存储 Unicode 文字。<code>wchar_t</code> 类型是为存储编译器定义的宽字符，在部分编译器中，其可以是 Unicode 字符。</p>
<p>在Windows API中，<code>wchar_t</code> 是16位宽。Windows API因<strong>不使 <code>wchar_t</code> 字符类型在单一 <code>wchar_t</code> 单元中支持所有系统可表示的字符</strong>，而破坏了 ANSI/ISO C 标准。<code>wchar_t</code> 在Windows下，反而表示一个 UTF-16 小尾字符（或 UTF-16 的一部分）。</p>
<p>在类Unix系统中，<code>wchar_t</code> 是32位宽。</p>
</blockquote>
<p>如果对 Unicode 字符集有足够的认识，我们就能知道 16 位无法满足“表示所有 Unicode 字符”。一般来说，UTF-x，x表示这套编码一个单位至少占用x位，因为Unicode最长达到32位，所以UTF-x通常是变长的（除了UTF-32）。</p>
<blockquote>
<p>需要指出的是，C++标准中对 <code>wchar_t</code> 的要求是要能表示所有系统能识别的字符。Windows 自称支持 Unicode，但是其 <code>wchar_t</code> 却不能表示所有的 Unicode，由此违背了 C++ 标准。 引用自 <a href="http://www.cppblog.com/lf426/archive/2010/06/25/118739.html">彻底解密C++宽字符：2、Unicode和UTF</a></p>
</blockquote>
<ul>
<li><a href="http://stackoverflow.com/questions/4588302/why-isnt-wchar-t-widely-used-in-code-for-linux-related-platforms">Why isn’t wchar_t widely used in code for Linux / related platforms?</a></li>
</ul>
<p><strong>结论：</strong>宽字符的宽度依赖于平台，局限性太高。不推荐使用。Windows 虽然广泛使用宽字符，但其有一个愚蠢的（错误的）假设：所有字符只使用两位字节就能表示。微软也有替人背锅的嫌疑，也可能是历史包袱的原因。</p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>学习过程中难免又涉及到更底层的字符集（character set）、字符编码（character encoding）知识，可以参考 <a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html">字符集和字符编码（Charset &amp; Encoding） - cnblogs 吴秦</a>。</p>
<p>这里需要强调的是：</p>
<blockquote>
<p>术语字符编码（character encoding），字符映射（character map），字符集（character set）或者代码页，在历史上往往是同义概念。 引用自 <a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">维基百科</a></p>
</blockquote>
<p>这句话适用于 ANSI 体系。后来随着 Unicode 的流行，随着其 UTF-32、UTF-16 和 UTF-8 的使用，为了更清楚的理解其中的关联</p>
<blockquote>
<p>可以这样理解：Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。</p>
</blockquote>
<h1 id="mbs-和-wcs"><a href="#mbs-和-wcs" class="headerlink" title="mbs 和 wcs"></a>mbs 和 wcs</h1><blockquote>
<p>mbs：multi byte string，用char作为存储类型，一个字符可能对应1个或者多个char，不能直接确定字符边界。charset不确定。过去的程序都是采用mbs的。</p>
</blockquote>
<blockquote>
<p>wcs：wide character string，用wchar_t作为存储类型，一个字符对于一个wchar_t。使用unicode编码，charset与OS相关，在windows平台中为UTF16(UCS-2)，在大多数unix平台中为UTF32(UCS-4)。</p>
</blockquote>
<p>mbs 的具体表现形式有 C 中 <code>char*</code>/<code>char[]</code>，C++ 中的 <code>std::string</code>；wcs 的具体表现形式有 C 中的 <code>wchar_t*</code>/<code>wchar_t[]</code>，C++ 中的 <code>std::wstring</code>。</p>
<p>要“知其所以然”，参考 <a href="http://www.cppblog.com/lf426/archive/2010/06/25/118707.html">彻底解密C++宽字符：1、从char到wchar_t</a>，讲解的很透彻。</p>
<p>要“知其然”，C 代码怎么写，可以参考 <a href="http://www.cnblogs.com/MichaelOwen/articles/2128771.html">wchar和char之间的相互转换</a>；C++ 代码怎么写，可以参考 <a href="http://www.cppblog.com/lf426/archive/2010/06/26/118762.html">彻底解密C++宽字符：3、利用C运行时库函数转换</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">wcstombs(<span class="keyword">char</span> * to,<span class="keyword">wchar_t</span> * from,<span class="keyword">size_t</span> _maxCount);</span><br><span class="line">mbstowcs(<span class="keyword">wchar_t</span> * to,<span class="keyword">char</span> * from,<span class="keyword">size_t</span> _maxCount);</span><br></pre></td></tr></table></figure>
<p>char 和 wchar_t 之间的转换可以使用上述两个函数，使用的关键在于 <code>setlocale()</code> 和第三个参数，难点也在第三个参数：</p>
<ol>
<li>设置本地策略集，使得编译器知晓多字节字符集使用的具体是哪一种；</li>
<li><del>第三个参数表示目标指针的<strong>字节长度</strong>，尤其是转为宽字符时需仔细辨识，一个宽字符占用的字节和平台有严格的关联。</del></li>
<li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_mbstowcs.htm">mbstowcs()</a> 第三个参数 This is the maximum number of wchar_t characters to be interpreted.</li>
<li><a href="https://www.tutorialspoint.com/c_standard_library/c_function_wcstombs.htm">wcstombs()</a> 第三个参数 This is the maximum number of bytes to be written to str.</li>
</ol>
<p>第三个参数的赋值很容易弄错，而且在不同平台下还有出入。在网上找到 <a href="http://blog.csdn.net/xiaobai1593/article/details/7063535">一篇说明</a>，在第一个参数赋值 <code>NULL</code>（此时第三个参数也无意义，随便赋值） 的情况下，返回目标缓存所需的大小（不含终结符）：</p>
<ol>
<li><code>size_t req = mbstowcs(NULL, str, 0);</code> 返回 str 转宽字符串时 wchar_t 字符个数；</li>
<li><code>size_t req = wcstombs(NULL, wstr, 0);</code> 返回 wstr 转多字节字符串时字节数（同时也是 char 类型个数）；</li>
</ol>
<p>所以我们综合有关讲解，给出一份跨平台，省时省力搬来搬去可以直接用的 C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">s2ws</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::locale old_loc =</span><br><span class="line">        <span class="built_in">std</span>::locale::global(<span class="built_in">std</span>::locale(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* src_str = s.c_str();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> buffer_size = <span class="built_in">std</span>::mbstowcs(<span class="literal">NULL</span>, src_str, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">wchar_t</span>* dst_wstr = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[buffer_size];</span><br><span class="line">    wmemset(dst_wstr, <span class="number">0</span>, buffer_size);</span><br><span class="line">    <span class="built_in">std</span>::mbstowcs(dst_wstr, src_str, buffer_size);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> result = dst_wstr;</span><br><span class="line">    <span class="keyword">delete</span> []dst_wstr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::locale::global(old_loc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2s</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; ws)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::locale old_loc =</span><br><span class="line">        <span class="built_in">std</span>::locale::global(<span class="built_in">std</span>::locale(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* src_wstr = ws.c_str();</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = <span class="built_in">std</span>::wcstombs(<span class="literal">NULL</span> ,src_wstr, <span class="number">0</span>);;</span><br><span class="line">    <span class="keyword">char</span>* dst_str = <span class="keyword">new</span> <span class="keyword">char</span>[buffer_size];</span><br><span class="line">    <span class="built_in">memset</span>(dst_str, <span class="number">0</span>, buffer_size);</span><br><span class="line">    <span class="built_in">std</span>::wcstombs(dst_str ,src_wstr, buffer_size);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = dst_str;</span><br><span class="line">    <span class="keyword">delete</span> []dst_str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::locale::global(old_loc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps 这里主要是为了演示 <code>mbstowcs()</code> 和 <code>wcstombs()</code> 的使用。如果是转换 <code>string</code> 和 <code>wstring</code>，可以参考 <a href="http://stackoverflow.com/questions/4804298/how-to-convert-wstring-into-string">How to convert wstring into string?</a></p>
<p>不清楚为什么网上好多资源给出的代码都是手动给定第三个参数，/(ㄒoㄒ)/~~</p>
<h2 id="为什么要有本地策略集？"><a href="#为什么要有本地策略集？" class="headerlink" title="为什么要有本地策略集？"></a>为什么要有本地策略集？</h2><p>在不同平台，编译器编译源代码时根据字符串前是否有 L 前缀，将其 <a href="http://www.cppblog.com/lf426/archive/2010/06/25/118707.html">硬编码</a> 为不同的字节码：</p>
<table>
<thead>
<tr>
<th>os/</th>
<th>L</th>
<th><del>L</del></th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>UTF-32</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Windows</td>
<td>USC-2</td>
<td>ASCII/gb2312/big5</td>
</tr>
</tbody></table>
<ul>
<li>如果字符串有前缀 L，那么在编译器确定的前提下，使用的字符编码是确定的，硬编码的内容也是确定的；</li>
<li>如果字符串无前缀 L，那么编译器 <a href="http://www.cppblog.com/lf426/archive/2010/06/25/118707.html">直接读取字符（串）在源文件中的编码数值</a>，因为源文件编码不同，其硬编码的内容是不确定的；</li>
</ul>
<p>基于上述描述可以推断，char 和 wchar_t 互转，在编译项目时（编译器确定）宽字符的硬编码映射单一，但多字节字符的硬编码（主要针对 ANSI 系的非 ASCII 部分）应该以哪种字符集编码方式解析（通俗地理解就是某几个字节究竟是翻译成简体中文、繁体中文还是日文之类的）是不确定的。所以需要本地策略集（locale）。</p>
<p>ps 如果要做国际化的东西，需要深入了解 locale 策略，可以学习 <a href="http://www.cppblog.com/lf426/archive/2010/06/25/118707.html">彻底解密C++宽字符</a> 的系列文章作为切入点。中间两三篇涉及代码的具体实现可能略微复杂，可以暂时忽略，但推荐一定要读前三篇和 <a href="http://www.cppblog.com/lf426/archive/2010/06/26/118788.html">彻底解密C++宽字符：6、国际化策略（完）</a>，通过了解“硬编码的硬伤”进一步理解“硬编码”，理解编译、字符集等偏底层的知识。</p>
<h1 id="LP-C-W-T-STR"><a href="#LP-C-W-T-STR" class="headerlink" title="LP[,C][,W,T]STR"></a>LP[,C][,W,T]STR</h1><p>这几个是 Windows 平台对 char wchar_t 类型的封装。如标题，我们可以组合出 6 种情况：</p>
<table>
<thead>
<tr>
<th>xx</th>
<th>x</th>
<th>W</th>
<th>T</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>LPSTR</td>
<td>LPWSTR</td>
<td>LPTSTR</td>
</tr>
<tr>
<td>C</td>
<td>LPCSTR</td>
<td>LPCWSTR</td>
<td>LPCTSTR</td>
</tr>
<tr>
<td>基于</td>
<td>char</td>
<td>wchar_t</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>L表示 <code>long</code> 指针，这是为了兼容 Windows 3.1 等 16 位操作系统遗留下来的，在 win32 中以及其他的 32位操作系统中， <code>long</code> 指针和 <code>near</code> 指针及 <code>far</code> 修饰符都是为了兼容的作用，没有实际意义。即 win32 中，<code>long</code> <code>near</code> <code>far</code> 指针与普通指针没有区别，LP 与P是等效的。</li>
<li>P表示这是一个指针。</li>
<li>STR表示这个变量是一个字符串。</li>
<li>C表示是一个常量，<code>const</code>。</li>
<li>W 来源于 <code>wchar_t</code>（宽字符）</li>
<li>T表示<strong>_T宏</strong>,这个宏用来表示你的字符是否使用 UNICODE, 如果你的程序定义了 UNICODE或者其他相关的宏，那么这个字符或者字符串将被作为 UNICODE字符串，否则就是标准的 ANSI字符串。</li>
</ul>
<p>LPTSTR：如果定义了 UNICODE宏则 LPTSTR被定义为 LPWSTR，<code>typedef LPTSTR LPWSTR</code>;否则LPTSTR被定义为LPSTR，<code>typedef LPTSTR LPSTR</code>。</p>
<p>更系统、更精彩的介绍参考 <a href="http://www.codeproject.com/Articles/76252/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR-etc">What are TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR (etc.)?</a></p>
<p>关于这些类型彼此之间转换以及和 CString 之间的转换，可以参考 <a href="http://www.cnblogs.com/goed/archive/2011/11/11/2245702.html">懒得起名…</a>。这里只罗列几个特殊的转换：</p>
<p>W2A W2CA CW2A <del>CW2CA</del><br>A2W A2CW CA2W <del>CA2CW</del></p>
<p>有上述这些也可以推测出 W2T A2T T2W T2A 等等的存在，这里特别提一下 [CT,CW,CA]2[CT,CW,CA] 是存在的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CString和LPCTSTR不需要转化，两者是等价的;</span></span><br><span class="line"><span class="comment">// 但去掉常量属性呢？即 CString 向 LPTSTR</span></span><br><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(<span class="string">&quot;string&quot;</span>)</span></span>;</span><br><span class="line">LPTSTR pStr = str.GetBuffer();</span><br><span class="line">str.ReleaseBuffer();</span><br><span class="line"><span class="comment">//注意：GetBuffer()和ReleaseBuffer()之间不可以调用任何的CString函数，比如GetLength()函数，因为无法预测对内存的操作，所以任何CString函数得到的结果都是不确定的。</span></span><br></pre></td></tr></table></figure>
<h1 id="CString-和-string"><a href="#CString-和-string" class="headerlink" title="CString 和 string"></a>CString 和 string</h1><p><code>CString</code> 是动态的 <code>TCHAR</code> 数组。<code>TCHAR</code> 是一个宏，是对 <code>char</code> 和 <code>wchar_t</code> 的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ATL::CStringT&lt; <span class="keyword">wchar_t</span>, StrTraitMFC_DLL&lt; <span class="keyword">wchar_t</span> &gt; &gt; CStringW;</span><br><span class="line"><span class="keyword">typedef</span> ATL::CStringT&lt; <span class="keyword">char</span>, StrTraitMFC_DLL&lt; <span class="keyword">char</span> &gt; &gt; CStringA;</span><br><span class="line"><span class="keyword">typedef</span> ATL::CStringT&lt; TCHAR, StrTraitMFC_DLL&lt; TCHAR &gt; &gt; CString;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>再次强调，Windows 的 <code>wchar_t</code> 对 Unicode 的支持是不完善的。</p>
<p><code>string</code> 是动态的 <code>char</code> 数组；<code>wstring</code> 是动态的 <code>wchar_t</code> 数组。所以 CString 转 string 存在潜在的 <code>wchar_t</code> 转换为 <code>char</code> 类型的可能，反之亦然。</p>
<h2 id="CString-转-string"><a href="#CString-转-string" class="headerlink" title="CString 转 string"></a>CString 转 string</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CString cstr;</span><br><span class="line"><span class="function">CT2CA <span class="title">psz</span><span class="params">(cstr)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(psz)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="string-转-CString"><a href="#string-转-CString" class="headerlink" title="string 转 CString"></a>string 转 CString</h2><p>下意识就会使用 CA2CT 宏做逆向操作，但其实我们用 char* 构造 CString 时无论是否 UNICODE 工程还是 MBCS 工程都是可以顺利编译的:-D</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;hah&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">CString <span class="title">cstr</span><span class="params">(str.c_str())</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <a href="http://stackoverflow.com/questions/19616828/how-to-convert-stdstring-to-cstring-in-unicode-project">代码片段三</a> 中提到一种特殊情况，即 string 字符串中存在 <code>\0</code> 字符时，可以如下构造 CString</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">stdstr</span><span class="params">(<span class="string">&quot;foo&quot;</span>)</span></span>;</span><br><span class="line">stdstr += <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">stdstr += <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="function">CString <span class="title">cstr</span><span class="params">(stdstr.c_str(), stdstr.length())</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="CString-转-wstring"><a href="#CString-转-wstring" class="headerlink" title="CString 转 wstring"></a>CString 转 wstring</h2><ul>
<li><a href="http://stackoverflow.com/questions/258050/how-to-convert-cstring-and-stdstring-stdwstring-to-each-other">代码片段四</a></li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>零散</title>
    <url>/2017/04/28/cherry/</url>
    <content><![CDATA[<p> 2016/3/14 10:51:03</p>
<p>办公室抽屉中草稿纸上的内容，挑拣有用的信息誊录在此。草稿纸扔掉。</p>
<blockquote>
<p>以下每一项都可以展开，写一篇笔记的</p>
</blockquote>
<a id="more"></a>

<h1 id="VS2010-学习笔记整理"><a href="#VS2010-学习笔记整理" class="headerlink" title="VS2010 学习笔记整理"></a>VS2010 学习笔记整理</h1><ul>
<li><p>启用行号</p>
</li>
<li><p>F5 调试，ctrl+F5 运行不调试</p>
</li>
<li><p>多显示器</p>
<p>  <img src="http://img.article.pchome.net/00/47/36/04/3.jpg" alt="是不是有种很爽的感觉"></p>
</li>
<li><p>目录配置 </p>
</li>
</ul>
<h1 id="UML-类图类与类之间关系表示方法：手机图片"><a href="#UML-类图类与类之间关系表示方法：手机图片" class="headerlink" title="UML 类图类与类之间关系表示方法：手机图片"></a>UML 类图类与类之间关系表示方法：<em>手机图片</em></h1><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/cherry/WP_20160314_003.jpg" alt="流程图"></p>
<h1 id="VIM-常用命令学习笔记整理"><a href="#VIM-常用命令学习笔记整理" class="headerlink" title="VIM 常用命令学习笔记整理"></a>VIM 常用命令学习笔记整理</h1><h1 id="复习-shell-及变量，进一步整理"><a href="#复习-shell-及变量，进一步整理" class="headerlink" title="复习 shell 及变量，进一步整理"></a>复习 shell 及变量，进一步整理</h1><h1 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h1><p>2015年10月29日 17:54:36</p>
<h2 id="字符集和字符编码，usc-和-unicode"><a href="#字符集和字符编码，usc-和-unicode" class="headerlink" title="字符集和字符编码，usc 和 unicode"></a><del>字符集和字符编码，usc 和 unicode</del></h2><p><del>参考：<a href="http://blog.csdn.net/revilwang/article/details/8763911">字符集与字符编码和宽字符之间的关系</a></del></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/cherry/fd19526e-273d-40a0-8dee-b0599e7fa862.png" alt="excel"></p>
<p><del>“UTF-8 编码还有一个优点，它是符合 C 语言字符串的要求，以 <code>&#39;\0&#39;</code> 结束，因此所有的普通字符串操作如 <code>strcpy</code> 等对 UTF-8 编码的字符完全有效，而 UTF-16, UTF-32等中间填充大量的 <code>&#39;\0&#39;</code> 字符，则不能使用这些函数。”</del></p>
<h2 id="ansi-体系和-unicode"><a href="#ansi-体系和-unicode" class="headerlink" title="ansi 体系和 unicode"></a>ansi 体系和 unicode</h2><p>参考：<a href="http://blog.csdn.net/stephen1315/article/details/7476236">Unicode 字符集和多字节字符集关系</a></p>
<p>ansi 机构最初的 ascii 字符集，后来各国各自扩充，中国大陆和新加坡等地区使用本地编码是 GB2312 或 GBK，中国港台地区使用的本地编码是 BIG5，韩国和日本的本地编码分别是 euc-kr 和 Shift_JIS。这些从 ANSI 标准派生的字符集被习惯的统称为 ANSI 字符集，它们正式的名称应该是 MBCS(Multi-Byte Chactacter System，即多字节字符系统)。ansi 体系，字符集一般只对应一种字符编码。</p>
<p>再后来，为了大一统，出现了 unicode 字符集。</p>
<h2 id="mbsc-和宽字节"><a href="#mbsc-和宽字节" class="headerlink" title="mbsc 和宽字节"></a>mbsc 和宽字节</h2><p>参考：<a href="http://blog.csdn.net/leixiaohua1020/article/details/12753723">单字节字符集，多字节字符集，Unicode</a></p>
<p>ASCII 是 SBCS。一个字节表示的 <code>0</code> 用来标志 SBCS 字符串的结束。  </p>
<p>DBCS 字符串的结束标志也是一个单字节表示的 <code>0</code>。  </p>
<p>Unicode 字符串使用两个字节表示的 <code>0</code> 作为它的结束标志。</p>
<p>——多字节（mbsc）包括 sbsc 和 dbsc 等。ascii 基本代表了 sbsc；ansi 和 mbsc 基本算同义词。</p>
<p>——宽字节，unicode 基本代表了宽字节。</p>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 操作</title>
    <url>/2017/03/10/commandsOfShell/</url>
    <content><![CDATA[<p>对于linux的学习会是一个很漫长、很有趣的过程。对于 Linux 命令的学习、日积月累，推荐 <a href="http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/">竹子-每日一个linux命令</a>、<a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html">工具参考篇</a></p>
<p>首先，你要知道哪些命令大概什么功能，能完成什么操作（这个重在积累，如果不知道只能 Google 之了），简单入门推荐 <a href="http://blog.csdn.net/ljianhui/article/details/11100625">最常用的20条命令</a>。然后，关于命令的具体用法可以 Google 之，也可以使用 <code>--help</code> <code>man</code> 等帮助。</p>
<a id="more"></a>

<h1 id="最常用的命令"><a href="#最常用的命令" class="headerlink" title="最常用的命令"></a>最常用的命令</h1><p>要有意识<strong>使用 <code>--help</code> 参数。</strong></p>
<ul>
<li><p>cd ls cp mv rm cat 目前已不必多说。</p>
</li>
<li><p>grep find tar 参数多多，多记多用。</p>
</li>
<li><p>file time 算是两个小惊喜</p>
<p>  file：该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了<br>  time：该命令用于测算一个命令（即程序）的执行时间。</p>
</li>
<li><p>chown chgrp chmod</p>
</li>
</ul>
<p>有一个很棒的tree命令，可以用来查看目录的树形结构。这个工具需要自己安装。使用方面可以参考<a href="http://blog.csdn.net/lwnylslwnyls/article/details/8211191">linux tree命令</a>，常用的：</p>
<ul>
<li>tree：当前目录下的所有内容显示</li>
<li>tree -L level：只显示当前目录下指定最大深度的目录结构</li>
</ul>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>参考 <a href="http://blog.csdn.net/beitiandijun/article/details/41678251">linux用户管理（1）</a>，如果有必要或者有时间可以看看作者其他的帖子。</p>
<ul>
<li>创建用户有两条命令：adduser和useradd。对于初次接触linux的**菜鸟使用 <code>adduser</code>**即可。两者的区别以及各自的详细使用查看原帖。</li>
<li>删除用户及其主目录：sudo userdel -r 用户名</li>
</ul>
<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><p>参考 <a href="http://linux.chinaunix.net/techdoc/system/2007/09/12/967663.shtml">Linux必学的系统管理命令</a></p>
<ul>
<li><p>df命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。</p>
</li>
<li><p>top命令用来显示执行中的程序进程，使用权限是所有用户。</p>
</li>
<li><p>free命令用来显示内存的使用情况，使用权限是所有用户。</p>
</li>
<li><p>quota命令用来显示磁盘使用情况和限制情况，使用权限超级用户。</p>
</li>
<li><p>at命令用来在指定时刻执行指定的命令序列。</p>
</li>
<li><p>lp是打印文件的命令，使用权限是所有用户。</p>
</li>
<li><p>useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是超级用户。</p>
</li>
<li><p>groupadd命令用于将新组加入系统。</p>
</li>
<li><p><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds3/kill.htm">kill 命令</a> 用来中止一个进程。 </p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> pid     <span class="comment"># 通过发送缺省的 SIGTERM 信号到进程 pid 来停止它</span></span><br><span class="line"><span class="comment"># 如果进程 pid 已经做了特殊安排来忽略或覆盖 SIGTERM 信号，这个进程实际可能不停止</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid  <span class="comment"># 发送信号 9，即 SIGKILL 信号。SIGKILL 信号是个通常不能被忽略或覆盖的特殊信号。</span></span><br></pre></td></tr></table></figure></li>
<li><p><del>使用crontab命令可以修改crontab配置文件，然后该配置由cron公用程序在适当的时间执行，该命令使用权限是所有用户。</del> 表达真烂，读完这句话之后根本不知道 crontab 命令可以干什么。</p>
</li>
<li><p>通过 <a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html">crontab 命令</a>，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本</p>
<blockquote>
<p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的</p>
</blockquote>
<p>  ps: 区分 <a href="https://zh.wikipedia.org/wiki/Cron">cron</a> 和 <a href="http://www.quartz-scheduler.org/documentation/quartz-2.1.x/tutorials/crontrigger.html">Cron Trigger</a></p>
</li>
</ul>
<h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><p>参考 <a href="http://www.live-in.org/archives/878.html">Linux进程查看命令</a></p>
<ul>
<li><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html">ps 命令</a>：用于查看当前进程的情况</p>
<ul>
<li>ps</li>
<li>ps aux</li>
</ul>
</li>
<li><p>pstree命令：将进程用树状结构显示出来，显示出进程间的相互关系</p>
<ul>
<li>pstree -Aup</li>
</ul>
</li>
<li><p>top命令：动态显示系统当前任务情况，相当于任务管理器</p>
</li>
</ul>
<h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2><p>参考 <a href="http://www.cnblogs.com/peida/archive/2012/12/20/2825837.html">每天一个linux命令（42）：kill命令</a></p>
<p>Linux中的kill命令用来终止指定的进程（terminate a process）的运行，是Linux下进程管理的常用命令。</p>
<blockquote>
<p>通常，终止一个前台进程可以使用Ctrl+C键，但是，对于一个后台进程就须用kill命令来终止。</p>
</blockquote>
<p>kill命令是通过向进程发送指定的信号来结束相应进程的。</p>
<ol>
<li><p>在默认情况下，采用编号为15的TERM信号。</p>
<ul>
<li>情景一：如果进程没有捕获该信号，则进程终止;</li>
<li>情景二：这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。是优点，但也可能带来不便。</li>
<li>问题：有时候清理资源耗时很长，呈现“假死”现象；甚至清理时出现问题，直接卡死…</li>
</ul>
</li>
<li><p>可以使用编号为 9 的KILL信号，强行“杀掉”进程。</p>
<ul>
<li>优点：使用该信号可以无条件终止进程（其他的信号进程都可以捕获并选择忽略）。</li>
<li>缺点：强行终止进程，常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。</li>
<li>总之，发送 KILL 信号时必须小心，只有在万不得已时，才用 KILL 信号(9)</li>
</ul>
</li>
</ol>
<p>以下是常用的信号：（通过 kill -l 可以查看所有信号名称）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HUP     1    终端断线</span><br><span class="line">INT       2    中断（同 Ctrl + C）</span><br><span class="line">QUIT    3    退出（同 Ctrl + \）</span><br><span class="line">TERM    15    终止</span><br><span class="line">KILL      9    强制终止</span><br><span class="line">CONT   18    继续（与STOP相反， <span class="built_in">fg</span>/<span class="built_in">bg</span>命令）</span><br><span class="line">STOP    19    暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure>
<h2 id="前台任务、后台任务"><a href="#前台任务、后台任务" class="headerlink" title="前台任务、后台任务"></a>前台任务、后台任务</h2><p>了解前台任务、后台任务及两者之间的切换之前：</p>
<ol>
<li><p>要先熟悉 kill 命令，及常用信号（通过 kill -l 可以查看所有信号名称）。</p>
</li>
<li><p>要知道进程组（process group）、会话（session）的概念，参考 <a href="http://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html">Linux进程关系</a></p>
<blockquote>
<p>会话中的每个进程组称为一个工作(job)。</p>
</blockquote>
</li>
</ol>
<p>参考 <a href="http://blog.sina.com.cn/s/blog_673ee2b50100iywr.html">Unix或Linux中&amp;、jobs、fg、bg等命令的使用方法</a></p>
<ul>
<li>ctrl-C：(kill foreground process) 发送 SIGINT 信号给<strong>前台</strong>进程，强制终止程序的执行；</li>
<li>ctrl-Z：(suspend foreground process) 发送 SIGTSTP 信号给<strong>前台</strong>进程，将正在前台执行的进程放到后台，并且暂停。</li>
<li>fg：将后台中的进程调至前台继续运行，此时可以使用 ctrl-z 再次挂起该进程。注意区分后台命令序号和 pid</li>
<li>bg：将一个后台暂停的进程继续执行，此时将无法使用 ctrl-z 再次挂起该进程</li>
<li>&amp;：command&amp; 让进程在后台运行</li>
<li>jobs：查看后台运行的进程（挂起的 + 正在运行的）/列出当前shell环境中已启动的任务</li>
</ul>
<h2 id="关闭终端（未整理）"><a href="#关闭终端（未整理）" class="headerlink" title="关闭终端（未整理）"></a>关闭终端（未整理）</h2><ul>
<li>nohup</li>
</ul>
<p>关闭终端本质是退出账户？是会话结束？</p>
<p>阅读 <a href="http://www.cnblogs.com/allenblogs/archive/2011/05/19/2051136.html">linux的nohup命令的用法</a> </p>
<p>延伸阅读：</p>
<ol>
<li><p><a href="https://yq.aliyun.com/articles/8874">linux会话浅析</a>，对整体的理解很有帮助</p>
<p> 相比于普通的读写，终端还实现了很多可以通过ioctl系统调用进行配置的功能。包括（1）功能键；（2）终端控制输入输出的流向；（3）等等</p>
<blockquote>
<p>输入输出流向控制，只有前台进程组能够从终端中读数据、而不管前台后台程序都能向终端写数据。这点也是必须的，跟用户进程交互的是前台进程，用户的输入当然不能被其他后台进程抢走。但是一个进程是前台还是后台，是它自己是所不知道的，没法靠进程自己来判断什么时候可以读终端、什么时候不能读。所以需要终端来提供支持，如果后台进程读这个终端，终端的驱动程序将向其发送SIGTTIN信号，从而将其挂起。直到shell将其重新置为前台进程时（通过fg命令），该进程才会继续执行；</p>
<p>终端提供的这些功能未必都会被打开它的程序使用到。而像shell这样为人机交互而生的程序，则注定会跟终端打交道。</p>
</blockquote>
<p> 前台、后台概念是 Shell 的，也是由其控制的。（niel-）</p>
<hr>
<blockquote>
<p>Session leader进程的退出，将导致它所连接的终端被hangup，这意味着会话结束。反过来，像ssh这样的远程连接也可以通过断开连接的方式来使终端hangup，这将使得leader进程收到SIGHUP信号而退出。</p>
<p>具体来说，当终端hangup时，内核会有如下两个动作：</p>
<p>1、向对应会话的leader进程发送SIGHUP信号。而一般来说，会话的leader进程很可能是一个shell，它在收到SIGHUP信号后，并不是马上退出，而是会向它所启动的子进程都各自发送一个SIGHUP信号，将它们都杀死，然后自己才退出。不过，如果是这个作为leader进程shell自己退出，而导致终端hangup的话，向其子进程发送SIGHUP信号的事情就不会发生了，因为shell退出在先，它再也不会收到SIGHUP信号；<br>2、修改所有打开该终端的文件句柄，改成一个不可读不可写的实现；</p>
</blockquote>
<hr>
</li>
<li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/">让进程在后台可靠运行的几种方法</a></p>
<p> 方法好几种。目前能够熟练运用其中的 nohup 即可。</p>
</li>
<li><p><a href="http://www.robin.net.cn/475.html">Linux终端类型介绍</a>，有关的帖子差不多都是这些内容，看来看去头脑中对于“终端”这个概念还是浆糊</p>
</li>
</ol>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>关于 Vim 的操作及配置，见另一篇笔记 《Vim 操作及其配置.md》。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>cmake 备忘</title>
    <url>/2018/12/03/cmake/</url>
    <content><![CDATA[<p>automake 系列工具友好性的确不咋地，而且只限于 *inux 平台。跨平台还是 cmake 为佳，也有越来越多的项目在使用 cmake，比如 google 的 gRPC，比如 zlib 也支持 cmake。</p>
<p>如果只是说要编译三方库为自己所用，一般来说不需要掌握怎么编写 <code>CMakeLists.txt</code>；只有当自己的项目需要用 cmake 管理、组织编译时才需要弄懂 <code>CMakeLists.txt</code> 中的“语言”怎么编写。</p>
<h1 id="使用-cmake"><a href="#使用-cmake" class="headerlink" title="使用 cmake"></a>使用 cmake</h1><pre><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target install</code></pre>
<p><code>cmake --build .</code> 在 linux 下等价于 <code>make</code>，在 windows 下等同于 msvc 生成解决方案 </p>
<a id="more"></a>

<h2 id="外部编译"><a href="#外部编译" class="headerlink" title="外部编译"></a>外部编译</h2><pre><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake ..</code></pre>
<blockquote>
<p>就是让源码文件和 cmake 生成的工程文件分开，将 cmake 生成的工程文件放在一个单独的目录下面。</p>
</blockquote>
<p>坚持使用 build 目录，进行外部编译。以避免在源码目录中混杂垃圾文件。</p>
<h2 id="生成器-generator-G"><a href="#生成器-generator-G" class="headerlink" title="生成器 generator -G"></a>生成器 generator <code>-G</code></h2><pre><code>cmake -G &quot;&lt;generator&gt;&quot; -DCMAKE_INSTALL_PREFIX=stage ..</code></pre>
<p><a href="https://cmake.org/cmake/help/v3.13/manual/cmake-generators.7.html">cmake-generators 文档</a> 描述</p>
<h3 id="Command-Line-Build-Tool-Generators"><a href="#Command-Line-Build-Tool-Generators" class="headerlink" title="Command-Line Build Tool Generators"></a>Command-Line Build Tool Generators</h3><p>……</p>
<h3 id="IDE-Build-Tool-Generators"><a href="#IDE-Build-Tool-Generators" class="headerlink" title="IDE Build Tool Generators"></a>IDE Build Tool Generators</h3><p>These generators support Integrated Development Environment (IDE) project files. Since <strong>the IDEs configure their own environment</strong> one may launch CMake from any environment.</p>
<h4 id="Visual-Studio-Generators"><a href="#Visual-Studio-Generators" class="headerlink" title="Visual Studio Generators"></a>Visual Studio Generators</h4><ul>
<li>……</li>
<li>Visual Studio 12 2013</li>
<li><a href="https://cmake.org/cmake/help/v3.13/generator/Visual%20Studio%2014%202015.html">Visual Studio 14 2015</a></li>
<li><a href="https://cmake.org/cmake/help/v3.13/generator/Visual%20Studio%2015%202017.html">Visual Studio 15 2017</a></li>
</ul>
<blockquote>
<p>VS 2017 supports <strong>multiple installations</strong> on the same machine. The <code>CMAKE_GENERATOR_INSTANCE</code> variable may be set as a cache entry containing the absolute path to a Visual Studio instance. If the value is not specified explicitly by the user or a toolchain file, CMake queries the Visual Studio Installer to locate VS instances, chooses one, and sets the variable as a cache entry to hold the value persistently.</p>
</blockquote>
<h5 id="Platform-Selection-A"><a href="#Platform-Selection-A" class="headerlink" title="Platform Selection -A"></a>Platform Selection <code>-A</code></h5><p>The <code>CMAKE_GENERATOR_PLATFORM</code> variable may be set, perhaps via the cmake(1) <code>-A</code> option, to specify a target platform name (architecture)<sup>1</sup>. For example:</p>
<ul>
<li><code>cmake -G &quot;Visual Studio 14 2015&quot; -A Win32</code> / <code>cmake -G &quot;Visual Studio 15 2017&quot; -A Win32</code></li>
<li><code>cmake -G &quot;Visual Studio 14 2015&quot; -A x64</code> / <code>cmake -G &quot;Visual Studio 15 2017&quot; -A x64</code></li>
<li><code>cmake -G &quot;Visual Studio 14 2015&quot; -A ARM</code> / <code>cmake -G &quot;Visual Studio 15 2017&quot; -A ARM</code></li>
<li><code>cmake -G &quot;Visual Studio 15 2017&quot; -A ARM64</code></li>
</ul>
<p>For compatibility with CMake versions prior to 3.1, one may specify a target platform name optionally at the end of the generator name. This is supported only for:</p>
<ul>
<li><code>Visual Studio 14 2015 Win64</code> / <code>Visual Studio 15 2017 Win64</code>, Specify target platform <code>x64</code>.</li>
<li><code>Visual Studio 14 2015 ARM</code> / <code>Visual Studio 15 2017 ARM</code>, Specify target platform <code>ARM</code>.</li>
</ul>
<p><em>sup 1</em>：<a href="https://docs.microsoft.com/en-us/cpp/supported-platforms-visual-cpp?view=vs-2017">Supported Platforms (Visual C++)</a></p>
<h5 id="Toolset-Selection-T"><a href="#Toolset-Selection-T" class="headerlink" title="Toolset Selection -T"></a>Toolset Selection <code>-T</code></h5><p>The <code>v140</code> toolset that comes with <strong>Visual Studio 14 2015</strong> is selected by default. The <code>CMAKE_GENERATOR_TOOLSET</code> option may be set, perhaps via the cmake(1) <code>-T</code> option, to specify another toolset.</p>
<blockquote>
<p>The <code>v141</code> toolset that comes with <strong>Visual Studio 15 2017</strong> is selected by default.</p>
</blockquote>
<p>For each toolset that comes with this version of Visual Studio, there are variants that are themselves compiled for 32-bit (x86) and 64-bit (x64) hosts (independent of the architecture they target). By default Visual Studio chooses the 32-bit variant even on a 64-bit host. One may request use of the 64-bit host tools by adding a <code>host=x64</code> option to the toolset specification. See the <code>CMAKE_GENERATOR_TOOLSET</code> variable for details.</p>
<p><strong>针对 MSVC 总结</strong>：三种或四种平台，桌面开发主要针对 win32 和 x64；工具集基本对应 MSVC 版本，高版本 MSVC 可选择低版本的工具集；另外，还有个平台版本（即 SDK version），似乎在 cmake 中并不重要。</p>
<blockquote>
<p>安装各版本的平台工具集：VS2010 之后版本的 VS 都有这个功能, 可以通过切换平台工具集, 在使用最新的 IDE 的同时, 用旧版本来进行编译, 彻底杜绝兼容问题<sup>2</sup>。<a href="https://junkboy.gitee.io/posts/2018/06/05/MSVC-VER.html">摘自</a></p>
</blockquote>
<p><em>sup 2</em>: MSVC 各版本之间的兼容问题是个老梗了，ε=(´ο｀*)))唉，不过 <a href="https://blogs.msdn.microsoft.com/vcblog/2017/03/07/binary-compatibility-and-pain-free-upgrade-why-moving-to-visual-studio-2017-is-almost-too-easy/"> v141 is binary compatible with v140</a></p>
<h3 id="Extra-Generators"><a href="#Extra-Generators" class="headerlink" title="Extra Generators"></a>Extra Generators</h3><p>……</p>
<h2 id="增删变量-D"><a href="#增删变量-D" class="headerlink" title="增删变量 -D"></a>增删变量 <code>-D</code></h2><p><code>-D&lt;var&gt;:&lt;type&gt;=&lt;value&gt;</code> 添加变量及值到 CMakeCache.txt 中。注意 <code>-D</code> 后面不能有空格，type 为 string 时可省略。例如：<code>cmake -DCMAKE_BUILD_TYPE:STRING=Debug</code>。MinGW Generator 默认生成 <code>CMAKE_BUILD_TYPE</code> 为空，即 release；NMake Generator默认生成 <code>CMAKE_BUILD_TYPE</code> 为 Debug。</p>
<p><code>-U&lt;globbing_expr&gt;</code> 删除 CMakeCache.txt 中的变量。注意 <code>-U</code> 后面不能有空格,支持 globbing 表达式，比如 <code>*,?</code> 等。例如：<code>cmake -UCMAKE_BUILD_TYPE</code>。</p>
<h3 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;Visual Studio 14 2015&quot;</span> <span class="literal">-DCMAKE_INSTALL_PREFIX</span>=<span class="string">&quot;install_root&quot;</span> <span class="comment"># -DCMAKE_BUILD_TYPE=&quot;Release&quot;</span></span><br><span class="line">cmake -<span class="literal">-build</span> . -<span class="literal">-target</span> install -<span class="literal">-config</span> Release</span><br></pre></td></tr></table></figure>
<p>如果前一条命令不指定 <code>-DCMAKE_BUILD_TYPE=&quot;Release&quot;</code>，只是单独在第二条命令中 <code>--config=Release</code>，会造成什么后果？无任何后果。当使用 MSVC 时，<a href="https://stackoverflow.com/questions/24460486/cmake-build-type-not-being-used-in-cmakelists-txt"><code>CMAKE_BUILD_TYPE</code> 选项被忽略</a>。</p>
<blockquote>
<p>Specifies the build type on <strong>single</strong>-configuration generators. <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html"><code>CMAKE_BUILD_TYPE</code> 的意义</a></p>
<p>This variable is only meaningful to single-configuration generators <del>(such as Makefile Generators and Ninja) i.e. those which choose a single configuration when CMake runs to generate a build tree</del> as opposed to multi-configuration generators <del>which offer selection of the build configuration within the generated build environment</del>.</p>
</blockquote>
<h3 id="调试版本后缀"><a href="#调试版本后缀" class="headerlink" title="调试版本后缀"></a>调试版本后缀</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">-DCMAKE_DEBUG_POSTFIX=<span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="comment"># -DCMAKE_RELEASE_POSTFIX=xx</span></span><br></pre></td></tr></table></figure>
<h3 id="MT-和-MD"><a href="#MT-和-MD" class="headerlink" title="MT 和 MD"></a>MT 和 MD</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 追加 `CMAKE_CXX_FLAGS_Build Type`</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; /MT&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; /MTd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 替换 `CMAKE_CXX_FLAGS_Build`</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;/MT&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;/MTd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 或者将已经存在的 `/MD、/MDd` 替换为 `/MT、/MTd`</span></span><br><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="keyword">set</span>(CompilerFlags</span><br><span class="line">        CMAKE_CXX_FLAGS</span><br><span class="line">        CMAKE_CXX_FLAGS_DEBUG</span><br><span class="line">        CMAKE_CXX_FLAGS_RELEASE</span><br><span class="line">        CMAKE_C_FLAGS</span><br><span class="line">        CMAKE_C_FLAGS_DEBUG</span><br><span class="line">        CMAKE_C_FLAGS_RELEASE</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">foreach</span>(CompilerFlag <span class="variable">$&#123;CompilerFlags&#125;</span>)</span><br><span class="line">        <span class="keyword">string</span>(REPLACE <span class="string">&quot;/MD&quot;</span> <span class="string">&quot;/MT&quot;</span> <span class="variable">$&#123;CompilerFlag&#125;</span> <span class="string">&quot;$&#123;$&#123;CompilerFlag&#125;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endif</span>(MSVC)</span><br></pre></td></tr></table></figure>
<p>摘自：<a href="https://blog.csdn.net/frank_liuxing/article/details/74010939">https://blog.csdn.net/frank_liuxing/article/details/74010939</a> </p>
<p>原文描述提到“<del>如果CMAKE Flags已经设置了<code>/MD</code>，可以不能发挥作用。可以采用方法2</del>” 但很可能是错误的，后者覆盖前者：</p>
<blockquote>
<p>If your CMake flags already contain <code>/MD</code>, you can ensure that the above commands are executed after the point at which <code>/MD</code> is inserted (the later addition of <code>/MT</code> <strong>overrides</strong> the conflicting existing option) <a href="https://stackoverflow.com/questions/14172856/cmake-compile-with-mt-instead-of-md">来自 stackoverflow</a></p>
</blockquote>
<h3 id="安装路径"><a href="#安装路径" class="headerlink" title="安装路径"></a>安装路径</h3><pre><code>-DCMAKE_INSTALL_PREFIX</code></pre>
<h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><h2 id="清理之后重新构建、编译"><a href="#清理之后重新构建、编译" class="headerlink" title="清理之后重新构建、编译"></a>清理之后重新构建、编译</h2><p>当出现 xx 等无法理解的问题时（尤其是在同一目录下同时编译 Debug 和 Release 版本时出现依赖库异常时），尝试删除 cmake 临时文件（<code>CMakeCache.txt</code> <code>CMakeFiles\</code> 等）所在目录，再次执行试试</p>
<h2 id="cmake-gui"><a href="#cmake-gui" class="headerlink" title="cmake-gui"></a>cmake-gui</h2><h1 id="编写-CMakeLists-txt"><a href="#编写-CMakeLists-txt" class="headerlink" title="编写 CMakeLists.txt"></a>编写 CMakeLists.txt</h1>]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 的重大改变</title>
    <url>/2016/11/03/cpp11BigChanges/</url>
    <content><![CDATA[<p><a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/">The Biggest Changes in C++11 (and Why You Should Care)</a>，译文：<a href="http://www.devbean.net/2012/11/biggest-changes-in-c11/">C++11 的重大改变</a></p>
<p>事实上，核心 C++11 已经有了很大的改变。C++11 标准库同样增加了新的内容。捎带一句，<a href="http://stackoverflow.com/questions/9538701/what-is-the-difference-between-c0x-and-c11">C++11, also formerly known as C++0x …</a></p>
<h1 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h1><blockquote>
<p>事实上，核心 C++11 已经有了很大的改变。现在它支持 lambda 表达式，自动类型推断，统一的初始化语法，委托构造函数，已删除和默认函数声明，nullptr，以及最重要的，右值引用——一种预言将会改变创造和处理对象方法的技术。</p>
</blockquote>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20125256">Lambda 表达式有何用处？如何使用？ - KE meng 的回答</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/zh-cn/library/dd293608.aspx">C++ 中的 Lambda 表达式</a></p>
</li>
<li><p>查看 C++ Primer 有关章节，讲解的很详细的。</p>
<ul>
<li>lambda 的函数调用运算符为 const-by-value，但对 <code>mutable</code> 关键字的使用可将其取消</li>
</ul>
</li>
</ul>
<h2 id="自动类型推断和-decltype"><a href="#自动类型推断和-decltype" class="headerlink" title="自动类型推断和 decltype"></a>自动类型推断和 decltype</h2><p>赋予 <code>auto</code> 关键词新生： <a href="http://www.cppblog.com/amazon/archive/2009/12/09/102847.html">数据存储类型</a></p>
<p><code>auto</code> 自动推导类型，轻度用户（不涉及模板）谨慎使用，在书写便利和代码易读两者之间寻求，滥用降低代码可读性。</p>
<p>注意使用的限制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> diff = <span class="number">0</span> - length;</span><br><span class="line"><span class="keyword">auto</span> diff2 = <span class="number">0</span> - length;</span><br><span class="line"><span class="comment">// diff != diff2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">0</span> - length) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// NOTE 并未像我们预期的那这样子输出 -10</span></span><br></pre></td></tr></table></figure>
<h2 id="统一初始化语法"><a href="#统一初始化语法" class="headerlink" title="统一初始化语法"></a>统一初始化语法</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">POD (程序设计) - wikipedia</a></p>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/C%2B%2B%E7%B1%BB">C++类 - wikipedia</a>，其中提到了“聚合类”和“POD”结构。值得抽时间全部看看</p>
</li>
<li><p><a href="http://www.cnblogs.com/tingshuo/archive/2013/03/25/2981197.html">怎样理解 C++ 中的 Aggregate 和 POD 类型</a>，这是译文—<a href="http://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">An answer from stackoverflow</a>，这是原文。强调理论。<del>建议查看原文，其中 “What changes for C++11?” 一节在 cnblog 中并未出现，而关于 POD 的定义，C++03 标准和 C++11 并不相同。</del> 这是后半部分,<a href="http://www.cnblogs.com/tingshuo/archive/2013/03/28/2986236.html">怎样理解C++ 11中的trivial和standard-layout</a></p>
<blockquote>
<p>新标准中已经很少使用POD这个术语了，而是更多的在使用更精确的概念：trival和stand-layout。</p>
</blockquote>
</li>
<li><p><a href="http://blog.csdn.net/aqtata/article/details/35618709">【C++11】POD 数据类型</a>，只放定义和代码，看不懂。强调实用性。</p>
<p>看了以上几篇帖子之后，知道了几个名词：Aggregate 和 POD，trivial 和 standard-layout。但详细的概念很是混乱，其中一条条的“是与不是”、“有与没有”难道是让人用来背诵记忆的吗？实用主义不要求学究钻研，编码过程用到了再回来复习。目前，水过不学了。其实真要较真的话，应该直接去找 C++ 的新标准，网上的终究是个参考，会有出入。</p>
</li>
</ul>
</li>
<li><p>列表初始化，见 wiz 中另一篇笔记《初始化.md》</p>
<blockquote>
<p>初始化操作的多种变体是令人感觉困扰的重要原因之一。C++11 使用统一的大括号标记清除了这种混乱。</p>
</blockquote>
</li>
</ul>
<h2 id="删除和默认函数"><a href="#删除和默认函数" class="headerlink" title="删除和默认函数"></a>删除和默认函数</h2><ul>
<li>多看书，多写代码</li>
</ul>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><ul>
<li><p>在此之前是什么样子？会有什么问题？深度探索一下。</p>
</li>
<li><p><a href="http://szjoshua.farbox.com/post/c-11nullptr">c++11中的nullptr详解</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/22203461">NULL 和 0 - 蓝色的回答</a></p>
<ul>
<li>不推荐使用宏，甚至不承认宏。包括 <code>NULL</code>，C++标准是没有承认 <code>NULL</code> 是 null pointer constant的。</li>
<li>赋予 null pointer，应该是使用 <code>0</code>，而非 <code>NULL</code></li>
</ul>
</li>
</ul>
<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul>
<li>减少代码量？</li>
<li>委托构造函数<strong>在初始化列表中</strong>调用目标构造函数。我们把调用者称为委托构造函数，被调用者称为目标构造函数。</li>
<li><a href="https://wizardforcel.gitbooks.io/cpp-11-faq/content/10.html">委托构造函数（Delegating constructors）</a></li>
</ul>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul>
<li><p>区分“左值”和“右值”。引用自 <a href="https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用 - wikipedia</a></p>
<blockquote>
<p>在C++11提出右值引用之前，C++03及更早的C++标准中，表达式的“值分类”（<a href="https://zh.cppreference.com/w/cpp/language/value_category">value categories</a>）属性为左值或右值。左值是对应（refer to）内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。因而，右值可以是字面量、临时对象等表达式。能否被赋值不是区分C++左值与右值的依据。C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。左值与右值的根本区别在于<strong>是否允许取地址&amp;运算符获得对应的内存地址</strong>。</p>
</blockquote>
</li>
<li><p>移动语义？学习 C++ Prime</p>
<ul>
<li><p>移动构造函数、移动赋值运算符</p>
<blockquote>
<p>C++11 标准库大量使用了移动语义。许多算法和容器也为移动语义做了优化。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><a href="http://jxq.me/2012/06/06/%E8%AF%91%E8%AF%A6%E8%A7%A3c%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/#section_05">【译】详解C++右值引用</a>，阅读笔记如下</p>
<ol>
<li><p>概述中# &amp;foobar() 是取 foobar() 函数执行结果的地址，而不是函数指针，&amp;foobar 才是函数指针。</p>
</li>
<li><p>右值引用，总算渐渐明朗了。但前提是分清左值/右值。</p>
<p> const 常量是左值，还是右值呢？——左值，因为 <code>const int max = 100;</code> 中 max 是可以使用 <code>&amp;</code> 取地址的。</p>
</li>
<li><p>move语义# 中“当赋值操作符的右边是右值的时候，我们希望赋值操作符被定义成下面这样：”，醍醐灌顶啊</p>
<p> 此处的右值，在后续代码中可能会再次被用来给变量赋值吗？</p>
<blockquote>
<p>“move语义：当一个变量（a）作为拷贝构造函数或者赋值的来源时，这个变量要么就是以后都不会再使用，要么就是（使用时）作为赋值操作的目标（a = b）。”</p>
</blockquote>
<p> 也就是，这个变量不能再用了。</p>
<p> ——参考 右值引用是右值吗？#</p>
<blockquote>
<p>“move语义的重点在于将其应用于那些不重要的东西上面，那些move之后会马上销毁而不会被再次用到的东西上面。”</p>
</blockquote>
</li>
<li><p>强制move语义# 中：</p>
<blockquote>
<p>C++11中的swap函数是这样的:…</p>
</blockquote>
<p> swap函数不能只做 <code>a = std::move(b);</code> 吗？</p>
<blockquote>
<p>值得注意的是对那些没有实现move语义的类型来说（没有针对右值引用重载拷贝构造函数和赋值操作符），新的swap仍然和旧的一样。</p>
</blockquote>
<p> 可能只是为了兼容。参考 Debian8Light 代码验证。</p>
</li>
<li><p>右值引用是右值吗# 中读不懂：</p>
<blockquote>
<p>理论上来说goo()所引用的对象也可能在X x = goo();后被访问的到。但是回想一下，这种行为不正是我们想要的吗？我们也想随心所欲的在左值上面使用move语义。</p>
</blockquote>
</li>
<li><p>move语义与编译器优化# 暂时读不懂</p>
</li>
<li><p><strong>完美转发相关内容暂时未看，涉及范型编程之泛型函数</strong></p>
</li>
</ol>
</li>
<li><p><a href="http://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/">C++11 标准新特性: 右值引用与转移语义</a></p>
</li>
</ul>
<h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><blockquote>
<p>2003年，C++ 以库技术报告 1（TR1）的形式经历了一次大型重构。TR1 包含了新的容器类（unordered_set，unordered_map，unordered_multiset和unordered_multimap）和许多新的库，例如正则表达式，元组，函数对象包装器。随着 C++11 的颁布，TR1 连同新的库一起正式集成到 C++ 标准中。下面是 C++11 标准库的特性：</p>
</blockquote>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><blockquote>
<p>毫无疑问，从程序员角度看，C++11 最重要的改进就是并发。</p>
</blockquote>
<h2 id="新的智能指针类"><a href="#新的智能指针类" class="headerlink" title="新的智能指针类"></a>新的智能指针类</h2><blockquote>
<p>C++98 只定义了一个智能指针类，auto_ptr，而这个类现在已经被废弃了。C++11 包含了新的智能指针类：shared_ptr 和最近新加的 unique_ptr。</p>
</blockquote>
<h2 id="新的算法"><a href="#新的算法" class="headerlink" title="新的算法"></a>新的算法</h2><p>THE END</p>
<p>延伸阅读：</p>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/cpp-11-faq/content/88.html">C++11 FAQ中文版</a></li>
<li><a href="https://zh.wikipedia.org/wiki/C%2B%2B11">C++11 - wikipedia</a>，还是很值得一看的。</li>
<li><a href="http://coolshell.cn/articles/5265.html">C++11 中值得关注的几大变化（详解）</a></li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>当前工作目录是可以变化的</title>
    <url>/2017/03/07/current-working-directory/</url>
    <content><![CDATA[<p>2015年10月29日 10:15:57</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在做 mfc 项目的时候需要获取当前目录，当时直接调用了 <code>GetCurrentDirectory()</code> 使用。当时在 VS2010 中有三个项目，目录结构如下：</p>
<p><img src="https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/TrayOnly-Directory.jpg" alt="TrayOnly项目的目录结构"></p>
<a id="more"></a>

<p>TrayOnly.exe 会调用启动 BasicConf.exe，而 BasicConf.exe 负责读写配置文件”conf\sample.conf”。</p>
<ul>
<li>在 VS2010 中将 BasicConf.vcxproj 设置为启动项目进行调试时，此配置文件须在 BasicConf 文件夹下，即”BasicConf\conf\sample.conf”；</li>
<li>将 TrayOnly.vcxproj 设置为启动项目进行调试，通过 TrayOnly.exe 启动 BasicConf.exe 时，配置文件须在 TrayOnly 文件夹下，即”TrayOnly\conf\sample.conf”；</li>
<li>而在 Debug 目录中手动启动 BasicConf.exe 时，配置文件须在 Debug 文件夹下，即”Debug\conf\sample.conf”。</li>
</ul>
<p>这个就是一个凌乱的现象。</p>
<h2 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a>设置工作目录</h2><p>右击项目-属性页-调试-工作目录，默认 <code>$(ProjectDir)</code> = 当前项目的目录 = 当前项目 .vcxproj 文件的所在目录</p>
<p>关于 IDE 中更多预定义变量的意义：<a href="https://cloud.tencent.com/developer/news/465316">Visual Studio中相对路径中的宏定义</a></p>
<h1 id="工作目录和运行目录"><a href="#工作目录和运行目录" class="headerlink" title="工作目录和运行目录"></a>工作目录和运行目录</h1><p>工作目录，全称是当前工作目录(Current Working Directory)。一般来说，每个进程都有一个与之相关联的分级文件系统(hierarchical file system)下的目录，称之为该进程的当前工作目录。工作目录是一个环境变量，如果程序刚进入 <code>main</code> 入口处的时候，当前工作目录其实就是程序启动的目录，但是当前工作目录是可以通过程序进行设置或者随着 <code>OpenFileDialog</code>、<code>SaveFileDialog</code> 等对象所确定的目录而改变。所以使用的时候要小心。<strong>工作目录主要影响程序中使用到的相对路径</strong>，比如说  <code>file.open(../a.txt);</code>   这个 a.txt 文件的具体位置是根据工作目录来判断的。</p>
<p>运行目录，也称执行目录、应用程序所在目录。该进程从中启动的目录，即程序文件自身所在的目录，是固定不变的。</p>
<p>所以，当前工作目录和程序所在的目录可以不同。</p>
<p>参考 <a href="http://stackoverflow.com/questions/4419868/what-is-the-current-directory-in-a-batch-file">What is the current directory in a batch file?</a></p>
<blockquote>
<p>the current working directory (variable)</p>
<p>the full path to the batch file’s directory (static)</p>
</blockquote>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="获得当前工作目录："><a href="#获得当前工作目录：" class="headerlink" title="获得当前工作目录："></a>获得当前工作目录：</h2><p>获取当前工作目录 <code>GetCurrentDirectory</code></p>
<p>设置当前工作目录 <code>SetCurrentDirectory</code></p>
<p>C标准函数 <code>char * getcwd(char * buf, size_t size)</code>  获取当前工作目录绝对路径， 注意一点： <code>size</code> 要足够大！</p>
<h2 id="获得-exe可执行文件路径："><a href="#获得-exe可执行文件路径：" class="headerlink" title="获得.exe可执行文件路径："></a>获得.exe可执行文件路径：</h2><p>Windows获取程序全路径的接口是：<code>GetModuleFileName</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exe文件所在路径为：C:\Users\Debug\xxx.exe</span></span><br><span class="line"><span class="keyword">char</span> exeFullPath[MAX_PATH]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">GetModuleFileName(<span class="literal">NULL</span>,exeFullPath,MAX_PATH);<span class="comment">//得到程序模块.exe全路径</span></span><br><span class="line"><span class="comment">//接下来把xxx.exe文件名去掉，有以下四种：</span></span><br><span class="line">*<span class="built_in">strrchr</span>( exeFullPath, <span class="string">&#x27;\\&#x27;</span>) = <span class="number">0</span>;              <span class="comment">//得到C:\Users\Debug</span></span><br><span class="line"><span class="built_in">strrchr</span>( exeFullPath, <span class="string">&#x27;\\&#x27;</span>)[<span class="number">0</span>]= <span class="number">0</span>;             <span class="comment">//也是得到C:\Users\Debug</span></span><br><span class="line">*(<span class="built_in">strrchr</span>( exeFullPath, <span class="string">&#x27;\\&#x27;</span>)+<span class="number">1</span>) = <span class="number">0</span>;          <span class="comment">//得到C:\UsersDebug\</span></span><br><span class="line"><span class="built_in">strrchr</span>( exeFullPath, <span class="string">&#x27;\\&#x27;</span>)[<span class="number">1</span>]= <span class="number">0</span>;             <span class="comment">//也是得到C:\Users\Debug\</span></span><br></pre></td></tr></table></figure>
<p>C Run-Time 库获取程序全路径接口是：<code>_get_tpgmptr</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;stdlib.h&gt;    ////如果是C++代码，用cst**；如果是写C 请用st**.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    _get_pgmptr(&amp;p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考自：<a href="http://blog.csdn.net/yongqiangyue/article/details/7707854">运行的应用程序的当前工作目录和所在的目录的区别</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>调试阿里云 CDN  同步延迟</title>
    <url>/2019/11/04/debugCDN/</url>
    <content><![CDATA[<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>cdn 节点和源上相同文件的 etag 或 lm 是相同的。</p>
<h1 id="http-header-response"><a href="#http-header-response" class="headerlink" title="http header response"></a>http header response</h1><p><a href="https://kb.cnblogs.com/page/92320/">https://kb.cnblogs.com/page/92320/</a></p>
<p>2019/7/23 14:00:43 请求源 101.200.199.142 cdnapp.ydtg.com.cn</p>
<p>Date    原始服务器消息发出的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 23 Jul 2019 06:00:42 GMT</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 1200940</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 00:58:00 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5d365b98-12532c&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>2019/7/23 14:10:43 请求 61.240.154.102 cdnapp.ydtg.com.cn</p>
<p>Age    从原始服务器到代理缓存形成的估算时间（以秒计，非负）    // 大致为当前时间 - Date</p>
<p><a href="http://www.webym.net/jiaocheng/1007.html">http://www.webym.net/jiaocheng/1007.html</a> Age 的描述错误</p>
<p>X-Swift-SaveTime 代表开始在cdn上缓存的时间        // 验证是否与 Date 相等：<del>在 X-Cache: HIT TCP_MEM_HIT 或 X-Cache: MISS TCP_REFRESH_MISS 时相同</del><br>X-Swift-CacheTime 是cdn默认缓存时间，以秒为单位，过了这个时间该缓存就失效了     //30分钟左右？</p>
<p><a href="http://www.sosoba.org/thread-271841-1-1.html?mod=viewthread&amp;tid=271841&amp;extra=page%253D1&amp;page=1">http://www.sosoba.org/thread-271841-1-1.html?mod=viewthread&amp;tid=271841&amp;extra=page%253D1&amp;page=1</a></p>
<p>X-Cache 命中字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 1200940</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 05:52:14 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 00:58:00 GMT</span><br><span class="line">ETag: &quot;5d365b98-12532c&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Ali-Swift-Global-Savetime: 1563861134</span><br><span class="line">Via: cache36.l2cn1818[23,200-0,M], cache14.l2cn1818[39,0], kunlun7.cn1481[0,200-0,H], kunlun7.cn1481[1,0]</span><br><span class="line">Age: 1080</span><br><span class="line">X-Cache: HIT TCP_MEM_HIT dirn:-2:-2</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 05:52:14 GMT</span><br><span class="line">X-Swift-CacheTime: 1765</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 3df09a1b15638622147584175e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2019/7/23 14:25:49 请求 27.221.30.10 cdnapp.ydtg.com.cn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 1200940</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 06:25:24 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 00:58:00 GMT</span><br><span class="line">ETag: &quot;5d365b98-12532c&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Ali-Swift-Global-Savetime: 1563861134</span><br><span class="line">Via: cache36.l2cn1818[24,200-0,H], cache25.l2cn1818[37,0], kunlun9.cn345[84,200-0,M], kunlun9.cn345[99,0]</span><br><span class="line">Age: 0</span><br><span class="line">X-Cache: MISS TCP_REFRESH_MISS dirn:2:14047659</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 06:25:24 GMT</span><br><span class="line">X-Swift-CacheTime: 1964</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 1bdd1e1d15638631240594521e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==================================</p>
<p>27.221.30.10 cdnapp.ydtg.com.cn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 06:28:19 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 02:28:58 GMT</span><br><span class="line">ETag: &quot;5d3670ea-7&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Ali-Swift-Global-Savetime: 1563848991</span><br><span class="line">Via: cache17.l2cn1818[25,200-0,H], cache13.l2cn1818[26,0], kunlun9.cn345[72,200-0,M], kunlun10.cn345[74,0]</span><br><span class="line">Age: 0</span><br><span class="line">X-Cache: MISS TCP_REFRESH_MISS dirn:0:44785189</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 06:28:19 GMT</span><br><span class="line">X-Swift-CacheTime: 1436</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 1bdd1e1e15638632998093847e</span><br></pre></td></tr></table></figure>
<p>101.200.199.142 cdnapp.ydtg.com.cn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 23 Jul 2019 06:31:02 GMT</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 7</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 02:28:58 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5d3670ea-7&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>61.240.154.102 cdnapp.ydtg.com.cn</p>
<p><del>当 X-Cache: HIT TCP_REFRESH_HIT 时，Date 和 X-Swift-SaveTime 不再相同</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 06:28:19 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 02:28:58 GMT</span><br><span class="line">ETag: &quot;5d3670ea-7&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Via: cache17.l2cn1818[0,304-0,H], cache23.l2cn1818[1,0], kunlun10.cn1481[33,200-0,H], kunlun10.cn1481[42,0]</span><br><span class="line">Ali-Swift-Global-Savetime: 1563848991</span><br><span class="line">Age: 379</span><br><span class="line">X-Cache: HIT TCP_REFRESH_HIT dirn:5:50364804</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 06:34:38 GMT</span><br><span class="line">X-Swift-CacheTime: 1474</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 3df09a1e15638636786971064e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2019/7/23 14:43:27 61.240.154.102 cdnapp.ydtg.com.cn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 06:28:19 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 02:28:58 GMT</span><br><span class="line">ETag: &quot;5d3670ea-7&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Via: cache17.l2cn1818[0,304-0,H], cache23.l2cn1818[1,0], kunlun10.cn1481[0,200-0,H], kunlun9.cn1481[1,0]</span><br><span class="line">Ali-Swift-Global-Savetime: 1563848991</span><br><span class="line">Age: 892</span><br><span class="line">X-Cache: HIT TCP_MEM_HIT dirn:5:50364804</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 06:34:38 GMT</span><br><span class="line">X-Swift-CacheTime: 1474</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 3df09a1d15638641915385880e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2019/7/23 15:10:58 61.240.154.102 cdnapp.ydtg.com.cn</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line">Content-Length: 7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Jul 2019 07:10:42 GMT</span><br><span class="line">Last-Modified: Tue, 23 Jul 2019 02:28:58 GMT</span><br><span class="line">ETag: &quot;5d3670ea-7&quot;</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Via: cache9.l2cn354[25,304-0,H], cache3.l2cn354[25,0], kunlun10.cn1481[107,200-0,H], kunlun8.cn1481[108,0]</span><br><span class="line">Ali-Swift-Global-Savetime: 1563848991</span><br><span class="line">Age: 0</span><br><span class="line">X-Cache: HIT TCP_REFRESH_HIT dirn:5:50364804</span><br><span class="line">X-Swift-SaveTime: Tue, 23 Jul 2019 07:10:42 GMT</span><br><span class="line">X-Swift-CacheTime: 1690</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 3df09a1c15638658425441368e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2019/7/23 15:12:47 </p>
]]></content>
  </entry>
  <entry>
    <title>devcpp 5.1.1 在 win8.1 x64 系统上</title>
    <url>/2017/04/18/devcpp/</url>
    <content><![CDATA[<ol>
<li><p>编译器 TDM-GCC 4.9.2 64-bit Release/Debug，可能对 64 位处理的不是很好，经常报 gdb.exe 崩溃。因此<strong>建议不使用用 64 位的编译配置</strong>，包括 Release、Debug；</p>
</li>
<li><p>使用 TDM-GCC 4.9.2 32-bit Release/Debug，报错缺失 zlib1.dll 文件，这一点可能是 32 位编译器对 64 位系统的兼容性有限，参考 <a href="http://zhidao.baidu.com/link?url=sAumyFo8EBxFxrMFy-fcFq5y4HL92atlVjqPRe2Vj7xB2auGH_pSD9XeublFo9V6og0kGkHwd13Dl0wFm8wg8RAZTUZJRX5Z5_vUj_XgTOm">计算机中丢失 ZLIB1.DLL</a> 去网上下载 dll 文件拷贝到相应目录即可。然后就可以正常使用 devcpp 了。</p>
</li>
<li><p>打开 devcpp，将编译器选择 TDM-GCC 4.9.2 32-bit Debug ，每次重启之后报错：</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/devcpp/devcpp1.png" alt="报错内容"></p>
<p> 解决方法：在 mingw64 创建一个 lib32 文件夹就可以了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>在 Windows 下开发 C++ 程序</title>
    <url>/2019/11/04/develop-cpp-windows/</url>
    <content><![CDATA[<p>如题，在此做一份备忘，记录在 Windows 下进行 C++ 开发用到的工具、插件及其意义。</p>
<p>当然多少会涉及到如何安装、配置这些工具，但不会多做介绍。</p>
<ol>
<li>Visual Studio，越新越好，但都有历史包袱</li>
<li><del>Visual AssistX</del> 破解费时费力，还有兼容问题。非重度用户，可探索 visual studio IDE 自身</li>
<li><a href="https://tnie.github.io/2018/12/10/vcpkg/">vcpkg 包管理器</a></li>
<li>spdlog 通过 vcpkg 安装</li>
<li>vld, <a href="https://kinddragon.github.io/vld/">Visual Leak Detector</a></li>
<li>不使用制表符，转换为 4 个空格。配置 IDE 实现。</li>
</ol>
<p>Visual Studio2015 IDE 中需要安装的插件（vc2017 中可能已经内嵌了某些插件的功能）</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=MadsKristensen.TrailingWhitespaceVisualizer">Trailing Whitespace Visualizer</a></li>
<li><a href="https://github.com/tcbhat/cpptripleslash">cpptripleslash</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.ProductivityPowerTools2015">Productivity Power Tools 2015</a></li>
</ul>
<a id="more"></a>

<h1 id="如何用好"><a href="#如何用好" class="headerlink" title="如何用好"></a>如何用好</h1><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>在 visual studio 开发 c++ 程序时，编写代码的规范：</p>
<ul>
<li>文件编码在 utf-8 和 utf-8-bom 中二选一</li>
<li>回车统一使用 Unix(LF) 格式</li>
</ul>
<p>protoc.exe 生成的源文件是: 两个空格 + utf-8 + Unix(LF)</p>
<h2 id="“监视”窗口中的格式说明符"><a href="#“监视”窗口中的格式说明符" class="headerlink" title="“监视”窗口中的格式说明符"></a>“监视”窗口中的格式说明符</h2><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/format-specifiers-in-cpp?view=vs-2017">“监视”窗口中的格式说明符</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* a1 = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> b = <span class="string">u8&quot;你好&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="string">u&quot;你好&quot;</span>; <span class="comment">// char16_t*</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="string">U&quot;你好&quot;</span>; <span class="comment">// char32_t*</span></span><br><span class="line">    <span class="keyword">auto</span> e = <span class="number">68</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>a,sb</td>
<td>你好</td>
<td>char *</td>
</tr>
<tr>
<td>b,s8</td>
<td>你好</td>
<td>std::basic_string&lt;char,std::char_traits<char>,std::allocator<char>   &gt;</td>
</tr>
<tr>
<td>c,su</td>
<td>L”你好”</td>
<td>const char16_t *</td>
</tr>
<tr>
<td>d,s32</td>
<td>U”你好”</td>
<td>const char32_t *</td>
</tr>
<tr>
<td>e,c</td>
<td>68 ‘D’</td>
<td>int</td>
</tr>
<tr>
<td>a1,[15]</td>
<td>0x00aed14c “Hello, world\0\0\0”</td>
<td>char[15]</td>
</tr>
</tbody></table>
<h2 id="调试多线程应用程序"><a href="#调试多线程应用程序" class="headerlink" title="调试多线程应用程序"></a>调试多线程应用程序</h2><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/debug-multithreaded-applications-in-visual-studio?view=vs-2017">调试多线程应用程序</a></p>
<h2 id="预编译头"><a href="#预编译头" class="headerlink" title="预编译头"></a>预编译头</h2><p>优点就是加快编译速度，YDStockProject 每次编译让我崩溃：一方面源于头文件依赖的混乱；另一方面可能就是源于 JUCE、BOOST 等使用大量模板的头文件的编译。</p>
<p>学习过程中 get 的点</p>
<ul>
<li><p>源文件也可以创建预编译头。按需学习，暂时无用</p>
</li>
<li><p>每个源文件只能 <code>#include</code> 一个预编译头，但同一项目中不同源文件可以 <code>#include</code> 不同的预编译头</p>
</li>
<li><p>每个源文件可以<strong>单独</strong>配置是否使用预编译头。但是我在 gtest-all.cc gmock-all.cc 的设置老是不生效呢？</p>
</li>
<li><p>使用预编译头有好多限制：比如 <a href="https://docs.microsoft.com/en-us/cpp/build/creating-precompiled-header-files?view=vs-2019#source-file-consistency">宏失效等 </a></p>
<blockquote>
<p>When you specify the Use Precompiled Header File (<code>/Yu</code>) option, the compiler ignores all preprocessor directives (including pragmas) that appear in the source code that will be precompiled. </p>
</blockquote>
</li>
</ul>
<h1 id="避免踩坑"><a href="#避免踩坑" class="headerlink" title="避免踩坑"></a>避免踩坑</h1><p>msvc 宇宙第一的 ide 都有哪些坑？</p>
<h2 id="不同版本的-stl-不兼容"><a href="#不同版本的-stl-不兼容" class="headerlink" title="不同版本的 stl 不兼容"></a>不同版本的 stl 不兼容</h2><p>谷歌喷 msvc 的 dll</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/picgo/43124169-e83ae890-8f58-11e8-9c66-726a09766f7d.png" alt="谷歌喷 msvc 的 dll"></p>
<h2 id="msvc2015-内嵌的-git-残废"><a href="#msvc2015-内嵌的-git-残废" class="headerlink" title="msvc2015 内嵌的 git 残废"></a>msvc2015 内嵌的 git 残废</h2><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/picgo/20201225152924.png"></p>
<p><a href="https://stackoverflow.com/questions/37818902/diff-between-commits-in-visual-studio-2015-using-git">https://stackoverflow.com/questions/37818902/diff-between-commits-in-visual-studio-2015-using-git</a></p>
<p><a href="https://blog.csdn.net/coolcooldool/article/details/53815939">https://blog.csdn.net/coolcooldool/article/details/53815939</a></p>
<p><a href="http://www.codewrecks.com/blog/index.php/2013/03/19/how-to-configure-diff-and-merge-tool-in-visual-studio-git-tools/">http://www.codewrecks.com/blog/index.php/2013/03/19/how-to-configure-diff-and-merge-tool-in-visual-studio-git-tools/</a></p>
<h2 id="编译模式与项目属性"><a href="#编译模式与项目属性" class="headerlink" title="编译模式与项目属性"></a>编译模式与项目属性</h2><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/picgo/20201225153054.png"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/picgo/20201225153121.png"></p>
<h2 id="node-js8-在-vs2017-中才支持"><a href="#node-js8-在-vs2017-中才支持" class="headerlink" title="node.js8 在 vs2017 中才支持"></a>node.js8 在 vs2017 中才支持</h2><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/picgo/20201225153203.png"></p>
<h2 id="msvc2015-用旧编译器的库报错“无法解析的外部符号”"><a href="#msvc2015-用旧编译器的库报错“无法解析的外部符号”" class="headerlink" title="msvc2015 用旧编译器的库报错“无法解析的外部符号”"></a>msvc2015 用旧编译器的库报错“无法解析的外部符号”</h2><p><a href="https://blog.csdn.net/hutianyou123/article/details/76577827">https://blog.csdn.net/hutianyou123/article/details/76577827</a></p>
<p><a href="https://stackoverflow.com/a/32418900/6728820">https://stackoverflow.com/a/32418900/6728820</a></p>
<h2 id="不能自由选择-c-标准"><a href="#不能自由选择-c-标准" class="headerlink" title="不能自由选择 c++ 标准"></a>不能自由选择 c++ 标准</h2><h2 id="不能在动态库静态变量或全局变量的析构中-join-线程"><a href="#不能在动态库静态变量或全局变量的析构中-join-线程" class="headerlink" title="不能在动态库静态变量或全局变量的析构中 join() 线程"></a>不能在动态库静态变量或全局变量的析构中 join() 线程</h2><p><a href="https://github.com/tnie/TestDll/issues/15">https://github.com/tnie/TestDll/issues/15</a></p>
<h2 id="Windows-的-cmd-和-powershell-表现不一致"><a href="#Windows-的-cmd-和-powershell-表现不一致" class="headerlink" title="Windows 的 cmd 和 powershell 表现不一致"></a>Windows 的 cmd 和 powershell 表现不一致</h2><p>命令路径中存在空格，如何使用？ 注意 引号 <code>&quot;</code> 和 斜杠 <code>\</code> 的相对位置</p>
<table>
<thead>
<tr>
<th>command</th>
<th>cmd 执行结果</th>
<th>power shell 执行结果</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;C:\Program Files (x86)\MSBuild\14.0\Bin\MSBuild.exe&quot; calculator.sln</code></td>
<td>√</td>
<td>×</td>
<td>表达式或语句中包含意外的标记“calculator.sln”。</td>
</tr>
<tr>
<td><code>&quot;C:\Program Files (x86)\MSBuild\14.0\Bin\&quot;MSBuild.exe calculator.sln</code></td>
<td>√</td>
<td>×</td>
<td>表达式或语句中包含意外的标记“MSBuild.exe”。</td>
</tr>
<tr>
<td><code>&quot;C:\Program Files (x86)&quot;\MSBuild\14.0\Bin\MSBuild.exe calculator.sln</code></td>
<td>√</td>
<td>×</td>
<td>表达式或语句中包含意外的标记“\MSBuild\14.0\Bin\MSBuild.exe”。</td>
</tr>
<tr>
<td><code>&quot;C:\Program Files (x86)\&quot;MSBuild\14.0\Bin\MSBuild.exe calculator.sln</code></td>
<td>√</td>
<td>×</td>
<td>表达式或语句中包含意外的标记“MSBuild\14.0\Bin\MSBuild.exe”。</td>
</tr>
<tr>
<td><code>C:\&quot;Program Files (x86)&quot;\MSBuild\14.0\Bin\MSBuild.exe calculator.sln</code></td>
<td>×</td>
<td>√</td>
<td>MSBUILD : error MSB1008: 只能指定一个项目。</td>
</tr>
<tr>
<td><code>C:&quot;\Program Files (x86)&quot;\MSBuild\14.0\Bin\MSBuild.exe calculator.sln</code></td>
<td>√</td>
<td>√</td>
<td>/</td>
</tr>
</tbody></table>
<p>END</p>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>不值得读</title>
    <url>/2016/11/30/do-not-read/</url>
    <content><![CDATA[<p>以前写书的人都是高手。写专业书籍首先要求技术够牛，其次文笔也要可以。进入新世纪，什么杂七杂八、牛鬼蛇神都可以出版书了，市场上充斥着大量的垃圾，浪费纸张浪费木材不说，万一被市场、群众（被大众所选择的不一定是对的）欺骗买了这样的书你真是想死的心都有。也有一些书，处在尴尬的层次——（尤其是专业书籍）算不上佳作，匆匆一瞥也挑不出问题，可是当你真正深入阅读时慢慢发现细节惨不忍睹（尤其是计算机领域渣渣们为了名利职称等翻译国外著作）。</p>
<h1 id="别看《C-Primer-Plus》"><a href="#别看《C-Primer-Plus》" class="headerlink" title="别看《C++ Primer Plus》"></a>别看《C++ Primer Plus》</h1><p>这本书是带“光环”的。在国内一些博客网站上，程序员们对这本书的评价还是可以的，<a href="https://book.douban.com/subject/1319751/">豆瓣的评分</a>也蛮高的。所谓群众的选择！但我接触过之后，开始怀疑“给予这本书肯定评价的程序员难道都是渣渣吗？或者都是门外汉拿这本书入门，觉得学到东西了所以给予肯定？”。以下是以前的记录，可以得出结论：原作者的水平就值得怀疑，翻译之后不会比原作更好。<strong>英文原著、译文都不值得看！</strong></p>
<p>2016/2/17 9:52:41</p>
<p>因为网上关于《C++ Primer》的电纸书资源有限，好吧，只找到英文原版第五版的mobi格式，而恰巧搜索资源的时候找到了《Plus》第五版的中文资源，亚马逊官方的，排版也不错，所以就在kindle 上看了，当时是打算重点学习后面的章节：函数重载、类的设计与使用、继承、异常处理等。</p>
<p>到目前读了20%，因为前四章的内容都比较基础，所以并没有详细地一页页读过来，而是拣选不熟的知识点学习。但已经有点烦了，确实好些地方娓娓道来，让人豁然开朗（跟我水平低也有关），但更多的细节上的不注意让人慢慢地烦躁起来，从网上找到两篇评论，恰巧说到了我的感觉。无论如何，打算放弃了，而且我<strong>绝对不会推荐</strong>别人读这本书的。</p>
<ol>
<li><p><a href="http://book.douban.com/review/5472087/">关注 C++ Primer Plus（第 6 版）的同学，请留步</a></p>
</li>
<li><p><a href="http://www.amazon.cn/review/R2QJQH8LI1JADU/ref=cm_cr_dp_title?ie=UTF8&ASIN=B008A4XZRI&channel=detail-glance&nodeID=&store=books">小错误太多，很不负责任</a>，66/71 认为此评论有用。这足够说明问题了。</p>
</li>
<li><p>还看到一个犀利的评价：</p>
<p> <img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/cpp-primer-plus.png"></p>
</li>
</ol>
<p>甚至会怀疑，那些让我豁然开朗，觉得学到东西的文字叙述是否真的就是那么回事，作者没有诓我吧。</p>
<p>最后一根稻草，是指针这一块的。</p>
<p>4.7.1节 讲到声明和初始化指针，提到声明指针时，<code>*</code> 操作符两边的空格问题，本身说的就不清楚，再加上难以自圆其说 指针声明中 <code>*</code> 和 解引用 <code>*</code> 的区别，甚至在作者的描述中两者是一致的。<br>我完全被打败了，弄糊涂了。所以去翻《C++ Primer》，很清晰，一点就明。</p>
<p>更多的错误就不说了，算是跳读的，虽说到了20%的进度，但就实际阅读的可能不到5%，我标注了8个明显的上下文不一致错误、翻译错误，让人费解的地方。</p>
<p>所以，打算去啃《Primer》英文原版了。</p>
<h1 id="别看《C-Concurrency-in-Action》译作"><a href="#别看《C-Concurrency-in-Action》译作" class="headerlink" title="别看《C++ Concurrency in Action》译作"></a>别看《C++ Concurrency in Action》译作</h1><p><strong>原著是值得肯定的</strong>，是 C++ 领域少有的介绍并发编程、多线程的书。但 <a href="https://book.douban.com/review/7485014/">国内翻译的版本</a> 被喷的一无是处，不再多说。</p>
<p>另外，GitBook 上有一份陈晓伟翻译的 <a href="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details">《C++并发编程(中文版)》</a>，我起初抱着很大的期望去读的。目前（2016/7/14 10:07:18 ） 快读到第二章结尾了，发现其中也有好多不尽人意之处，甚至有些完全翻译错误，将读者带跑带偏。某句话末尾多出个词汇，文字输入时音正字错（“人为”写成“认为”）的现象更是频繁出现。读起来磕磕绊绊，最主要的还是担心译者水平，翻译错误——很明显的错误能够发现，然后去找原文矫正；可是意识不到就代表没有错误了吗？——肯定有，译者的英文水平其实挺一般的。</p>
<p>所以，打算去看英文原版了。好在作者用的都是日常词汇，读起来并不“卡”，只是会慢些而已。</p>
<p>追评：原著写得挺好的，真正地去读英文原版会发现也没想象中那么困难，已经向第 4 章迈进了。目前阅读进度缓慢甚至停滞，主要是因为阅读目的（并发入门）已经达到，后面的进阶内容在目前用不到，所以读书的动力就不大了。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>异常 std::exception</title>
    <url>/2020/12/25/exception/</url>
    <content><![CDATA[<p>查看 <a href="https://zh.cppreference.com/w/cpp/error/exception"><code>std::exception</code></a> 的定义，作为抽象类，其默认构造和拷贝构造都声明为 <code>noexcept</code>：</p>
<blockquote>
<p>因为不允许复制 <code>std::exception</code> 抛出异常，故当派生类（例如 <code>std::runtime_error</code> ）必须管理用户定义的诊断信息时，常将它实现为<strong>写时复制</strong>的字符串。</p>
</blockquote>
<ol>
<li>为什么 <code>std::exception</code> 拷贝构造不允许抛出异常？ vc2010</li>
</ol>
<p>查看 <a href="https://zh.cppreference.com/w/cpp/error/logic_error"><code>std::logic_error</code></a> 或 <code>std::runtime_error</code> 的定义：</p>
<blockquote>
<p>因为不容许复制 <code>std::logic_error</code> 抛出异常，通常将此消息在内部存储为分离分配的<strong>引用计数</strong>字符串。这也是构造函数不接收 <code>std::string&amp;&amp;</code> 参数的理由：无论如何它必须复制内容。</p>
</blockquote>
<ol>
<li>子类的构造函数是可能抛出 <code>std::bad_alloc</code> 异常的，为什么子类的拷贝构造不能抛出异常？</li>
<li><del>为什么抽象类提供了拷贝构造，而子类不提供呢</del>？使用了隐式声明的 <a href="https://zh.cppreference.com/w/cpp/language/copy_constructor">复制构造函数</a>。</li>
<li><del><code>std::bad_alloc</code> 提供了拷贝操作符，而 <code>std::logic_error</code> 或 <code>std::runtime_error</code> 不需要</del>？ 参考在 vc2015 中标准实现文件 vcruntime_exception.h 中 <code>std::exception</code> 既没有实现为抽象类，同时也提供了拷贝操作符，所以其子类使用了 <a href="https://zh.cppreference.com/w/cpp/language/copy_assignment">隐式声明的复制赋值运算符</a></li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>进一步理解 extern</title>
    <url>/2016/11/03/extern-static-const/</url>
    <content><![CDATA[<p>首先，要区分全局变量和局部变量。</p>
<h1 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h1><p>在 C 和 C++ 中，局部变量意义相同；全局变量略有出入。</p>
<p>在《C++ Primer》中很明确的表示：(p44)</p>
<blockquote>
<p>名字 <code>main</code> 定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有<strong>全局作用域</strong>。一旦声明之后，全局作用域内的名字在<strong>整个程序的范围内</strong>都可使用。</p>
</blockquote>
<p>在 <a href="http://c.biancheng.net/cpp/html/62.html">C语言中文网-C语言局部变量和全局变量</a> 中指出：</p>
<blockquote>
<p>在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域是<strong>整个源程序</strong>。</p>
</blockquote>
<a id="more"></a>

<p>这一点和 <a href="http://c.biancheng.net/cpp/html/1158.html">C语言中文网-C语言变量作用域和生存期</a> 中的描述是统一的：</p>
<blockquote>
<p><code>extern</code> (外部的)  这是在<em>函数外部定义</em>的变量的<em>缺省存储方式</em>。<code>extern</code> 变量的作用域是整个程序。</p>
</blockquote>
<p>但是，在 <a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">维基百科词条-全局变量</a> 中则有另一番表述：</p>
<blockquote>
<p>需要指出的是，C 语言不存在真正意义上的“全局变量”。被习惯性误称为“全局变量”的，一般是文件作用域对象。</p>
<p>文件作用域变量，作用域从声明开始一直到文件末尾。</p>
</blockquote>
<p>在实际的测试中（使用的 gcc 编译器），C 中的全局变量作用域为整个程序，而不是到文件末尾。因为会报错“重复定义”，但想来和 gcc/g++ 作为 C++ 编译器也是有关的。</p>
<p>然后，我们来区分声明和定义。</p>
<h1 id="变量声明和定义"><a href="#变量声明和定义" class="headerlink" title="变量声明和定义"></a>变量声明和定义</h1><p>在《C++ Primer》中指出：p41</p>
<blockquote>
<p>为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持<strong>分离式编译</strong>机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>如果将程序分为多个文件，则需要有在文件间共享代码的方法。</p>
<p>为了支持分离式编译，C++ 语言将声明和定义区分开来。<strong>声明（declaration）</strong>使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义（definition）</strong>负责创建与名字关联的实体。</p>
<p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是<em>除此之外</em>，定义还申请存储空间，<em>也可能</em>会为变量赋一个初始值。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字 <code>extern</code>，而且不要显示地初始化变量，任何包含了显示初始化的声明即成为定义。</p>
<p>变量能且只能被定义一次，但是可以被多次声明。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
</blockquote>
<p>在 <a href="http://c.biancheng.net/cpp/biancheng/view/143.html">C语言中文网-关于C++变量的声明和定义</a> 中描述如下：</p>
<blockquote>
<p>外部变量定义和外部变量声明的含义是不同的。外部变量的定义只能有一次，它的位置在所有函数之外，而同一文件中的外部变量的声明可以有多次，它的位置可以在函数之内，也可以在函数之外。</p>
<p>系统根据外部变量的定义分配存储单元。对外部变量的初始化只能在定义时进行，而不能在声明中进行。</p>
<p>所谓声明，其作用是向编译系统发出一个信息，声明该变量是一个在后面定义的外部变量，仅仅是为了提前引用该变量而作的声明。<code>extern</code> 只用作声明，而不用于定义。</p>
</blockquote>
<p>其中的讲解和“分离式编译”、“文件间共享代码”毫无关系，重在关联函数的声明/定义<strong>与</strong>变量的声明/定义，以函数的声明/定义来讲变量的声明/定义。比如</p>
<ul>
<li>如果未在 <code>fun2()</code> 之前定义 <code>fun1()</code>，则在 <code>fun2()</code> 中调用 <code>fun1()</code> 时必须先声明 <code>fun1()</code>，相似的，使用外部变量时若未定义，则必须先声明。</li>
<li>声明（函数声明/变量声明）一般放在头文件中，这样就可以在多个源文件间共享函数/变量。</li>
</ul>
<h1 id="extern-和-static"><a href="#extern-和-static" class="headerlink" title="extern 和 static"></a>extern 和 static</h1><p>至此，引出<code>extern</code>和<code>static</code>关键字。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>参考 <a href="http://developer.51cto.com/art/201104/256820.htm">浅谈C/C++中的static和extern关键字</a>，其中关于<code>extern</code>的讲解不够精细，关于<code>static</code>的足够。</p>
<blockquote>
<p><code>static</code> 对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</p>
<p>对于一个全局变量，它既可以在本源文件（定义此全局变量的源文件）中被访问到，也可以在同一个工程的其它源文件中被访问（其他源文件只需用 <code>extern</code> 进行声明即可）。</p>
<p>在本源文件中（定义时）用 <code>static</code> 对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p>
</blockquote>
<p>引用<a href="">另一篇帖子</a>中的表述：</p>
<blockquote>
<p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</p>
<p>把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</p>
<p>Tip A.若全局变量仅在单个 C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间（文件间）的耦合度；</p>
<p>Tip B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间（函数间）的耦合度；</p>
<p>Tip E.函数中必须要使用 <code>static</code> 变量情况：比如当某函数的返回值为指针类型时，则必须是 <code>static</code> 的局部变量的地址作为返回值，若为 <code>auto</code> 类型，则返回为错指针。</p>
</blockquote>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><blockquote>
<p>在 C 语言中，修饰符 <code>extern</code> 用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</p>
<p><code>extern</code> 声明的位置对其作用域也有关系，如果是在 <code>main</code> 函数中进行声明的，则只能在 <code>main</code> 函数中调用，在其它函数中不能调用。</p>
</blockquote>
<p>看到这里，应该也理解了 <code>extern</code> 关键字了。如果还要进一步理解可以参考 <a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">C/C++中extern关键字详解</a>，但其实不建议通过这篇帖子学习，因为其中的逻辑层次、语言表述很让人难受啊。</p>
<h2 id="二进制兼容"><a href="#二进制兼容" class="headerlink" title="二进制兼容"></a>二进制兼容</h2><p><a href="https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html">C++ 项目中的 extern “C” {}</a></p>
<p>不同语言编写的代码互相调用是困难的，甚至是同一种编写的代码但不同的编译器编译的代码。</p>
<p>为了使它们遵守统一规则，可以使用 <code>extern</code> 指定一个编译和连接规约。</p>
<p><code>extern &quot;C&quot;</code> 指令非常有用，因为 C 和 C++ 的近亲关系。注意：<code>extern &quot;C&quot;</code> 指令中的 <code>C</code>，表示的一种 <strong>编译和连接规约</strong>，而不是一种语言。C 表示符合 C 语言的编译和连接规约的任何语言，如 Fortran、assembler 等。</p>
<p>还有要说明的是，<code>extern &quot;C&quot;</code> 指令仅指定编译和连接规约，但不影响语义。例如在函数声明中，指定了 <code>extern &quot;C&quot;</code>，仍然要遵守 C++ 的类型检测、参数转换规则。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在弄清楚 <code>extern</code> 关键字的过程中，还额外学到了一些知识：</p>
<ol>
<li><p><a href="http://developer.51cto.com/art/201105/261467.htm">头文件中定义实体（不只是声明）</a></p>
<blockquote>
<p>不能在头文件中定义变量。但是有三个例外。头文件可以定义类、值在编译时就知道的 <code>const</code> 对象和 <code>inline</code> 函数。</p>
</blockquote>
</li>
<li><p><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">extern 和 const</a></p>
<blockquote>
<p> <strong>C++</strong> 中 <code>const</code> 修饰的全局常量据有跟 <code>static</code> 相同的特性，即它们只能作用于本编译模块中，但是 <code>const</code> 可以与 <code>extern</code> 连用来声明该常量可以作用于其他编译模块中</p>
<p> 我只是想提醒你，<code>const char* g_str = &quot;123456&quot;</code> 与 <code>const char g_str[] =&quot;123465&quot;</code>是不同的， 前面（指向常量的普通指针 pointer to const）那个 <code>const</code> 修饰的是 <code>char *</code> 而不是 <code>g_str</code>,它的 <code>g_str</code> 并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你想让 <code>char* g_str</code> 遵守 <code>const</code> 的全局常量的规则，最好这么定义 <code>const char* const g_str=&quot;123456&quot;</code>（指向常量的常量指针 const pointer to const）。</p>
</blockquote>
<p> 强调，C++ 和C 是不同的！</p>
</li>
<li><p><a href="http://www.caole.net/diary/lvalue.html">C/C++ 中的左值</a></p>
<p> 左值、右值的概念真是反人类啊，其实一直不懂掌握这个知识点对于程序员有什么价值。只看到了 2.2节，因为 2.3节中出现了未掌握的类型转化，当然最主要的原因还是~我真的看不下去了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
  </entry>
  <entry>
    <title>Fiddler 使用技巧</title>
    <url>/2017/04/18/fiddler/</url>
    <content><![CDATA[<p>2015年11月16日 11:34:56</p>
<p>先放一个链接：<a href="http://kb.cnblogs.com/page/130367/">Fiddler 教程</a></p>
<p>在使用 <code>curl</code> 命令，调用 libcurl 中有涉及 http 传输（主要是上传），所以需要查看 http headers。但也因为只是简单实用，所以我自己本人并未看过这篇教程。只是觉得作者条理清晰，文章内容应该不会差，作为一篇教程应该足以。</p>
<p>以下只列出几个在实际使用中碰到的问题：（其实在网上都能查到，但是一个帖子一个问题，比较零散，统一放在这里，以备以后查看）</p>
<a id="more"></a>

<h1 id="fiddler-不能监听-localhost"><a href="#fiddler-不能监听-localhost" class="headerlink" title="fiddler 不能监听 localhost"></a>fiddler 不能监听 localhost</h1><p>解决方案：</p>
<ul>
<li>在 localhost 后加点“.”，例如 <code>http://localhost.:8080</code>  而不是  <code>http://localhost:8080</code></li>
<li>同理，用 <code>http://127.0.0.1.</code>  (127.0.0.1 紧跟一个点号)</li>
<li>用本机 ip 或者机器名访问，例如：<code>http://10.10.44.96:8080</code> 或者 <code>http://machinename</code>  (机器名)</li>
</ul>
<h1 id="fiddler-无法抓取-chrome"><a href="#fiddler-无法抓取-chrome" class="headerlink" title="fiddler 无法抓取 chrome"></a>fiddler 无法抓取 chrome</h1><p>这个问题出在代理上面。实际上 fiddler 是可以抓 chrome 的请求的。</p>
<p>如果 chrome 安装了代理管理的插件 SwitchySharp，无论选择直接连接还是选择使用代理连接，插件都会屏蔽 fiddler 的设置。</p>
<p>fiddler 会自动给浏览器设置一个代理 127.0.0.1 端口 8888，并且记忆浏览器的代理设置，所有的请求先走 fiddler 代理，再走浏览器代理。</p>
<p>如果使用插件，可能会直接屏蔽了 fiddler 的代理，因此无法监听到请求了。</p>
<p>解决方案：</p>
<ul>
<li>代理插件选择“使用系统代理设置”选项</li>
<li>或者不使用插件，不用卸载，chrome 很方便禁用一个插件</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>文件描述符</title>
    <url>/2017/03/10/file-descriptor/</url>
    <content><![CDATA[<p>在《嗨翻C语言》的学习中，了解到“文件描述符”的概念。有一点点傻傻分不清楚文件描述符表中两列的区别，每每涉及重定向时觉得混乱。</p>
<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>参考 <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述符-维基百科</a> 中描述：</p>
<blockquote>
<p>在 UNIX/Linux 平台上，对于控制台（Console）的标准输入，标准输出，标准错误输出也对应了三个文件描述符。它们分别是 0,1,2。在实际编程中，如果要操作这三个文件描述符时，建议使用 <code>&lt;unistd.h&gt;</code> 头文件中定义的三个宏来表示：<code>STDIN_FILENO</code>, <code>STDOUT_FILENO</code> 以及 <code>STDERR_FILENO</code>。</p>
</blockquote>
<p>对于内核而言，所有打开文件都由文件描述符引用。文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用 <code>open</code> 或 <code>create</code> 返回的文件描述符标识该文件，将其作为参数传送给 <code>read</code> 或 <code>write</code>。</p>
<a id="more"></a>

<h1 id="FILE-指针"><a href="#FILE-指针" class="headerlink" title="FILE* 指针"></a>FILE* 指针</h1><p>在介绍 <a href="http://blog.csdn.net/jnu_simba/article/details/8806654">文件描述符和inode关系</a> 一篇文章中描述到：（待验证）</p>
<blockquote>
<p>在 UNIX 系统中，用户通过终端登录系统后得到一个 Shell 进程，这个终端<del>成为</del> 称为 Shell 进程的控制终端 (Controlling Terminal)，控制终端是保存在 PCB 中的信息，而我们知道 <code>fork</code> 会复制 PCB 中的信息，因此由 Shell 进程启动的其它进程的控制终端也是这个终端。</p>
</blockquote>
<blockquote>
<p>默认情况 下(没有重定向)，每个进程的标准输入(<code>stdin</code>)、标准输出(<code>stdout</code>)和标准错误输出(<code>stderr</code>)都指向控制终端，因为在程序启动时(在 <code>main()</code> 函数还 没开始执行之前)会自动把控制终端打开三次，分别赋给三个 <code>FILE *</code> 指 针 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>，这三个文件指针是 libc 中定义的全局变量，这三个文件的描述符分别是 0、1、2，<strong>保存在相应的 <code>FILE</code> 结构体中</strong>。进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
</blockquote>
<p>在了解以上内容之后，需要重新翻阅《嗨翻C语言》中相关章节，确定是否掌握。</p>
<h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><ul>
<li><p>文件描述符：在 linux 系统中，设备也是以文件的形式存在，要对该设备进行操作 就必须先打开这个文件，打开文件就会获得文件描述符，它是个很小的正整数。每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。</p>
<ul>
<li>文件描述符的优点：兼容 POSIX 标准，许多 Linux 和 UNIX 系统调用都依赖于它。</li>
<li>文件描述符的缺点：不能移植到 UNIX 以外的系统上去，也不直观。</li>
</ul>
</li>
<li><p>文件指针：C 语言中使用的是文件指针而不是文件描述符做为 I/O 的句柄。文件指针指向进程用户区中的一个被称为 <code>FILE</code> 结构的数据结构。<code>FILE</code> 结构包括一个缓冲区和 一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句柄）。<code>FILE *</code> 中除了包含了 <code>fd</code> 信息，还包含了 IO 缓冲，是 C 标准形式，所以 <code>FILE *</code> 比 <code>fd</code> 更适合跨平台，应该多用 <code>fopen</code> 在，少用 <code>open</code>。</p>
</li>
<li><p>C 语言文件指针与文件描述符之间可以相互转换：通过 <code>fdopen</code> 和 <code>fileno</code> 两个函数实现，它们都包含在头文件 stdio.h 中。</p>
</li>
</ul>
<h1 id="查阅文件"><a href="#查阅文件" class="headerlink" title="查阅文件"></a>查阅文件</h1><p>参见 Debian8Light 系统 /usr/include/stdio.h 文件：</p>
<p><code>stdin</code> <code>stdout</code> <code>stderr</code> 是 <code>_IO_FILE</code> 结构体类型，而 <code>_IO_FILE</code> 和 <code>FILE</code> 一致。</p>
<p>参见 Debian8Light 系统 /usr/include/libio.h 文件：（可以看到 <code>_IO_FILE</code> 结构体中封装了 <code>_fileno</code> 属性）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>fprintf(stdout, &quot;Hello world!\n&quot;);</code> 在 <code>./test &gt; a.out</code> 重定向之后打印结果到 a.out 文件。</p>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p>以下链接，供进一步理解。</p>
<ul>
<li><p><a href="http://blog.csdn.net/cywosp/article/details/38965239">Linux中的文件描述符与打开文件之间的关系</a></p>
<blockquote>
<p>两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 <code>read()</code>、<code>write()</code> 或 <code>lseek()</code> 所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。</p>
</blockquote>
</li>
<li><p><a href="http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html">linux中文件描述符fd和文件指针flip的理解</a></p>
<blockquote>
<p><strong>每个进程在 PCB（Process Control Block）即进程控制块中都保存着一份文件描述符表，文件描述符就是这个表的索引，文件描述表中每个表项都有一个指向已打开文件的指针</strong>，现在我们明确一下：已打开的文件在内核中用 <code>file</code> 结构体表示，文件描述符表中的指针指向 <code>file</code> 结构体。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>函数模板</title>
    <url>/2021/02/02/function-template/</url>
    <content><![CDATA[<p>function 模板到底是什么？ <a href="https://github.com/tnie/YDData2/issues/163">https://github.com/tnie/YDData2/issues/163</a></p>
<p>为什么 <code>function&lt;&gt;</code> 对象递归调用自身不能使用 <code>auto</code>? <a href="https://stackoverflow.com/questions/2067988/recursive-lambda-functions-in-c11">https://stackoverflow.com/questions/2067988/recursive-lambda-functions-in-c11</a></p>
<p>vc2015 IntelliSence 提示</p>
<blockquote>
<p>使用 <code>auto</code> 类型说明符声明的变量不能出现在其自身的初始值设定项中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// auto sum2 = [sum2](int a) &#123;  // 编译错误 why?</span></span><br><span class="line"><span class="comment">// std::function&lt;int(int)&gt; sum2 = [sum2](int a) &#123;  // 执行错误 why? 参考拷贝构造函数的参数为什么要使用引用类型。</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; sum2 = [&amp;sum2](<span class="keyword">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a + sum2(a - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">spdlog::info(<span class="string">&quot;T(&#123;&#125;)=&#123;&#125;&quot;</span>, <span class="number">30</span>, sum2(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>
<p>虽然 <code>&amp;sum2</code> 引用能够调用成功，但我们必须时刻关注 sum2 对象的生存周期。比如以下代码就会崩溃</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; sum2Copy;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sum2 = ...</span></span><br><span class="line">    sum2Copy = sum2;</span><br><span class="line">&#125;</span><br><span class="line">spdlog::info(<span class="string">&quot;T(&#123;&#125;)=&#123;&#125;&quot;</span>, <span class="number">30</span>, sum2Copy(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>
<h1 id="boost-empty-value-的意义？"><a href="#boost-empty-value-的意义？" class="headerlink" title="boost::empty_value 的意义？"></a><code>boost::empty_value</code> 的意义？</h1><h1 id="funcion-模板"><a href="#funcion-模板" class="headerlink" title="funcion 模板"></a>funcion 模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ERR，报错内容在千里之外</span></span><br><span class="line"><span class="keyword">using</span> SENDFUNC = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(CBD , <span class="keyword">void</span> <span class="keyword">const</span> * <span class="keyword">const</span> , <span class="keyword">size_t</span> ) <span class="keyword">const</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> SENDFUNC = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(CBD , <span class="keyword">void</span> <span class="keyword">const</span> * <span class="keyword">const</span> , <span class="keyword">size_t</span> ) <span class="comment">/*const*/</span>&gt;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>查看内核版本、发行版本</title>
    <url>/2017/03/10/get-core-version/</url>
    <content><![CDATA[<p>Linux 查看系统信息：查看内核版本，查看发行版本。</p>
<h1 id="一、查看内核版本（2种方法）："><a href="#一、查看内核版本（2种方法）：" class="headerlink" title="一、查看内核版本（2种方法）："></a>一、查看内核版本（2种方法）：</h1><h2 id="查看-proc-version-☆"><a href="#查看-proc-version-☆" class="headerlink" title="查看 /proc/version ☆"></a>查看 <code>/proc/version</code> ☆</h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~$ cat /proc/version </span><br><span class="line">Linux version 3.16.0-4-amd64 (debian-kernel@lists.debian.org) (gcc version 4.8.4 (Debian 4.8.4-1) ) #1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29)</span><br><span class="line">vimer@debian8light:~$ </span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="使用-uname-a-命令"><a href="#使用-uname-a-命令" class="headerlink" title="使用 uname -a 命令"></a>使用 <code>uname -a</code> 命令</h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~$ uname -a</span><br><span class="line">Linux debian8light 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29) x86_64 GNU/Linux</span><br><span class="line">vimer@debian8light:~$ </span><br></pre></td></tr></table></figure>
<p>好好利用命令的帮助信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~$ uname --help</span><br><span class="line">用法：uname [选项]...</span><br><span class="line">输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。</span><br><span class="line"></span><br><span class="line">  -a, --all            以如下次序输出所有信息。其中若-p 和 -i 的探测结果不可知则被省略：</span><br><span class="line">  -s, --kernel-name        输出内核名称</span><br><span class="line">  -n, --nodename        输出网络节点上的主机名</span><br><span class="line">  -r, --kernel-release        输出内核发行号</span><br><span class="line">  -v, --kernel-version        输出内核版本</span><br><span class="line">  -m, --machine        输出主机的硬件架构名称</span><br><span class="line">  -p, --processor        输出处理器类型或&quot;unknown&quot;</span><br><span class="line">  -i, --hardware-platform    输出硬件平台或&quot;unknown&quot;</span><br><span class="line">  -o, --operating-system    输出操作系统名称</span><br><span class="line">      --help        显示此帮助信息并退出</span><br><span class="line">      --version        显示版本信息并退出</span><br><span class="line"></span><br><span class="line">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告uname 的翻译错误</span><br><span class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/uname&gt;</span><br><span class="line">or available locally via: info &#x27;(coreutils) uname invocation&#x27;</span><br><span class="line">vimer@debian8light:~$ </span><br></pre></td></tr></table></figure>
<h1 id="二、查看发行版本（2种方法）："><a href="#二、查看发行版本（2种方法）：" class="headerlink" title="二、查看发行版本（2种方法）："></a>二、查看发行版本（2种方法）：</h1><h2 id="使用-lsb-release-a-命令-☆"><a href="#使用-lsb-release-a-命令-☆" class="headerlink" title="使用 lsb_release -a 命令 ☆"></a>使用 <code>lsb_release -a</code> 命令 ☆</h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:    Debian</span><br><span class="line">Description:    Debian GNU/Linux 8.3 (jessie)</span><br><span class="line">Release:    8.3</span><br><span class="line">Codename:    jessie</span><br><span class="line">vimer@debian8light:~$ </span><br></pre></td></tr></table></figure>
<p>关于什么是 LSB？延伸阅读-<a href="https://www.ibm.com/developerworks/cn/linux/l-lsb-intr/">LSB 简介</a></p>
<p>有些系 统上不一定安装了这个命令，可以通过查看 /etc/issue 文件得到发行版信息。</p>
<h2 id="查看-etc-issue"><a href="#查看-etc-issue" class="headerlink" title="查看 /etc/issue"></a>查看 <code>/etc/issue</code></h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~$ cat /etc/issue</span><br><span class="line">Debian GNU/Linux 8 \n \l</span><br><span class="line"></span><br><span class="line">vimer@debian8light:~$ </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 获取系统时间</title>
    <url>/2016/11/03/getTime/</url>
    <content><![CDATA[<h1 id="C-获取系统时间"><a href="#C-获取系统时间" class="headerlink" title="C++ 获取系统时间"></a>C++ 获取系统时间</h1><p>有的帖子真心写的很好，你都想帮作者打广告。有的烂到即使你从里面学到了知识，你也不想再见到它，你都不想在自己的笔记里放它的链接，不然说不准哪天又点进去浪费自己的时间。</p>
<p>说一下思路：</p>
<ol>
<li>使用开发语言自身的标准库。对于 C++ 来说，使用 C 的或者 C++ 的</li>
<li>使用第三方库，如果有的话</li>
<li>使用系统相关 API。缺点在于不能跨平台</li>
</ol>
<a id="more"></a>

<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C 标准库"></a>C 标准库</h2><p>优点就是仅使用 C 标准库，能够跨平台使用；<strong>缺点</strong> 是只能精确到秒级。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; time.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">time_t</span> tt = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">t</span> =</span> localtime(&amp;tt); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, </span><br><span class="line">        t-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">        t-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">        t-&gt;tm_mday,</span><br><span class="line">        t-&gt;tm_hour,</span><br><span class="line">        t-&gt;tm_min,</span><br><span class="line">        t-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>struct tm </code>结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> tm_sec;    <span class="comment">/* 秒,取值范围(0~59)，但当遇到闰秒时则会有60秒的取值。 */</span></span><br><span class="line">   <span class="keyword">int</span> tm_min;    <span class="comment">/* 分钟数，取值范围(0-59) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_hour;   <span class="comment">/* 小时数，取值范围(0-23) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_mday;   <span class="comment">/* 当天在这个月中是第几天，取值范围(1-31) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_mon;    <span class="comment">/* 当前月份是第几个月，取值范围(0-11) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_year;   <span class="comment">/* 从1900年开始至今的年数，即(Year - 1900)的值 */</span></span><br><span class="line">   <span class="keyword">int</span> tm_wday;   <span class="comment">/* 当天在本周是第几天，取值范围(0-6, Sunday = 0) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_yday;   <span class="comment">/* 当天在今年是第几天，取值范围(0-365, 1 Jan = 0) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_isdst;  <span class="comment">/* 夏令时标记，值大于0表示夏令时生效；等于0表示夏令时失效；小于0表示数据不可用。 */</span></span><br><span class="line">   <span class="keyword">char</span>    *tm_zone; <span class="comment">/* 时区名称，根据系统不同可能不被声明或不同全名。 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>帖子很棒！<a href="http://sodino.com/2015/03/15/c-time/">日常时间的获取、格式化等操作汇总</a></p>
<ul>
<li><p>计算时间差值：<code>double difftime(time_t time1, time_t time0);</code></p>
</li>
<li><p>利用 <code>mktime()</code> 函数，获取某一天是本周的第几天（<code>tm_wday</code>），是当年的第几天（<code>tm_yday</code>）</p>
<blockquote>
<p>现在注意了，有了 <code>mktime()</code> 函数，是不是我们可以操作现在之前的任何时间呢？你可以通过这种办法算出 1945 年 8 月 15 号是星期几吗？答案是否定的。因为这个时间在 1970 年 1 月 1 日之前，所以在大多数编译器中，这样的程序虽然可以编译通过，但运行时会异常终止。</p>
</blockquote>
</li>
<li><p>使用限制：<code>time_t</code> 类型的限制</p>
<blockquote>
<p>既然 <code>time_t</code> 实际上是长整型，到未来的某一天，从一个时间点（一般是 1970 年 1 月 1 日 0 时 0 分 0 秒）到那时的秒数（即日历时间）超出了长整形所能表示的数的范围怎么办？对 <code>time_t</code> 数据类型的值来说，它所表示的时间不能晚于 2038 年 1 月 18 日 19 时 14 分 07 秒。</p>
</blockquote>
</li>
</ul>
<p>另外，要强调的是获取时间后推荐 <strong>使用本地结构保存</strong>。<a href="https://www.ibm.com/developerworks/community/blogs/12bb75c9-dfec-42f5-8b55-b669cc56ad76/entry/_e5_b0_8f_e5_bf_83c_e8_af_ad_e8_a8_80_e6_97_b6_e9_97_b4_e5_87_bd_e6_95_b0_e9_99_b7_e9_98_b1?lang=en">小心 C 语言时间函数陷阱</a></p>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>没有接触过</p>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>优点：能精确到<strong>毫秒级</strong>；缺点：使用了 windows API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; windows.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    SYSTEMTIME sys;   </span><br><span class="line">    GetLocalTime( &amp;sys );   </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%4d/%02d/%02d %02d:%02d:%02d.%03d 星期%1d\n&quot;</span>,</span><br><span class="line">        sys.wYear,sys.wMonth,sys.wDay,sys.wHour,sys.wMinute, </span><br><span class="line">        sys.wSecond,sys.wMilliseconds,sys.wDayOfWeek);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SYSTEMTIME</code> 结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEMTIME</span> &#123;</span></span><br><span class="line">    WORD wYear;</span><br><span class="line">    WORD wMonth;</span><br><span class="line">    WORD wDayOfWeek;</span><br><span class="line">    WORD wDay;</span><br><span class="line">    WORD wHour;</span><br><span class="line">    WORD wMinute;</span><br><span class="line">    WORD wSecond;</span><br><span class="line">    WORD wMilliseconds;</span><br><span class="line">&#125; SYSTEMTIME, *PSYSTEMTIME;</span><br></pre></td></tr></table></figure>
<p>更详细的信息，请查阅 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950(v=vs.85).aspx">MSDN-SYSTEMTIME structure条目</a></p>
<h2 id="Linux库"><a href="#Linux库" class="headerlink" title="Linux库"></a>Linux库</h2><p>参考<a href="http://sodino.com/2015/03/20/c-time-micro-nano/">时间精确到微秒、纳秒</a></p>
<ul>
<li><p>区分 <code>&lt;sys/time.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件，前者是*inux系统的系统库，后者可能也带有*inux色彩，但侧重 ANSI C 标准。</p>
</li>
<li><p>区分 GNU C和 ANSI C。</p>
<ul>
<li><code>&lt;time.h&gt;</code> 中不纯粹是 ANSI C 标准的定义，还包括一些 Linux 下的扩展，比如 ANSI(C99) 标准是没有要求微秒、纳秒类型的，而在 Linux 系统中的 <code>&lt;time.h&gt;</code> 包含 <code>struct timespec</code> 纳秒类型。如果代码中使用了这些扩展类型、扩展函数，就会造成平台移植时的不确定性。</li>
</ul>
</li>
</ul>
<blockquote>
<p>日期与时间函数在 <code>&lt;time.h&gt;</code> 中，主要表示处理器时钟的 <code>clock_t</code> 类型、表示时间的 <code>time_t</code> 类型、时钟每秒滴答数 <code>CLOCKS_PER_SEC</code>、描述日历时间的 <code>struct tm</code> 结构、函数 <code>clock、time</code>、<code>asctime</code>、<code>ctime</code>、<code>gmtime</code>、<code>localtime</code>、<code>mktime</code>、<code>difftime</code>、<code>strftime</code>、<code>wcsftime(宽字符版本)</code>，其他的都是非标准扩展。</p>
</blockquote>
<h1 id="获取时间间隔"><a href="#获取时间间隔" class="headerlink" title="获取时间间隔"></a>获取时间间隔</h1><h2 id="C标准库"><a href="#C标准库" class="headerlink" title="C标准库"></a>C标准库</h2><p>前文提到我们可以使用 <code>difftime()</code> 函数，但它只能精确到秒。如更精确一些呢？</p>
<p>参考 <a href="http://developer.51cto.com/art/201107/275692_all.htm">详细介绍C/C++时间函数使用方法</a>，推荐☆☆☆☆</p>
<p>C/C++ 中的计时函数是 <code>clock()</code>，而与其相关的数据类型是 <code>clock_t</code>。这个函数返回从“开启这个程序进程”到“程序中调用 <code>clock()</code> 函数”时之间的 CPU 时钟计时单元（clock tick）数。在 <code>&lt;time.h&gt;</code> 文件中，还定义了一个常量 <code>CLOCKS_PER_SEC</code>，它用来表示一秒钟会有多少个时钟计时单元</p>
<p>可以用 <code>clock</code> 函数来计算你的机器运行一个循环或者处理其它事件到底花了多少时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “stdio.h”  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “stdlib.h”  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “time.h”  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">10000000L</span>;  </span><br><span class="line">    <span class="keyword">clock_t</span> start, finish;  </span><br><span class="line">    <span class="keyword">double</span> duration;  </span><br><span class="line">    <span class="comment">/* 测量一个事件持续的时间*/</span> </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Time to do %ld empty loops is &quot;</span>, i );  </span><br><span class="line">    start = clock();  </span><br><span class="line">    <span class="keyword">while</span>( i-- ) </span><br><span class="line">        ;  </span><br><span class="line">    finish = clock();  </span><br><span class="line">    duration = (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC;  </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%f seconds\n&quot;</span>, duration );  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>在 SUSE11 系统下，查找 <code>CLOCKS_PER_SEC</code> 的定义，在 time.h 中 指向 <code>&lt;bits/time.h&gt;</code>，其目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cts@SuSe-CTS2:/usr/include/bits&gt; <span class="built_in">pwd</span></span><br><span class="line">/usr/include/bits</span><br><span class="line">cts@SuSe-CTS2:/usr/include/bits&gt; </span><br></pre></td></tr></table></figure>
<p>然后找到看到以下宏：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  define CLOCKS_PER_SEC  1000000l</span></span><br></pre></td></tr></table></figure>
<p>在 Debian8.1 系统下，同上。<code>&lt;bits/time.h&gt;</code> 目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">niel@debian8light:/usr/include/x86_64-linux-gnu/bits$ <span class="built_in">pwd</span></span><br><span class="line">/usr/include/x86_64-linux-gnu/bits</span><br><span class="line">niel@debian8light:/usr/include/x86_64-linux-gnu/bits$ </span><br></pre></td></tr></table></figure>
<h1 id="关于闰秒"><a href="#关于闰秒" class="headerlink" title="关于闰秒"></a>关于闰秒</h1><p><a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E7%A7%92">闰秒</a>，英文名称 leap second，即 23:59:60</p>
<p><a href="https://zh.cppreference.com/w/c/chrono/time_t">time_t</a></p>
<blockquote>
<p>尽管 C 标准没有定义，它几乎总是一个保有从 UTC 1970 年 1 月 1 日 00:00 开始秒数的整数值（不计闰秒），对应 POSIX 时间</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a></p>
<blockquote>
<p><em>Unix time</em> (also known as <em>POSIX time</em> or <em>UNIX Epoch time</em>) is a system for describing a point in time. It is the number of seconds that have elapsed since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), <strong>minus（减去） leap seconds</strong>. Every day is treated <strong>as if it contains exactly 86400 seconds</strong>, so leap seconds are to be subtracted（扣除） since the epoch.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    tm tmp;</span><br><span class="line">    localtime_s(&amp;tmp, &amp;t);</span><br><span class="line">    <span class="keyword">auto</span> count = (tmp.tm_hour * <span class="number">60</span> + tmp.tm_min) * <span class="number">60</span> + tmp.tm_sec;</span><br><span class="line">    assert(count == (t % <span class="number">86400</span> + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>)); <span class="comment">// 东八区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;============2015年6月30日23：59：60&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    tmp.tm_year = <span class="number">2015</span> - <span class="number">1900</span>;  <span class="comment">// years since 1900</span></span><br><span class="line">    tmp.tm_mon = <span class="number">5</span>;</span><br><span class="line">    tmp.tm_mday = <span class="number">30</span>;</span><br><span class="line">    tmp.tm_hour = <span class="number">23</span>;</span><br><span class="line">    tmp.tm_min = <span class="number">59</span>;</span><br><span class="line">    tmp.tm_sec = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">auto</span> t60 = mktime(&amp;tmp);</span><br><span class="line">    <span class="keyword">char</span> cstr[<span class="number">100</span>];</span><br><span class="line">    asctime_s(cstr, &amp;tmp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cstr &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// Wed Jul  1 00:00:00 2015</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;结论：在 ctime 体系中不计闰秒。\</span></span><br><span class="line"><span class="string">所以即便使用 tm 构造出闰秒，在 ctime 体系中和下一日的 00:00:00 等同。\</span></span><br><span class="line"><span class="string">而 localtime() 永远得不到闰秒。&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>Git 凭证辅助工具</title>
    <url>/2017/02/16/git-credential/</url>
    <content><![CDATA[<p>事情源于我想将局域网内服务器上的代码上传到互联网上的远程仓库：repo-133 -&gt; repo-E431 -&gt; repo-remote</p>
<ul>
<li>代码编写以及编译运行只能在 133 服务器上，此机器无法连接互联网；</li>
<li>133 服务器可以访问我自己的笔记本 E431，毕竟我要通过 xshell 访问 133 进行开发；</li>
<li>E431 笔记本可以访问互联网，针对私有代码我一般使用开源中国作为远程仓库。</li>
</ul>
<p>实现这个打算很容易，问题出在精益求精的摸索过程中。我在 E431 上中转时使用的是 Bitvise SSH Server，搭建方法参考 <a href="http://blog.michiru.me/posts/git-server-on-windows.html">在 Windows 上搭建 Git 服务器</a>。（我在 E431 上建立的并不是裸仓库）搭建完毕，从 repo-133 向其推送时会失败：<a href="https://rwmj.wordpress.com/2009/03/06/git-fatal-no-matching-remote-head/">git “fatal: no matching remote head”</a>，当时因为有别的工作，通过将 repo-E431 检出一个无用分支规避错误。</p>
<a id="more"></a>

<p>最近有时间，想着上述解决方案太粗糙了，用着也不方便，就打算再花时间“打磨”一下，没曾想竟然用了整整两天的时间。主要是花在了弄清楚 git credential 机制（凭证辅助工具系统）上。</p>
<p>包括上述提到推送失败，原方案存在两个问题：将 E431 的版本库建立成 非 bare 的，133 向 E431 提交时必须绕开工作区所在分支；133 提交后，还需要在 E431 上手工再一次提交。针对上述两个问题，分别改进（133 上的代码、配置不需要做任何更改）：E431 使用 <code>git init --bare</code> 重新建立仓库，并使用 git hook 自动提交。</p>
<p>上面的解决思路是正确的。将 E431 仓库改为裸仓库之后，因为不存在工作区所以就不会再有冲突，但同样的因为不存在工作区，在裸仓库中许多涉及工作区的命令都是不能用的，比如 <code>git pull</code></p>
<h1 id="git-hook"><a href="#git-hook" class="headerlink" title="git hook"></a>git hook</h1><p>参考 <a href="https://segmentfault.com/a/1190000003836345#articleHeader5">配置 Git Hook</a> 帖子，了解 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">8.3 自定义 Git - Git 钩子</a>，发现要实现我的目的只需要在 <code>DirMonitor.git/hooks/</code> 目录下创建 post-receive 文件即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo &quot;&quot; &amp;&amp; echo &quot;start transfer...&quot;</span><br><span class="line">git push --all</span><br><span class="line">echo &quot;done&quot; &amp;&amp; echo &quot;&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>虽然涉及到的知识点较多，但如果只要求实现上述目的，对涉及到的知识点完全不需要做什么了解就可以完成。</p>
<p>胜利在望，在 133 更新、提交并推送，咔嚓，折了。至此，遇到了第一个难题。根据报错的信息在网上各种查阅，都不对症，最后绕回来还是以 stackoverflow 上的两个解答为契机，结合自己使用 Bitvise SSH Server，有了猜测。Bitvise SSH Server 更换虚拟账户，新添 windows 本地账户（133 使用此账户访问远程主机）解决了此问题。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/5697210/msysgit-error-with-hooks-git-error-cannot-spawn-git-hooks-post-commit-no-su">msysgit error with hooks: “git error: cannot spawn .git/hooks/post-commit: No such file or directory”</a></li>
<li><a href="http://stackoverflow.com/questions/13297100/how-do-i-execute-a-post-receive-hook-on-msysgit-on-windows-hosted-by-apache">How do I execute a post-receive hook on msysgit on Windows hosted by Apache?</a></li>
</ul>
<p>我碰到的问题和第一篇问答中报错信息相仿 “git error: cannot spawn .git/hooks/post-receive: No such file or directory”，但赞同数最高的答案是 SHEBANG，很明显这不是我的问题，第一次看到这篇问答时忽略了其余的回答。等后来还是解决不了，偶然撞上第二篇问答，相互佐证，猜测我碰到的问题可能类似：</p>
<blockquote>
<p>Apache must run as a regular user instead of Local System, in order to benefit from the environment variables defined for said regular user.</p>
</blockquote>
<p>事实上，我新增 windows 系统登录用户到 Bitvise SSH Server，并将 133-repo 访问远程的用户同步修改后的确不再报此错误，能够执行 hook 脚本并打印输出，但在 <code>git push -all</code> 时卡死，始终不返回——欲知后事如何，且看下节精彩。</p>
<p>扩展学习：</p>
<blockquote>
<p>在计算机科学中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。引用自 <a href="https://zh.wikipedia.org/wiki/Shebang">维基百科</a></p>
</blockquote>
<ol>
<li>post-receive 和 post-update 的区别</li>
<li><code>unset GIT_DIR</code> 存在的必要：源于 <a href="https://x-front-team.github.io/2016/09/03/%E4%BD%BF%E7%94%A8git%E9%92%A9%E5%AD%90%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/">使用git钩子自动部署服务</a></li>
<li>脚本语言</li>
<li>expect 语法：源于 <a href="https://www.404forest.com/2016/10/28/use-expect-and-git-hooks-to-automate-deployment-tasks/#2-expect">使用 expect/git hooks 实现项目在服务器端的自动部署</a></li>
</ol>
<h1 id="交互式命令"><a href="#交互式命令" class="headerlink" title="交互式命令"></a>交互式命令</h1><p>面对上一节末尾出现的问题，毫无思路，在网上也查不到任何信息。只能自己摸索，而我根本不会写脚本，只能将 post-receive 中的 git push 换成其他的 git 命令，比如 git remote 和 git remote show origin。因为实在查阅不到什么有价值的信息，而且僵在这个问题上让我很烦，所以就自行摸索了（可能稍微懂脚本的同学一眼就能看到问题所在，╮(╯▽╰)╭）穷则思变</p>
<p>发现 git remote 本地操作的命令可以正常执行；但 git remote show origin 这种需要网络访问的就存在问题。进一步使用 <code>ping git.oschina.net</code> 过滤掉“网络可能未连通”之后，将矛头对准了交互。事后弄清原因之后，发现造成这种困扰并让我花费很多时间才做出正确的推断是一件很“凑巧”的事情：</p>
<p>如果使用 <code>https://</code> 协议</p>
<ul>
<li>使用 git credential 存在多种凭证辅助工具：cache、store 和 manager</li>
<li>[√]不使用 git credential，直接在 url 中包含用户名和密码 <code>https://username:password@github.com/username/repository.git</code></li>
<li>不使用 git credential，使用常规 url。在每次访问远程时都手动输入用户名、密码。</li>
</ul>
<p>如果使用 <code>ssh://</code> 协议</p>
<ul>
<li>使用 passphrase</li>
<li>[√]不使用 passphrase</li>
</ul>
<p>新版本 Git for Windows（2.9）一路默认安装，并使用了 Windows Credential Store 凭证辅助工具，以至于我在 E431 上敲入 git push、git remote show origin 等命令时直接就执行了，无需输入用户名、密码（我使用的 <code>https://</code> 协议，并且在之前我肯定输入了 username &amp; password，但我却无意识究竟发生了什么，代表着什么——这个下一节介绍）</p>
<p>为了证实猜测，我做了两次尝试验证。悲伤的是，两次验证的方向都是正确的，但源于别的小问题，却阻碍了我坚定信心，沿着既定方向一路摸索下去的决心，推迟了我看到真相的时间。</p>
<ol>
<li><p>使用 <code>https://</code> 协议，放弃 git credential 凭证辅助工具，直接在 url 中包含用户名和密码</p>
<p> 这个解决方案是正确的。可是 <code>https://username:password@github.com/username/repository.git</code> 这样子写有个例外，就是 password 不能包含 <code>/</code>。当时含有 <code>/</code> 报错 “Couldn’t resolve host ‘username’”，害的我一度以为 OSChina 和 Github 放弃了这种方法，毕竟使用明文密码很不友好。</p>
<p> 后来我将 OSChina 账户的密码改了，不再包含 <code>/</code>，就顺利地执行了。</p>
</li>
<li><p>使用 <code>ssh://</code> 协议。虽然我中间尝试过改用此协议，但我忽略了 passphrase 的存在，当初 <code>ssh-keygen</code> 时敲入了密码，造成现在即便使用 <code>ssh://</code> 协议，依旧存在交互。</p>
<p> 重新生成密钥，不再使用 passphrase，同样顺利地执行了。</p>
</li>
</ol>
<p>遗留问题：</p>
<ol>
<li>如果坚持使用含有 <code>/</code> 字符的密码，那么该如何在 url 使用密码呢？ <a href="http://stackoverflow.com/questions/24718519/clone-a-repo-with-slash-in-password">Clone a repo with Slash in Password</a> 无解</li>
<li>如果  OSChina 或 Github 使用了双重认证，对此有何影响？</li>
<li>我在 Git for Windows 中执行帖子 <a href="http://www.au92.com/archives/remove-passphrase-password-from-private-rsa-key.html">SSH私钥取消密码（passphrase）</a> 中描述的命令时直接僵死，没有反应，为什么？</li>
</ol>
<h1 id="git-credential"><a href="#git-credential" class="headerlink" title="git credential"></a>git credential</h1><p>这真的是一块我之前完全忽略了的知识点。只能说 Git 做的太好了，让普通用户感受不到凭证辅助工具系统的存在，对用户来说是透明的。</p>
<p>在这一节中，我就不再叙述学习过程中的曲折了，因为着实绕了个大弯才重新回到正道上。就直接说结果了。</p>
<ul>
<li>提纲挈领，也是让我认识到 git credential 存在的一篇好贴 <a href="http://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github">Is there a way to skip password typing when using https:// on GitHub?</a></li>
<li>读书 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">7.14 Git 工具 - 凭证存储</a></li>
<li>看手册 <a href="https://git-scm.com/docs/git-credential">git-credential</a>、<a href="https://git-scm.com/docs/git-credential-store">git-credential-store</a>、<a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a>，因为这三条命令的使用说明都是英文的，没有读。想着上面那本书挺经典的，只读书也能理解个七七八八，结果误了，译文表达欠妥也是重要原因之一。</li>
</ul>
<h2 id="git-credential-xxx"><a href="#git-credential-xxx" class="headerlink" title="git credential-xxx"></a><code>git credential-xxx</code></h2><p>凭证辅助工具有很多种，甚至用户可以自己写一个，只要满足特定的接口就可以。常见的几种凭证辅助工具：cache、store、windows 下的 Windows Credential Store、mac 下的 osxkeychain。</p>
<p>在 Git 中操作这几种工具的命令分别是：<code>git credential-cache</code>、<code>git credential-store</code>、<code>git credential-manager</code>（mac 下的我不知道）。这些命令的使用有点奇葩：</p>
<blockquote>
<p>这个命令接收一个参数，并通过标准输入获取更多的参数。</p>
</blockquote>
<p>前文提到凭证辅助工具必须满足特定的接口，此“特定的接口”就是指增加、查询和删除。当然，还可以有更多的功能，但至少得有这三个接口。接口的使用方式也是死的，分别通过 <code>store</code>、<code>get</code> 和 <code>erase</code> 参数 —— 即引用中提到的“一个参数”中的“参数”。</p>
<h2 id="git-credential-1"><a href="#git-credential-1" class="headerlink" title="git credential"></a><code>git credential</code></h2><p>git credential 命令的存在是为了抹掉辅助工具和 Git 之间的耦合，毕竟 Git 命令执行只关心交互时的凭证，不必操心这些凭证哪来的——鸡蛋好吃就行，何必找下蛋的那只鸡呢。</p>
<p>使用 git credential 之前可以通过 <code>git config [--global] credential.helper xxx</code> 配置凭证辅助工具。git credential 的用法和上述 git credential-xxx 的用法非常相似，只是参数不一样：</p>
<ul>
<li><code>fill</code>，可以理解为查询，从配置的所有辅助工具中查询，如果没查找，就伸手<strong>和用户要</strong></li>
<li><code>approve</code>，可以理解为添加，如果用户给的凭证经验证有效，（git）就调用这个命令将凭证保存到配置的所有辅助工具中</li>
<li><code>reject</code>，可以理解为删除，调用这个命令会从配置的所有辅助工具中把与 description 匹配的凭证删掉</li>
</ul>
<p>git credential 命令是给 Git 调用的接口，不是给程序员，不是给 git 使用者的——理解这一点很重要。</p>
<p>容易存在的一个误解是，上述加粗部分。<code>git credential fill</code> 从用户输入得到的用户名、密码是不会存储的。但 git push、git remote show origin 等远程交互命令会存储源于其对 <code>git credential fill</code> + core features + <code>git credential approve</code> 的封装：从标准输入得到用户名、密码之后，进行访问验证，如果成功 git 会调用 <code>git credential approve</code> 将此组 protocol、host、username、password 添加到辅助工具中。参考 <a href="https://git-scm.com/docs/git-credential#_typical_use_of_git_credential">_typical_use_of_git_credential</a></p>
<p>强调，git credential 凭证辅助工具系统是针对 <code>http[s]://</code> 协议的，和 <code>ssh://</code> 协议无关。</p>
<blockquote>
<p>如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。</p>
<p>然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。 这在使用双重认证的情况下会更麻烦，因为你需要输入一个随机生成并且毫无规律的 token 作为密码。幸运的是，Git 拥有一个凭证系统来处理这个事情。</p>
</blockquote>
<p>扩展学习：</p>
<p>git 存在三个层次的配置文件？全局的应该是在 <code>D:\Program Files\Git\mingw32\etc\gitconfig</code> 下；用户主目录下应该有一份 .gitconfig；每个 repo 下有一份，在 .git/config 文件。修改时分别用什么参数呢？</p>
<h2 id="windows-下的凭证辅助工具"><a href="#windows-下的凭证辅助工具" class="headerlink" title="windows 下的凭证辅助工具"></a>windows 下的凭证辅助工具</h2><ol>
<li><p>在 windows 下 cache 辅助工具不能用，<code>git credential-cache</code> 不是有效命令。</p>
<p> 参考链接：<a href="http://stackoverflow.com/questions/11693074/git-credential-cache-is-not-a-git-command">git: ‘credential-cache’ is not a git command</a></p>
</li>
<li><p>在 windows 下 store 辅助工具也有问题，执行 <code>git credential-store XXX</code> 会报错。</p>
<p> 参考链接：<a href="http://stackoverflow.com/questions/37505843/fatal-unable-to-get-credential-storage-lock-file-exists">fatal: unable to get credential storage lock: File exists</a>，解决方案意义不大，如果我坚持使用 store 辅助工具呢？</p>
</li>
<li><p>我一度还碰到 “Fatal: Exception encountered” 错误。</p>
<p> 参考链接：<a href="https://github.com/projectkudu/kudu/issues/2044">Fatal: Exception encountered.</a></p>
</li>
<li><p>有上述两个前提，在 windows 下凭证辅助工具只能用 <code>git credential-manager</code> 了。</p>
<p> 直接在开始菜单搜索框中输入“Windows Credential Store”，可以使用窗口操作凭证。</p>
</li>
</ol>
<h1 id="最后的问题"><a href="#最后的问题" class="headerlink" title="最后的问题"></a>最后的问题</h1><p>为什么 hook 脚本中交互式命令不能直接使用凭证辅助工具中保存的用户名、密码呢？有什么方法可以做到呢？</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 进阶操作和工作流</title>
    <url>/2016/11/02/git-workflow/</url>
    <content><![CDATA[<p>进阶操作不包含基础，进阶分为两部分：使用分支和修改提交。主要整理自 <a href="http://backlogtool.com/git-guide/cn/">猴子都能懂的 GIT 入门</a>。关于工作流，罗列了几个链接，值得反复阅读学习。</p>
<p>其实我们在 <a href="https://git-scm.com/">Git 官网</a> 就能找到最好的学习材料：<a href="https://git-scm.com/book/zh/v2">《Pro Git》</a>。知识点讲得很全，也讲得很好。无论是进行系统的学习，还是作为参考手册都是不二之选！但如果你真的只有 5 分钟时间，还要快速上手使用，拿这么一本书显然是不合适的，所以就推荐了上面的入门贴。实际工作中，碰到什么问题，我都是来翻书的。</p>
<h1 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h1><p><strong>先确定运用规则才可以有效地利用分支。</strong></p>
<h2 id="Merge-分支"><a href="#Merge-分支" class="headerlink" title="Merge 分支"></a>Merge 分支</h2><blockquote>
<p>Merge 分支是为了可以随时发布 release 而创建的分支，它还能作为 Topic 分支的源分支使用。保持分支稳定的状态是很重要的。如果要进行更改，通常先创建 Topic 分支，而针对该分支，可以使用Jenkins 之类的 CI 工具进行<strong>自动化编译以及测试</strong>。</p>
<p>通常，大家会将 master 分支当作 Merge 分支使用。</p>
</blockquote>
<h2 id="Topic-分支"><a href="#Topic-分支" class="headerlink" title="Topic 分支"></a>Topic 分支</h2><blockquote>
<p>Topic 分支是为了开发新功能或修复 Bug 等任务而建立的分支。若要同时进行多个的任务，请创建多个的 Topic 分支。</p>
<p>Topic 分支是从稳定的 Merge 分支创建的。完成作业后，要把 Topic 分支合并回 Merge 分支。</p>
</blockquote>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>完成作业后的 topic 分支，最后要合并回 merge 分支。合并分支有2种方法：使用 merge 或 rebase。使用这2种方法，合并后分支的历史记录会有很大的差别。</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>进行 merge 的话，分为两种情况：</p>
<ol>
<li><p>fast-forward（快进）合并</p>
<p> 合并 bugfix 分支到 master 分支时，如果 master 分支的状态没有被更改过，那么这个合并是非常简单的。 bugfix 分支的历史记录包含 master 分支所有的历史记录，所以只要把 bugfix 移动到 master 分支就可以导入 bugfix 分支的内容了（即<strong>将 master 的 HEAD 移动到 bugfix 的 HEAD 这里</strong>）。这样的合并被称为 fast-forward（快进）合并。</p>
<p> <strong>这种场景不会产生新的提交。</strong></p>
</li>
<li><p>non fast-forward</p>
<p> 但是，master 分支的历史记录有可能在 bugfix 分支分叉出去后有新的更新。这种情况下，要把 master 分支的修改内容和 bugfix 分支的修改内容汇合起来。</p>
<p> 因此，合并两个修改会生成一个提交。这时，master 分支的 HEAD 会移动到该提交上。</p>
</li>
</ol>
<p>Note</p>
<blockquote>
<p>执行合并时，如果设定了 non fast-forward （<code>--no-ff</code>）选项，即使在能够 fast-forward 合并的情况下也会生成新的提交并合并。</p>
<p>执行 non fast-forward 后，分支会维持原状。那么要查明在这个分支里的操作就很容易了。</p>
</blockquote>
<p>阮一峰老师写到：</p>
<blockquote>
<p>使用 <code>--no-ff</code> 参数后，会执行正常合并，在 Master 分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p>
</blockquote>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">rebase</a></h3><p>这个没有亲自实践过，要认真学学。</p>
<ol>
<li><p>首先，rebase bugfix 分支到 master 分支, bugfix 分支的历史记录会添加在 master 分支的后面。</p>
<p> 这时移动提交 X 和 Y 有可能会发生冲突，所以需要修改各自的提交时发生冲突的部分。</p>
</li>
<li><p>rebase 之后，master 的 HEAD 位置不变（此时就是典型的 fast-forward merge 场景了）。因此，要合并 master 分支和 bugfix 分支，即是将 master 的 HEAD 移动到 bugfix 的 HEAD 这里。</p>
</li>
</ol>
<p>rebase 最大的优点是：<strong>历史记录成一条线，相当整洁</strong>。在《Pro Git》书中提到：</p>
<blockquote>
<p>变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该<strong>项目的维护者就不再需要进行整合工作</strong>，只需要快进合并便可。</p>
</blockquote>
<p>同样，在书中也提到了变基的风险，作为新手我们并不需要做过多的学习。</p>
<p>具体练习见 <a href="http://backlogtool.com/git-guide/cn/stepup/stepup2_8.html">用 rebase 合并</a>。</p>
<h1 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h1><p>参考自 <a href="http://backlogtool.com/git-guide/cn/stepup/stepup6_1.html">改写提交</a>。改写提交非常容易出现冲突，需要人工合并。</p>
<p>“改写提交”，我觉得《Pro Git》的表达更好一些——“重写历史”。因为有关的操作大多比较敏感，都有后遗症，操纵不当更会变成灾难，所以建议 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">认真读书</a>、反复练习之后再在实际项目中操作。</p>
<p>在进入正文之前，我们必须清楚 <code>^</code> 和 <code>~</code> 的区别：<a href="http://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git">What’s the difference between HEAD^ and HEAD~ in Git?</a></p>
<p><strong>强调</strong>：<code>~</code> 是对 <code>^</code> 的复合运算，而不是 <code>^n</code> 的复合运算。</p>
<h2 id="修改最近的提交"><a href="#修改最近的提交" class="headerlink" title="修改最近的提交"></a>修改最近的提交</h2><p>git commit –amend</p>
<h2 id="取消过去的提交（内容）"><a href="#取消过去的提交（内容）" class="headerlink" title="取消过去的提交（内容）"></a>取消过去的提交（内容）</h2><p>git revert 可以取消指定的提交内容。</p>
<p>虽然使用后面要提到的 rebase -i 或 reset 可以直接删除提交，但是有时候并不合适（甚至不能）直接删除提交，比如不能随便删除已经<strong>发布的</strong>提交。这时就可以通过 revert 创建（否定某一次提交的）提交。</p>
<h2 id="遗弃提交"><a href="#遗弃提交" class="headerlink" title="遗弃提交"></a>遗弃提交</h2><p>git reset 除了默认的 mixed 模式，还有 soft 和 hard 模式。</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>HEAD 的位置</th>
<th>索引</th>
<th>工作树</th>
</tr>
</thead>
<tbody><tr>
<td>soft</td>
<td>修改</td>
<td><em>不修改</em></td>
<td><em>不修改</em></td>
</tr>
<tr>
<td>mixed</td>
<td>修改</td>
<td>修改</td>
<td><em>不修改</em></td>
</tr>
<tr>
<td>hard</td>
<td>修改</td>
<td>修改</td>
<td>修改</td>
</tr>
</tbody></table>
<p>主要使用的场合：</p>
<ul>
<li>复原修改过的索引的状态(mixed)</li>
<li>彻底取消最近的提交(hard)</li>
<li>只取消提交(soft)</li>
</ul>
<h2 id="提取提交"><a href="#提取提交" class="headerlink" title="提取提交"></a>提取提交</h2><p>cherry 樱桃</p>
<p>git cherry-pick 可以从其他分支复制指定的提交，然后导入到现在的分支。</p>
<p>例如，假设我们有个稳定版本的分支，叫 v2.0，另外还有个开发版本的分支 v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个 v3.0 中的功能到 v2.0 中，这里就可以使用 cherry-pick 了。</p>
<h2 id="改写提交的历史记录"><a href="#改写提交的历史记录" class="headerlink" title="改写提交的历史记录"></a><a href="http://backlogtool.com/git-guide/cn/stepup/stepup6_5.html">改写提交的历史记录</a></h2><p>git rebase -i</p>
<p>这个命令很强大，在 rebase 指定 <code>-i</code>（interactive，交互式的） 选项，可以改写、替换、删除或合并提交。但也有一些副作用……</p>
<p>请翻书，<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">重写历史</a></p>
<h3 id="副作用？"><a href="#副作用？" class="headerlink" title="副作用？"></a>副作用？</h3><p>场景描述：今天进行 rebase -i 操作后发现 merge –no-ff 的分支合并记录都没了</p>
<p>![merge –no-ff](<a href="https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/merge">https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/merge</a> –no-ff.png)</p>
<p>ps：借着这张图，复习一下 <code>^</code> 和 <code>~</code> 的知识。</p>
<ul>
<li>git reset head~，head 变更为 7c8d8a；</li>
<li>git reset head~2，head 变更为 6af94；</li>
<li>git reset head~^2，head 变更为 78663f；</li>
<li>git reset head<del>4，报错！因为 head</del>4 不存在</li>
<li><strong>强调</strong>：<code>~</code> 是对 <code>^</code> 的复合运算，而不是 <code>^n</code> 的复合运算。(7c8d8a)^2~ = 6af94d = (7c8d8a)~</li>
</ul>
<p>返回来继续说，执行 git rebase -i head~3 后结果如下：</p>
<p>![merge –no-ff](<a href="https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/merge">https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/merge</a> –no-ff 2.png)</p>
<p>在执行 git rebase -i head~3 时对话框如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 6af94d1 modify name.txt</span><br><span class="line">pick 78663ff new age.txt            （笔者注：7c8d8a2 透明的）</span><br><span class="line">pick 915b8b1 re modify name.txt</span><br><span class="line"></span><br><span class="line"># Rebase d0cd09d..915b8b1 onto d0cd09d (3 command(s))</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>可以看到，是不存在任何合并节点的。这也是 rebase 的目的！</p>
<p><strong>疑问</strong>：如果我只是想改写 7c8d8a 之前某个 commit 的备注信息，且不想丢失分支演进，改怎么做呢？</p>
<p><strong>结论</strong>：其实这算不得 rebase -i 的副作用，<code>git rebase</code> 默认 ignore merges。我自己以期上述目的，是用错了命令，<del>虽然我至今不知道怎么实现上述目的</del> 查看 <code>--preserve-merges</code> 参数。再往深的追究，其实我至今都不知道该怎么使用 git 去实现一个完善的工作流程，我了解一些命令的用法，但去不知道该怎么组织一个工程，怎么对一个项目进行细致的、完整的版本管理？</p>
<p>参见 <a href="https://git-scm.com/docs/git-rebase#git-rebase---preserve-merges"><code>git rebase --preserve-merges</code> 手册</a>。此参数的某些使用情景很乱，见 <a href="http://stackoverflow.com/questions/15915430/what-exactly-does-gits-rebase-preserve-merges-do-and-why">What exactly does git’s “rebase –preserve-merges” do (and why?)</a></p>
<h2 id="汇合分支上的提交，然后一同合并到分支"><a href="#汇合分支上的提交，然后一同合并到分支" class="headerlink" title="汇合分支上的提交，然后一同合并到分支"></a>汇合分支上的提交，然后一同合并到分支</h2><p>git merge –squash</p>
<h2 id="TortoiseGit-的-Show-RefLog"><a href="#TortoiseGit-的-Show-RefLog" class="headerlink" title="TortoiseGit 的 Show RefLog"></a>TortoiseGit 的 Show RefLog</h2><p>TODO：感觉很有用哎，今天进行 rebase -i 操作后发现 merge –no-ff 的分支合并记录都没了，而且进行了两次 reabse -i，所以也没办法通过 git reset ORIG_HEAD 恢复。幸运的是发现了 RefLog 的存在，不知道这是 Git 本身的功能，还是 TortoiseGit 的功能扩展。抽空查探一下。</p>
<p>是 Git 自身的机制，很强大！<a href="https://git-scm.com/docs/git-reflog">官方手册</a>，真心没有探索的欲望，怎么破？</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Tips</p>
<p>不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。</p>
<p>Tips</p>
<p>查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。</p>
<p>以下是Git的标准注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure>
<p>请以这种格式填写提交信息。</p>
<p>Get</p>
<p>切换分支使用 checkout，检出文件也使用 checkout……不是因为作者懒得起名字，而是因为两者本质是同一种操作，都是从版本库（或索引）检出文件到工作区。分支本质上是某一个提交（的引用），切换分支就是检出对应的提交。</p>
<p>Get</p>
<blockquote>
<p>如果在log命令添加 <code>--decorate</code> 选项执行，可以显示包含标签资料的历史记录。</p>
</blockquote>
<h2 id="在-windows-下搭建-git-服务器"><a href="#在-windows-下搭建-git-服务器" class="headerlink" title="在 windows 下搭建 git 服务器"></a>在 windows 下搭建 git 服务器</h2><p>2016/12/15 12:49:18 前两天将写的代码误删了，没有用版本管理工具。代码在一台连不上互联网的服务器上，因为系统老旧的原因，使用上有好多限制，负责人担心在新系统上写的代码拿到旧系统（最终必须部署在旧系统上）上用还得再次修改兼容性之类的问题，所以一般都是在旧系统上直接一个字母一个字母的敲代码。误删上周的工作内容后，后悔之余，也得考虑以后怎么避免这种情况。</p>
<p>在旧系统上凑活能装上 git，很原始的版本了。但它只能访问到我的笔记本（局域网），而不能访问互联网，所以就需要在 E431 windows7 的电脑上部署 Git 仓库。</p>
<ul>
<li><a href="http://blog.michiru.me/posts/git-server-on-windows.html">在 Windows 上搭建 Git 服务器</a></li>
</ul>
<p>依据上一篇搭建完成之后，操作中报错：（看着好像是不能是 <code>--bare</code> Repo 啊）</p>
<ul>
<li><a href="https://rwmj.wordpress.com/2009/03/06/git-fatal-no-matching-remote-head/">git “fatal: no matching remote head”</a></li>
</ul>
<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><p>工作流 flow，对于大团队和个人肯定是不一样的，不能一概而论。对于个人开发，其重点最终要落在对分支 branch 的利用上，只要合理安排分支基本就可以了。对于人员很多，强调合作开发的团队，在上述基础上还要找准各节点（每个开发人员）的定位，会变得复杂很多。</p>
<p>一个完整的工作流包括对分支的利用、对节点的安排。好在大多时候我们只需关注前面一部分就能达到目的。</p>
<h2 id="分支的安排"><a href="#分支的安排" class="headerlink" title="分支的安排"></a>分支的安排</h2><p>在 <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81">3.4 Git 分支 - 分支开发工作流</a> 中描述了“长期分支”和“特性分支”两个概念。</p>
<p>在 <a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略 - 阮一峰</a> 中使用了两个常设分支（长期分支）和三个临时分支（特性分支）。master 用于正式发布，develop 用于日常开发；feature 功能分支，Release 预发布分支，fixbug 修补分支。此策略即 <strong>Git flow</strong>。</p>
<blockquote>
<p>合并分支使用 <code>--no-ff</code> 选项。</p>
</blockquote>
<p>Git flow 并不完美，<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程 - 阮一峰</a> 中又讲解了另外两种分支策略：Github flow、Gitlab flow。推荐 Gitlab flow。<strong>在摸索中学习，在学习后实践。</strong></p>
<p>ps：2017/2/23 15:23:53 我现在认为基于“版本发布”的，还是使用 git flow 更好一些，更<strong>符合直觉</strong>，更何况有那么多的前辈们（非 web 开发）都是如此呢。</p>
<h3 id="gitlab-flow"><a href="#gitlab-flow" class="headerlink" title="gitlab flow"></a>gitlab flow</h3><p><a href="http://mojito515.github.io/blog/2016/03/09/ru-he-shi-yong-gitlabde-flowyi-ji-dai-ma-review/">如何使用gitlab的flow以及代码review</a></p>
<p><a href="https://www.15yan.com/story/6yueHxcgD9Z/">GitLab Flow的使用</a></p>
<h2 id="分布式节点的安排"><a href="#分布式节点的安排" class="headerlink" title="分布式节点的安排"></a>分布式节点的安排</h2><p>在 <a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">5.1 分布式 Git - 分布式工作流程</a> 中提到三种</p>
<blockquote>
<p>集中式工作流、集成管理者工作流、司令官与副官工作流。</p>
</blockquote>
<p>个人开发或者小团队开发，使用前者足够了。这种单点协作模型完全符合人们的直觉，好多人虽然不知道“集中式工作流”这个名词，但已经在这么用了。</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p><a href="https://github.com/xirong/my-git/blob/master/how-to-use-github.md">how-to-use-github</a></p>
<p>  对网络上众多资源的一个整理。</p>
</li>
<li><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86">7.3 Git 工具 - 储藏与清理</a></p>
<p>  <code>git stash</code> 和 <code>git clean</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用配置</title>
    <url>/2018/01/17/gitConfig/</url>
    <content><![CDATA[<p>在使用 git 版本仓库时，难免会出现默认配置不符合我们需要的地方。尤其是在 windows 上使用 git 时，不如意的地方就会更频繁的出现。这时需要我们自己手动微调 git 的默认配置，汇总如下：</p>
<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>经常输入 <code>git status</code> 查看库当前状态，如果终端环境不支持 tab 自动补全，频繁输入 <code>status</code> 完整单词就会变得很繁琐，考验耐心；即便支持自动补全，<code>git status</code> 和 <code>git stash</code> 也是前缀相同。这时我们可以考虑 <a href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases">使用别名</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.co checkout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.br branch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.ci commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.st status</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="自动补全-amp-色彩"><a href="#自动补全-amp-色彩" class="headerlink" title="自动补全 &amp; 色彩"></a>自动补全 &amp; 色彩</h1><p>较新版本的 git，较新版本的终端，没有遇到过无法自动补全的情况。在旧版本系统上，无法使用源码安装新版本 git 的前提下，使用老版本 git 可能遇到无法自动补全 and 黑底白字没有足够色彩提示的情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 待补充</span></span><br></pre></td></tr></table></figure>
<h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>换行符在跨平台时是一个老生常谈的问题了，在此不再介绍其背景知识，直接上结论。在跨平台使用同一版本仓库时，使用以下配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交时转换为 LF，检出时转换为 CRLF</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">true</span> </span><br><span class="line"><span class="comment">// 上述选项针对 msvc。如果是从 github 等仓库拉取的项目，且不使用 msvc 转文件格式，应该使用</span></span><br><span class="line">git config --global core.autocrlf input </span><br><span class="line"><span class="comment">// 拒绝提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span>   </span><br></pre></td></tr></table></figure>
<p>其中缘由，如有兴趣，请移步 <a href="http://kuanghy.github.io/2017/03/19/git-lf-or-crlf">Git 多平台换行符问题(LF or CRLF)</a>。</p>
<p>如果有除了源代码之外的更多文件格式的需求，可能需要参考</p>
<ul>
<li><a href="https://stackoverflow.com/questions/170961/whats-the-best-crlf-carriage-return-line-feed-handling-strategy-with-git">What’s the best CRLF (carriage return, line feed) handling strategy with Git?</a></li>
<li><a href="https://blog.miniasp.com/post/2014/02/20/Visual-Studio-Tools-for-Git-Line-Ending-Conversion-Notes.aspx">Visual Studio Tools for Git 处理断行字元(CRLF) 的注意事项</a></li>
</ul>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p><code>core.autocrlf=true</code> 碰到 utf-8 编码的包含汉字的文本时是否会出问题？——以前可能会，现在不会！</p>
<p><a href="https://github.com/cssmagic/blog/issues/22">GitHub 第一坑：换行符自动转换</a>，在<strong>缺陷</strong>一节提到内容，经实际测试不存在。测试环境：</p>
<blockquote>
<p>GitHub Desktop Version 1.0.11<br>git version 2.15.1.windows.2</p>
</blockquote>
<h1 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h1><p>在 linux 终端中，中文显示异常不一定是 git 的锅，可能是终端自身的问题。这里的解决方案针对的是 windows 下中文显示问题：</p>
<p><code>git log</code> 内容已可正常使用并显示中文，但 <code>git status</code> 和 <code>git push/pull</code> 时，中文文件名仍然乱码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不对 0x80 以上的字符进行 quote，解决 git status/commit 时中文文件名乱码</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>更多中文显示问题请移步 <a href="http://xstarcd.github.io/wiki/shell/git_chinese.html">Git中文显示问题解决</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GTD</title>
    <url>/2017/04/17/gtd/</url>
    <content><![CDATA[<p>2016/3/23 9:27:13</p>
<p>相信“GTD 这个系统本来也不是给初学者用的，整个系统过于复杂，难度过高，维持 GTD 系统本身就要花费很大的精力和时间”，引自 <a href="https://www.zhihu.com/question/23051794/answer/24689356">GTD 入门应该从哪些资料开始？ —— warfalcon 的回答</a>。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gtd/2a199e39-7741-4bff-a885-7aacb7dbca1b.png" alt="初学者应该学什么"></p>
<p>我在一年前为了使用 doit.im 还买了会员账户，当时肯定是真爱，期待也相信这个工具能够给我带来帮助，甚至是改变。事实是，跳槽之后（15年10月）我已经很少使用它了。也就是我迷恋这款应用只持续了三个月左右。</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/gtd/doit.png" alt="doit"></p>
<p>现在反思原因，下意识会认为自己并不需要这款应用，后来的冷淡也是喜新厌旧，过了蜜月期自然无爱了。可是我认为我当初既然愿意花费金钱，doit 必然是有其可取之处的。进一步思考，一方面我仍旧有收集任务、安排任务的需要，另一方面我并没有使用其他替代的工具，那究竟是为什么放弃了？——因为没有时间，没有条件。</p>
<ol>
<li>交代背景：我换工作没多久，丫头也就在智慧流开始新工作了，从 11 月份到今年的 3 月份，周一到周五，乃至周六都是七点半出门，九点上班，八点半下班，十点到家的节奏。</li>
<li>日程安排其实更适合于放在通勤时间去规划，可是我的 wp 太坑爹；另外，任务收集其实大多也来源于碎片时间。以前虽然碎片时间没有利用起来，但每天还是有两三个小时个人时间的，总是会开电脑的，捎带做一下输入工作还是很方便的。</li>
<li>而那小半年忙碌的时间，在工作日里唯一的个人时间就是睡觉的时候了。在工作日里，我基本就没用过自己的电脑。</li>
<li>也并不是完全不可以做。但人是有惰性的，当做事情的方便性大大折扣，自然就慢慢放弃了。</li>
</ol>
<p>要重新启用 doit！碎片时间的利用需要移动端的支持……联想的低端安卓机，还是丫头的苹果 4，或者买新手机？</p>
<p>对应用生态环境完善的移动端设备（说人话就是，安卓手机/苹果手机）需求越来越大了。</p>
<ul>
<li>doit</li>
<li>wiz</li>
<li>evernote</li>
<li>Dropbox</li>
<li>？Delicious</li>
<li>手机银行（工行、民生）</li>
<li>支付宝</li>
<li>……</li>
</ul>
<p>当某一天需要替换 doit 时，可以略作参考，当然到时候肯定还是会 Google 的。帖子肯定会过时的</p>
<ul>
<li><a href="http://www.zhihu.com/question/23452348">GTD类的工具（如Doit.im，Anydo等）哪种免费且好用点？</a></li>
</ul>
<p>另，omnifocus，据传为苹果系统上的 GTD 神器。收费应用，需购买。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>linux 指令之 g++</title>
    <url>/2017/04/26/gxx/</url>
    <content><![CDATA[<p>2015年11月6日 16:57:34</p>
<p>最全的学习材料当然是 GCC 的官方文档。如果有耐心但是英语不好的话，可以参看一下 <a href="http://www.shanghai.ws/gnu/gcc_1.htm">这个网站</a>。先说</p>
<h1 id="gcc-g-执行的四个过程："><a href="#gcc-g-执行的四个过程：" class="headerlink" title="gcc/g++ 执行的四个过程："></a>gcc/g++ 执行的四个过程：</h1><ol>
<li><p><code>gcc -E</code> 仅作预处理，即只激活预处理，不进行编译、汇编和链接                       <strong>{通常以什么为后缀？}</strong></p>
<p> <code>$gcc -E main.c -o main.i</code></p>
</li>
<li><p><code>gcc -s</code> 编译到汇编语言，不进行汇编和链接，即只激活预处理和编译，生成汇编语言</p>
<p> <code>$gcc -S main.i -o main.s  #参数-S，大写</code></p>
</li>
<li><p><code>gcc -c</code> 编译、汇编到目标代码，不进行链接，即只激活预处理、编译和汇编功能，生成目标文件（.o）</p>
<p> <code>$gcc -c main.s -o main.o</code></p>
</li>
<li><p>生成，到执行文件 （根据依赖关系链接各目标文件，生成最终的执行程序）</p>
<p> <code>$gcc main.o printf1.o printf2.o -o main</code></p>
</li>
</ol>
<a id="more"></a>

<p>更详细的描述参考：<a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html">Linux GCC常用命令</a>、<a href="http://blog.csdn.net/geniusluzh/article/details/8272913">gcc/g++执行的步骤及参数简介</a></p>
<p>了解 g++ 的编译流程之后，我们说一下</p>
<h1 id="g-和-gcc-的区别"><a href="#g-和-gcc-的区别" class="headerlink" title="g++ 和 gcc 的区别"></a>g++ 和 gcc 的区别</h1><ol>
<li> 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序；后缀为 .cpp 的，两者都会认为是 c++ 程序。</li>
<li> <strong>编译阶段</strong>，g++ 会调用 gcc，对于 c++ 代码，两者是等价的；（<strong>生成阶段</strong>）但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译/链接统统用 g++ 了。其实 <a href="http://www.cnblogs.com/iloveyoucc/archive/2012/08/29/2661851.html">gcc 编译 C++ 程序</a> 也可以。</li>
</ol>
<p>进一步的区别参考：<a href="http://www.52pojie.cn/thread-58109-1-1.html">gcc和g++的区别</a></p>
<p>然后说一下 </p>
<h1 id="I（大写的-i）、-L-这两个参数"><a href="#I（大写的-i）、-L-这两个参数" class="headerlink" title="-I（大写的 i）、-L 这两个参数"></a>-I（大写的 i）、-L 这两个参数</h1><ul>
<li><code>-I</code> 后跟路径名，指定 gcc 编译时的头文件搜索路径；（+系统默认的路径（<strong>具体呢？</strong>）下查找）</li>
<li><code>-L</code> 后跟路径名，指定 gcc 链接时查找库的搜索路径。（+系统默认的路径下查找）</li>
</ul>
<p>进一步延伸一下，<code>-L</code> 指定了库的路径，但具体是哪一个 .so 文件是怎么确定呢？</p>
<h1 id="l-（小写的-L）参数"><a href="#l-（小写的-L）参数" class="headerlink" title="-l （小写的 L）参数"></a>-l （小写的 L）参数</h1><p>下面通过记录具体的调试过程，逐步介绍。</p>
<ol>
<li><p><code>&gt; g++ main.cpp -o main</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nl@linux-zds2:~/nielong/curlTest/1getAndpost&gt; g++ main.cpp -o main</span><br><span class="line">main.cpp:2:23: fatal error: curl/curl.h: 没有那个文件或目录</span><br><span class="line"><span class="meta"> #</span><span class="bash">include &lt;curl/curl.h&gt;</span></span><br><span class="line">                       ^</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>
<p> 因为 <code>#include &lt;curl/curl.h&gt;</code>，而且在系统指定目录中找不到此文件。所以报以上错误。</p>
<p> 使用 <code>-I</code> 参数指定到上一级目录中查找头文件。（将 curl 文件夹拷贝到了上一级目录）</p>
</li>
<li><p><code>&gt; g++ main.cpp -o main -I ../</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl@linux-zds2:~&#x2F;nielong&#x2F;curlTest&#x2F;1getAndpost&gt; g++ main.cpp -o main -I ..&#x2F;</span><br><span class="line">main.cpp: In function ‘int main()’:</span><br><span class="line">main.cpp:53:28: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     getUrl(&quot;&#x2F;tmp&#x2F;get0.html&quot;);</span><br><span class="line">                            ^</span><br><span class="line">main.cpp:54:30: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     postUrl(&quot;&#x2F;tmp&#x2F;post0.html&quot;);</span><br><span class="line">                              ^</span><br><span class="line">&#x2F;tmp&#x2F;cc3fVgxs.o：在函数‘getUrl(char*)’中：</span><br><span class="line">main.cpp:(.text+0x4c)：对‘curl_slist_append’未定义的引用</span><br><span class="line">main.cpp:(.text+0x55)：对‘curl_easy_init’未定义的引用</span><br><span class="line">main.cpp:(.text+0x7e)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0x99)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0xb3)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0xcd)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0xd9)：对‘curl_easy_perform’未定义的引用</span><br><span class="line">main.cpp:(.text+0xee)：对‘curl_slist_free_all’未定义的引用</span><br><span class="line">main.cpp:(.text+0xfa)：对‘curl_easy_cleanup’未定义的引用</span><br><span class="line">&#x2F;tmp&#x2F;cc3fVgxs.o：在函数‘postUrl(char*)’中：</span><br><span class="line">main.cpp:(.text+0x14b)：对‘curl_easy_init’未定义的引用</span><br><span class="line">main.cpp:(.text+0x175)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0x190)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0x1ab)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0x1c5)：对‘curl_easy_setopt’未定义的引用</span><br><span class="line">main.cpp:(.text+0x1d1)：对‘curl_easy_perform’未定义的引用</span><br><span class="line">main.cpp:(.text+0x1e0)：对‘curl_easy_cleanup’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p> 报以上错误是因为动态链接库未指定，所以相关方法未定义。使用 <code>-l</code>（小写 L）指定 libcurl.so</p>
<p> 使用 <code>-l curl</code> 参数链接 .so 文件。（<code>-l curl</code> 会相对应的使用 libcurl.so 链接库，具体因果在后面详述）</p>
</li>
<li><p><code>&gt; g++ main.cpp -o main -I ../ -lcurl</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl@linux-zds2:~&#x2F;nielong&#x2F;curlTest&#x2F;1getAndpost&gt; g++ main.cpp -o main -I ..&#x2F; -lcurl</span><br><span class="line">main.cpp: In function ‘int main()’:                                                                                                   </span><br><span class="line">main.cpp:53:28: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]                                      </span><br><span class="line">     getUrl(&quot;&#x2F;tmp&#x2F;get0.html&quot;);                                                                                                        </span><br><span class="line">                            ^                                                                                                         </span><br><span class="line">main.cpp:54:30: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]                                      </span><br><span class="line">     postUrl(&quot;&#x2F;tmp&#x2F;post0.html&quot;);                                                                                                      </span><br><span class="line">                              ^                                                                                                       </span><br><span class="line">&#x2F;usr&#x2F;lib64&#x2F;gcc&#x2F;x86_64-suse-linux&#x2F;4.8&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-suse-linux&#x2F;bin&#x2F;ld: cannot find -lcurl                                         </span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p> 报错找不打 <code>-lcurl</code> 指定的 .so 文件，此为搜索路径问题。关于 <a href="http://blog.chinaunix.net/uid-354915-id-3573647.html">解决/usr/bin/ld: cannot find -lxxx 问题</a></p>
<p> 使用 <code>-L</code> 参数指定到上一级目录中查找 .so 文件。（在上一级目录创建了 usr/lib/libcurl.so.4.* 的软链接，<a href="/2017/03/20/ln-command/">软连接 &amp; 硬链接</a> 在后面详述）</p>
<p> 另外，使用 <code>-l xxx</code> 命令有一个细节，此命令需要放在 main.cpp 的后面。具体参照：<a href="http://bbs.chinaunix.net/thread-4096875-1-1.html">A</a> 、<a href="http://www.cnblogs.com/flyingchen/archive/2011/10/26/2225339.html">B</a></p>
</li>
<li><p><code>&gt; g++ main.cpp -o main -I ../ -lcurl -L ../ </code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl@linux-zds2:~&#x2F;nielong&#x2F;curlTest&#x2F;1getAndpost&gt; g++ main.cpp -o main -I ..&#x2F; -lcurl -L ..&#x2F;                                               </span><br><span class="line">main.cpp: In function ‘int main()’:                                                                                                   </span><br><span class="line">main.cpp:53:28: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     getUrl(&quot;&#x2F;tmp&#x2F;get0.html&quot;);</span><br><span class="line">                            ^</span><br><span class="line">main.cpp:54:30: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     postUrl(&quot;&#x2F;tmp&#x2F;post0.html&quot;);</span><br><span class="line">                              ^</span><br><span class="line">nl@linux-zds2:~&#x2F;nielong&#x2F;curlTest&#x2F;1getAndpost&gt; </span><br></pre></td></tr></table></figure>
<p> 搞定。</p>
</li>
</ol>
<h1 id="l-crul-怎么对应的-libcurl-so？"><a href="#l-crul-怎么对应的-libcurl-so？" class="headerlink" title="-l crul 怎么对应的 libcurl.so？"></a>-l crul 怎么对应的 libcurl.so？</h1><p>参考 <a href="/2016/12/09/library-static-dynamic/">链接库</a>。经过上面的介绍，再</p>
<h1 id="强调两点："><a href="#强调两点：" class="headerlink" title="强调两点："></a>强调两点：</h1><ol>
<li>预处理阶段处理头文件。所以，使用 <code>-I</code> 指定头文件路径时，仅仅作用在预处理阶段，在其后的编译、汇编、链接阶段不再需要 <code>-I</code> 指定头文件路径，因为经过预处理操作，预处理的结果中已包含各头文件。</li>
<li>链接阶段链接库。即，使用 <code>-L</code> 指定库路径时，作用于链接阶段，在预处理、编译、汇编阶段尚不需要 -L 指定库路径。</li>
</ol>
<h1 id="附录：gcc-g-常用的参数"><a href="#附录：gcc-g-常用的参数" class="headerlink" title="附录：gcc/g++常用的参数"></a>附录：gcc/g++常用的参数</h1><p>-IDir<br>指定额外的头文件搜索目录，编译器首先在Dir中寻找，然后按照常规的顺序搜索头文件。<br>-include file<br>相当于在源程序中添加头文件，相当于#include “file”。<br>-LDir<br>指定编译的时候编译器搜索的库路径。<br>-lLIBRARY<br>指定编译的时候使用的库。</p>
<hr>
<p>-E<br>只激活预处理功能。<br>-S<br>只激活预编译和编译功能。<br>-c<br>只激活预处理、编译和汇编功能。</p>
<hr>
<p>-shared<br>生成共享目标文件，通常用于建立共享库时使用。<br>-static<br>禁止使用共享库。</p>
<hr>
<p><strong>-w</strong><br>不生成任何警告信息。<br><strong>-Wall</strong><br>生成所有警告信息。使用它能够使GCC产生尽可能多的警告信息。并非全部。参考 <a href="http://blog.csdn.net/max__payne/article/details/2058898">GCC常用选项&amp;使用详解</a><br><strong>-Werror</strong><br>在发生警报时取消编译操作，即把报警当作是错误。<br>-C<br>在预处理的时候不删除注释信息，一般和-E联合使用，用于分析程序。<br>-M<br>生成文件的关联信息，包含目标文件生成所依赖的所有源代码。<br>-MM<br>和上面的一样，但是忽略头文件造成的依赖关系。<br>-MD、-MMD<br>对应和-M、-MM相同，只不过将输出输入到.d文件中去。</p>
<p>-D<br>一般Makefie里的 －DHAVE_CONFIG_H是作为CFLAGS参数传给gcc的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc [-c|-S|-E] [-std&#x3D;standard]</span><br><span class="line">    [-Dmacro[&#x3D;defn]...] [-Umacro]</span><br></pre></td></tr></table></figure>
<p>查man手册知，就是通过 gcc -DHAVE_CONFIG ， 定义了 HAVE_CONFIG_H 这个宏。<br>随手找了个bash的源码，截一段： ./lib/tilde/tilde.c bash源码中的源文件~~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if defined (HAVE_CONFIG_H)</span><br><span class="line">#  include &lt;config.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>而这里的 config.h 文件，是通过 configure 生成的，里面关于编译环境的一些宏。</p>
<p>通过 configure 检查出来的这些宏，在做跨平台时使用非常方便。</p>
<h1 id="GCC高级编译链接参数"><a href="#GCC高级编译链接参数" class="headerlink" title="GCC高级编译链接参数"></a><a href="http://blog.zheezes.com/senior-gcc-compiler-link-parameters.html">GCC高级编译链接参数</a></h1><ol>
<li>部分动态链接部分静态链接</li>
<li>设置动态链接 PATH</li>
</ol>
<p>两者都涉及到 <code>-wl</code> 参数，关于其使用的 <a href="http://stackoverflow.com/questions/6562403/i-dont-understand-wl-rpath-wl">注意事项</a>。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>develop</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 对错误的处理</title>
    <url>/2016/11/03/handing-errors/</url>
    <content><![CDATA[<p> 在项目开发中，非主体逻辑的部分在整体代码量中占得比重往往更大。比如我们做一个加减乘除计算器，需要处理用户输入非数字怎么办，数字太大溢出怎么办，零作为除数了怎么办等等；比如我们要读取配置文件中的用户名、密码，我们得首先处理配置文件不存在，内容格式不正确，用户名过长等等。</p>
<p>机器（具体说就是一门语言，比如 C++）是一板一眼的，你告诉它了它就能做，你没告诉的它就不知道。对机器来说不存在“常识”这个词。</p>
<blockquote>
<p>用 C++ 写代码的时候总是避免不了处理错误，一般来说有两种方式：通过函数的返回值 return code；抛出异常 exceptions。</p>
</blockquote>
<h1 id="使用返回值的缺点"><a href="#使用返回值的缺点" class="headerlink" title="使用返回值的缺点"></a>使用返回值的缺点</h1><p>从 C 语言过渡过来的开发者可能更习惯使用返回值。就我自己的开发经历（给某个风场使用 Labwindows/CVI 开发自动化采集软件）来说，使用返回值有四点很是不爽的地方：</p>
<a id="more"></a>

<ol>
<li><p>与业务真正的返回值混用，需要规定一个错误代码。比如我们用 <code>int statistics(int id)</code> 统计员工今天检测的样品数目，从业务角度来说返回值是非负数，所以可以使用负数作为错误代码——这就是“混用”。</p>
<p> 我们也可以强制改为 <code>int statistics(int id, int* count)</code>，严格限制返回值只能用于记录运行状态，而将统计结果置于参数列表中。这样又会引入新的问题：<del>输入参数、输出参数混用，且</del> 调用之前必须提前声明变量，而不能将声明和调用在同一条语句中执行。参考 <a href="https://www.byvoid.com/blog/cpp-constructor-exception">其他语言中的错误处理</a> 中 GO 语言</p>
</li>
<li><p>错误信息简陋。尤其是函数被调用后如果存在多种错误状态，单独使用错误码根据其不同的数值标识不同的状态，然后在调用函数中根据错误代码编辑并打印对应的错误信息，这是很不合理的：一方面调用函数和被调用函数很可能不是同一开发者，存在沟通成本；另一方面，即便是同一开发者，在存在多个调用函数的情况下，也可能出现同一错误代码打印的错误信息内容却不一致的尴尬。</p>
<p> 针对这一点不足，我们可以在每个被调用函数中再添一个输出参数，用于保存错误信息。比如 <code> int statistics(int id, int* count, std::string&amp; errinfo)</code>。这样做的问题，是针对每次调用我们都需要<strong>额外</strong>多使用一个字符串，而且同前者一样（比前者更甚），将错误处理方式和“执行逻辑”混在了一起：一方面都是使用控制流；另一方面，大多情况下还都是在同一控制流中。</p>
<p> <a href="https://isocpp.org/wiki/faq/exceptions#exceptions-avoid-two-return-types">exceptions simplify my function return type and parameter types.</a></p>
<p> <a href="https://isocpp.org/wiki/faq/exceptions#exceptions-separate-good-and-bad-path">exceptions separate the “good path” (or “happy path”) from the “bad path”.</a></p>
</li>
<li><p>每个可能产生错误的函数在调用后都需要判断是否有错误，一旦发生了不可解决的错误，就要终止当前函数（并释放当前函数申请的资源），然后向上<strong>传递错误</strong>。而且<strong>每个调用层</strong>都需要检查错误。代码会变得很丑陋。<a href="https://isocpp.org/wiki/faq/exceptions#exceptions-avoid-spreading-out-error-logic">This “error propagation” often needs to go through dozens of functions.</a></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;path/to/file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ERROR_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* <span class="built_in">array</span> = <span class="keyword">new</span>[n];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  err = do_something(fd, <span class="built_in">array</span>);</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = do_other_thing();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = do_more_thing();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func 的调用者还需要再次检查错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>开发过程中很容易忘记处理错误返回值，程序带着错误执行的不确定性。等程序宕掉的时候，可能距离错误源十万八千里远，调试起来老费劲了。</p>
</li>
</ol>
<p>实际上，上述只是涉及 <code>errorcode func(var1, var...)</code> 形式，更多：</p>
<ol>
<li>Error-codes as Return Values</li>
<li>Error-code as out-parameter</li>
<li>Error Singletons</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>到目前为止，除了学习异常时写过几个小的测试程序，对于异常并没有更多的认识。主要源于 google 编码规范中“禁止使用 C++ 异常”，以及有些大牛也不推荐使用异常（<a href="https://www.zhihu.com/question/22889420">参考</a>），所以下意识地对 <code>exception</code> 有些回避。</p>
<p>相比使用返回值的缺点，异常的优点有：</p>
<ol>
<li>程序逻辑和错误处理分离。</li>
<li>错误信息丰富，便于获得错误现场。我们可以自定义异常对象。</li>
<li>代码相对简短，不需要判断每个函数的返回值</li>
<li>开发者如果忘记处理异常，程序会直接宕掉。</li>
</ol>
<p>想获得上述优点，肯定要付出点代价。使用 <code>exception</code> 的开销相对较大。</p>
<p>写到这里，我自己突然很倾向使用异常了。但也不能盲目地将所有使用返回值的地方全部替换成异常，很可能使得<strong>控制流变得复杂，难以追踪</strong>。</p>
<blockquote>
<p>我的观点是，用异常来表示真正的、而且不太可能发生的错误。所谓不太可能发生的错误，指的是真正难以预料，但发生了却又不得不单独处理的，譬如内存耗尽、读文件发生故障。</p>
<p>一句话来概况就是<strong>不要用异常代替正常的控制流</strong>。只有当程序真的「不正常」的时候，才使用异常；反过来，当程序真正发生错误了，一定要使用异常而不是返回一个错误代码，因为错误代码总是倾向于被忽略。<a href="https://www.byvoid.com/blog/cpp-constructor-exception">引用来源</a></p>
</blockquote>
<p>C++ 标准的中的 <a href="https://isocpp.org/wiki/faq/exceptions">Exceptions and Error Handling</a></p>
<h1 id="构造函数中的错误"><a href="#构造函数中的错误" class="headerlink" title="构造函数中的错误"></a>构造函数中的错误</h1><p>接下来说说处理构造函数中的错误，通常有三种常见的处理方法：</p>
<blockquote>
<p>使用一个额外的 <code>initialize()</code> 函数来初始化；标记错误状态；或者直接抛出异常。</p>
</blockquote>
<ol>
<li>第一种方式，违背了对象产生和初始化要在一起的原则，强迫用户记住调用一个额外的初始化函数，一旦没有调用直接使用了其他函数，其行为很可能是未定义的。</li>
<li>标记状态的方法在实践中相当丑陋，因为在使用前总是需要判断它是否「真的创建成功了」。</li>
<li>最直接的方法还是在构造函数中抛出异常。构造函数抛出异常以后析构函数是不会被调用的，所以如果你在构造函数里面申请了内存或者打开了资源，需要在异常产生时关闭。</li>
</ol>
<p>如何在构造函数中捕获异常，语法方面具体怎么写可以参考原文，也请自行学习。</p>
<p>ps 整篇笔记主要参考自 <a href="https://www.byvoid.com/blog/cpp-constructor-exception">如何处理C++构造函数中的错误</a>，作者的专业知识值得肯定，但文字功底就不敢恭维了：有些描述起承转合很是僵硬，逻辑上毫无关系的两句话竟然用的逗号衔接，有些段落在文字顺序、排版上强加因果，误导读者。总之，文章很不错，如果读到某个地方觉得别扭，考虑重组语句，甚至重组段落。</p>
<h1 id="怎么用好-exception"><a href="#怎么用好-exception" class="headerlink" title="怎么用好 exception"></a>怎么用好 exception</h1><p>上述也就是在说 exception 的优缺点以及 exception 的必要性。可怎么样才是用好 exception，发挥了其优点，而非滥用、误用，放大了其缺点？仅仅知道其语法没甚意义。 </p>
<p><a href="https://isocpp.org/wiki/faq/exceptions#mindset-for-proper-use-of-eh">避免以下 mindset（观念模式/思维倾向）：</a></p>
<h1 id="std-expected"><a href="#std-expected" class="headerlink" title="std::expected"></a>std::expected</h1><p>错误处理的新方式。但其作为一项提案，截止到 2019 年 3 月尚未成为标准。</p>
<p><a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45">Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</a></p>
<ul>
<li>The return-codes mindset</li>
<li>The Java mindset</li>
<li>Organizing the exception classes around the physical thrower rather than the logical reason for the throw</li>
<li>Using the bits / data within an exception object to differentiate different categories of errors</li>
<li>Designing exception classes on a subsystem by subsystem basis</li>
<li>Use of raw (as opposed to smart) pointers</li>
<li>Confusing logical errors with runtime situations</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-idioms</category>
      </categories>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>《嗨翻C语言》（下）</title>
    <url>/2016/11/03/headFirstC-note2/</url>
    <content><![CDATA[<h1 id="动态存储（189-）"><a href="#动态存储（189-）" class="headerlink" title="动态存储（189~）"></a>动态存储（189~）</h1><ul>
<li><p>堆上的数据不会自动清除，因此堆是保存数据结构的绝佳场所。</p>
<blockquote>
<p>可以把在堆上保存数据想象成在储物柜中寄存物品。</p>
</blockquote>
</li>
<li><p>当程序不断地申请存储器，又不释放那些不再需要的存储器，就会发生<strong>存储器泄漏</strong>。</p>
<blockquote>
<p>创建数据不会发生泄漏，只有当程序失去了所有对数据的引用才会导致泄漏。    </p>
</blockquote>
</li>
<li><p>用<code>malloc()</code>获取空间，<em>memory allocation</em>；调用<code>free()</code>释放存储器</p>
<ul>
<li><code>malloc()</code>接收一个参数：所需要的字节数。因此<code>malloc()</code>经常与<code>sizeof</code>运算符一起使用。</li>
<li><code>malloc()</code>返回的是通用指针，即<code>void*</code>类型的指针。 </li>
</ul>
</li>
<li><p><code>strdup()</code>函数可以把字符串复制到堆上。</p>
<blockquote>
<p><code>strdup()</code>函数总是在堆上创建空间，而不是在栈上。所以千万记得要用<code>free()</code>函数释放空间。</p>
</blockquote>
</li>
<li><p><strong>valgrind</strong>工具，它用于Linux操作系统中。</p>
<blockquote>
<p>当程序想分配堆存储器时，valgrind将会拦截你对<code>malloc()</code>和<code>free()</code>的调用，然后调用自己的<code>malloc()</code>和<code>free()</code>。</p>
</blockquote>
</li>
<li><p>垃圾收集（garbage collection），一些语言会跟踪你在堆上分配的数据，当你不再使用这些数据时，就会释放它们。<strong>C语言没有“垃圾收集”</strong></p>
</li>
</ul>
<blockquote>
<p>虽然不必在程序结束前释放所有数据，操作系统会在程序结束时清除所有存储器。不过，你还是应该显式释放你创建的每样东西，这是一种好的习惯。</p>
</blockquote>
<p>——很不懂作者为什么在章节快结束的时候，放上一句这么没营养的话。有机会去查一查原文，确认是不是译者的问题。个人认为以下表述更恰当：<br>虽然<em>操作系统会在程序结束时清除所有存储器</em>。不过，你还是应该<strong>显式释放</strong>你创建的每样东西，这是一种好的习惯。</p>
<h1 id="高级函数（201-）"><a href="#高级函数（201-）" class="headerlink" title="高级函数（201~）"></a>高级函数（201~）</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>此章节介绍“学习如何把函数作为参数传递，从而提高代码的智商”。</p>
<p>有些时候，我们希望“把代码打包传给函数”。“把代码打包”就是封装成函数，所以，问题就是：怎么把函数传给函数?</p>
<ul>
<li><p>在C语言中，函数名也是指针变量。</p>
<blockquote>
<p>当你创建了一个叫<code>go_to_warp_speed(int speed)</code>函数的同时也会创建了一个叫<code>go_to_warp_speed</code>的指针变量，变量中保存了函数的地址。只要把函数指针类型的参数传给<code>find()</code>，就能调用它指向的函数了。</p>
</blockquote>
<p>  上述中<code>go_to_warp_speed</code>指针变量是一个常量。类似 <code>int* a=4</code>中的<code>4</code>, <code>char* str=&quot;abc&quot;</code>中的<code>&quot;abc&quot;</code>。</p>
<p>  扩展</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处声明时的*和 赋值操作时的*应不是同一个意思?!</span></span><br><span class="line"><span class="comment">那么为什么初始化不写成int* a=&amp;4?? —就是声明了一个指针,指向了常量存储区的一块地址 */</span></span><br><span class="line"><span class="keyword">int</span>* a;  <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">*a=<span class="number">4</span>;    <span class="comment">//改变指针指向存储器中的值,但单纯这么写是错的</span></span><br><span class="line">a=&amp;b;    <span class="comment">//给指针赋值,改变指针指向的存储器</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数名是指向函数的指针……两者并不完全相同，函数名是L-value，而指针变量是R-value，因此函数名不能像指针变量那样自加或自减。</p>
</li>
<li><p>函数指针是C语言最强大的特性之一。</p>
</li>
</ul>
<h3 id="函数指针的语法"><a href="#函数指针的语法" class="headerlink" title="函数指针的语法"></a>函数指针的语法</h3><ul>
<li><p>没有函数类型，即：不能用<code>function * pointer_func</code> 声明函数指针。</p>
</li>
<li><p>因为需要把函数的返回类型和接收参数类型告诉C编译器，所以创建函数指针如下：</p>
<blockquote>
<p>返回类型(* 指针变量)(参数类型)，例如</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*warp_fn)(<span class="keyword">int</span>);  <span class="comment">//创建函数指针</span></span><br><span class="line">wrap_fn = go_to_warp_speed;  <span class="comment">//函数指针赋值</span></span><br><span class="line">wrap_fn(<span class="number">4</span>);  <span class="comment">//使用函数指针</span></span><br></pre></td></tr></table></figure>
<p>Q1:如果函数指针是指针，为什么调用时不需要再它们前面加<code>*</code>？</p>
<p>A1:可加可不加。<code>wrap_fn(4)</code>和<code>(*wrap_fn)(4)</code>都可以。如果<code>fp</code>是函数指针，那么可以用<code>fp(参数，……)</code>调用函数。 也可以用<code>(*fp)(参数，……)</code>，两种情况都能工作。</p>
<p>Q2：可以用<code>&amp;</code>取得函数的地址吗？</p>
<p>A2：可以。<code>find(sports_or_workout)</code>和<code>find(&amp;sports_or_workout)</code>都可以。如果你有函数<code>shoot()</code>，那么<code>shoot</code>和<code>&amp;shoot</code>都指向了<code>shoot()</code>函数。</p>
<p>Q3：那为什么不这么写？</p>
<p>A3：即使省略<code>*</code>和<code>&amp;</code>，C编译器也能识别他们，（而且）这样代码更好读。</p>
</blockquote>
<p>  延伸：由A3推测，是不是 常量<code>4</code>或者<code>&quot;abc&quot;</code>既表示本身的值,又代表其在常量存储区的地址?此处亦类似?</p>
</li>
</ul>
<h3 id="C标准库的排序函数"><a href="#C标准库的排序函数" class="headerlink" title="C标准库的排序函数"></a>C标准库的排序函数</h3><ul>
<li>C标准库的排序函数会接收一个<strong>比较器函数（comparator function）指针</strong>，用来判断两条数据的大小。</li>
<li><code>qsort()</code>函数看起来像这样：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qsort(<span class="keyword">void</span>* <span class="built_in">array</span>,       <span class="comment">//数组指针</span></span><br><span class="line">      <span class="keyword">size_t</span> length,     <span class="comment">//数组长度</span></span><br><span class="line">      <span class="keyword">size_t</span> item_size,  <span class="comment">//数组中每个元素的长度</span></span><br><span class="line">      <span class="keyword">int</span> (*comparator)(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*));</span><br></pre></td></tr></table></figure></li>
<li><code>qsort()</code>函数在原数组上进行改动。</li>
</ul>
<h3 id="创建函数指针数组"><a href="#创建函数指针数组" class="headerlink" title="创建函数指针数组"></a>创建函数指针数组</h3><ul>
<li>在数组中保存函数，就必须告诉编译器函数的具体特征：函数返回什么类型以及接收什么参数。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (* replies[])(response) = &#123;dump, second_chance, marriage&#125;;</span><br></pre></td></tr></table></figure></li>
<li>函数指针数组让代码易于管理，它们让代码变得更短、更易于扩展，从而可以伸缩。<br>  ——至于说降低程序可读性,那是因为你笨。</li>
</ul>
<h2 id="可变参数函数（variadic-function）（228-）"><a href="#可变参数函数（variadic-function）（228-）" class="headerlink" title="可变参数函数（variadic function）（228~）"></a>可变参数函数（variadic function）（228~）</h2><p>C标准库中有一组宏（macro）可以帮助你建立自己的可变参数函数。<br>——TODO：kindle中描述这一组宏的图片看不清，抽空在网上找一下。</p>
<h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><p>（省略。在接触Linux下C++开发之后，这方面知识不算陌生。）</p>
<h1 id="系统调用（249-）"><a href="#系统调用（249-）" class="headerlink" title="系统调用（249~）"></a>系统调用（249~）</h1><p>在大部分计算机上，系统调用就是操作系统内核中的函数，是程序用来与内核对话的函数。</p>
<h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><ul>
<li><p>简单易用</p>
</li>
<li><p>安全问题</p>
</li>
<li><p>无法应付复杂的应用场景</p>
<blockquote>
<p>操作系统必须解释你传给 <code>system()</code>的字符串，这可能引发错误，尤其当你动态创建命令字符串时。</p>
</blockquote>
</li>
</ul>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><ul>
<li><p><code>exec()</code> 函数通过运行其他程序来<strong>替换</strong>当前进程。</p>
<ul>
<li><code>exec()</code>函数的版本众多，但可以分为两组：列表函数和数组函数。</li>
<li>如果<code>exec()</code>调用成功，当前程序就会停止运行。一旦程序运行了<code>exec()</code>以后的代码，就说明出了问题。</li>
</ul>
</li>
<li><p>每个进程都有一组环境变量。</p>
</li>
</ul>
<h2 id="失败黄金法则"><a href="#失败黄金法则" class="headerlink" title="失败黄金法则"></a>失败黄金法则</h2><ul>
<li><p>尽可能收拾残局</p>
</li>
<li><p>把<code>errno</code>变量设为错误码</p>
<ul>
<li><code>errno</code>变量是定义在<code>errno.h</code>中的全局变量，和它定义在一起的还有很多<strong>标准错误码</strong></li>
<li>可以使用<code>string.h</code>中<code>strerror()</code>函数查询<strong>标准错误信息</strong></li>
</ul>
</li>
<li><p>返回<code>-1</code></p>
<ul>
<li>系统调用出错时通常会返回<code>-1</code>，但不是绝对的。</li>
<li><code>fileno()</code>:根据文件指针获取文件描述符。失败时不返回<code>-1</code></li>
<li><code>exit()</code>是唯一没有返回值而且不会失败的函数。</li>
<li>记住：一定要检查系统调用的返回值</li>
</ul>
</li>
</ul>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><ul>
<li><p><code>fork()</code>会克隆当前进程</p>
<ul>
<li>新建副本将从同一行开始运行相同程序。</li>
<li>原进程叫父进程，而新建副本叫子进程。</li>
</ul>
</li>
<li><p>进程需要以某种方式区分自己是父进程还是子进程</p>
<blockquote>
<p><code>fork()</code>会返回一个整型值：为子进程返回<code>0</code>，为父进程返回一个正数。父进程将接收到子进程的进程标识符。</p>
</blockquote>
</li>
<li><p>与Unix和Mac不同，Windows天生不支持<code>fork()</code>。</p>
</li>
</ul>
<h1 id="进程间通信（274-）"><a href="#进程间通信（274-）" class="headerlink" title="进程间通信（274~）"></a>进程间通信（274~）</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li><p>三大默认数据流：标准输入、标准输出和标准错误；文件连接和网络连接也属于数据流。</p>
</li>
<li><p>进程需要记录数据流的连向，比如标准输出连到了哪里。进程用文件描述符（就是个数字）表示数据流</p>
</li>
<li><p><strong>描述符表</strong>：描述符表的前三项万年不变：0号标准输入，1号标准输出，2号标准错误</p>
<ul>
<li>标准输入/输出/错误在描述符表中的位置是固定的，但它们指向的数据流可以改变。</li>
<li>每打开一个文件，操作系统都会在描述符表中新注册一项</li>
</ul>
</li>
<li><p><code>dup2()</code>复制数据流</p>
</li>
<li><p><code>exit()</code>是系统调用！</p>
<blockquote>
<p><code>exit()</code>系统调用是结束程序的最快方式</p>
</blockquote>
</li>
<li><p><code>waitpid()</code>函数会等子进程结束以后才返回</p>
<ul>
<li>为了得到子进程的退出状态，可以把<code>pid_status</code>的值传给<code>WEXITSTATUS()</code>宏</li>
</ul>
</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul>
<li><p>在命令行用管道连接两条命令时，实际把它们当成了父子进程来连接。child | parent，详见<a href="http://linux.chinaunix.net/techdoc/develop/2008/02/21/979889.shtml">shell中管道的原理</a></p>
</li>
<li><p><code>pipe()</code>函数建立管道</p>
<blockquote>
<p><code>pipe()</code>函数创建了管道，并返回了两个描述符：<code>fd[1]</code>用来向管道写数据，<code>fd[0]</code>用来从管道读数据，</p>
</blockquote>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li>当信号到来时，进程必须停止手中一切工作去处理信号。进程会查看<strong>信号映射表</strong>，表中每个信号都对应一个信号处理器函数。</li>
</ul>
<h3 id="捕捉信号，然后运行自己的代码"><a href="#捕捉信号，然后运行自己的代码" class="headerlink" title="捕捉信号，然后运行自己的代码"></a>捕捉信号，然后运行自己的代码</h3><ul>
<li><code>sigaction</code>是一个函数包装器，是一个结构体。</li>
<li>创建<code>sigaction</code>以后，需要用<code>sigaction()</code>函数来让操作系统知道它的存在</li>
<li>有一个例外，代码捕捉不到<code>SIGKILL</code>信号，也没法忽略它</li>
<li>在自定义的信号处理函数中使用<code>raise()</code>，这样程序就能在接收到低级别的信号时引发更高级别的信号 </li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>不要同时使用<code>alarm()</code>和<code>sleep()</code>。两者都使用了间隔计时器，因此同时使用这两个函数会发生冲突。</p>
</li>
<li><p>一个进程只有一个定时器。因此每次调用<code>alarm()</code>函数都会重置定时器</p>
<blockquote>
<p>定时器由操作系统的内核管理，如果一个进程有很多定时器，内核就会变得很慢，因此操作系统需要限制进程能使用的定时器个数。</p>
</blockquote>
</li>
<li><p>信号可以让程序从容结束，而间隔定时器可以帮助处理一些超时任务。</p>
</li>
</ul>
<h1 id="网络编程（323-）"><a href="#网络编程（323-）" class="headerlink" title="网络编程（323~）"></a>网络编程（323~）</h1><p>C程序用数据流读写字节。如果想要写一个与网络通信的程序，就需要一种新数据流——套接字。</p>
<ul>
<li><p>在使用<strong>套接字</strong>与客户端程序通信前，服务器需要经历四个阶段：</p>
<ol>
<li><p>绑定（Bind）</p>
<ul>
<li>为了绑定它（端口），你需要两样东西：套接字描述符（还记得“文件描述符”吗？）和套接字名。</li>
</ul>
</li>
<li><p>监听（Listen）</p>
</li>
<li><p>接受（Accept）</p>
</li>
<li><p>开始（Begin）</p>
</li>
</ol>
</li>
<li><p>之前见过的数据流都可以用<code>fprintf()</code>和<code>fscanf()</code>与它们通信。但套接字是双向的：</p>
<ul>
<li>如果想向套接字输出数据，就要用<code>send()</code>函数；</li>
<li><code>recv()</code>函数；</li>
</ul>
</li>
<li><p>绑定端口有延时：当你在某个端口绑定了套接字，在接下来的30秒内，操作系统不允许任何程序再绑定它，包括上一次绑定这个端口的程序。</p>
</li>
<li><p><code>recv()</code>读取数据</p>
<ul>
<li>字符串不以<code>\0</code>结尾。 </li>
<li>当用户在telnet输入文本时，字符串以<code>\r\n</code>结尾。 </li>
<li><code>recv()</code>将返回字符个数，如果发生错误就返回<code>-1</code>，如果客户端关闭了连接，就返回<code>0</code>。 </li>
<li><code>recv()</code>调用不一定能一次接收到所有字符。</li>
<li><code>revc()</code>用起来十分繁琐，最好把它<strong>封装</strong>在某个函数中</li>
</ul>
</li>
<li><p><code>getaddrinfo()</code>获取域名的地址</p>
<ul>
<li><code>getaddrinfo()</code>会在堆上创建一种叫名字资源的新数据结构</li>
<li>因为名字资源在堆上创建，所以要用一个叫<code>freeaddrinfo()</code>的函数清除它</li>
</ul>
</li>
</ul>
<h1 id="多线程（342-）"><a href="#多线程（342-）" class="headerlink" title="多线程（342~）"></a>多线程（342~）</h1><p>你可以使用很多线程库，这里我们将使用最流行的一种：POSIX线程库，也叫pthread。</p>
<ul>
<li><p>线程函数的返回类型必须是<code>void*</code>。</p>
</li>
<li><p>可以用<code>pthread_create()</code>创建并运行线程。</p>
</li>
<li><p>如果程序运行完这段代码就结束了，线程也会随之灭亡，因此必须等待线程结束：</p>
<ul>
<li><code>pthread_join()</code>会接收线程函数的返回值，并把它保存在一个<code>void</code>指针变量中</li>
</ul>
</li>
<li><p>通常当两个线程读写相同变量时，代码就是非线程安全的。</p>
</li>
<li><p><code>PTHREAD_MUTEX_INITIALIZER</code>实际上是一个宏，当编译器看到它，就会插入创建互斥锁的代码。</p>
</li>
<li><p>如果你希望把某个整型值传给线程，并让它返回某个整型值，一种方法是：</p>
<ul>
<li>用<code>long</code>，因为它的大小和<code>void</code>指针相同，可以把它保存在<code>void</code>指针变量中</li>
</ul>
</li>
</ul>
<blockquote>
<p>问：怎样设计高效的多线程程序？ 答：减少线程需要访问的共享数据的数量。</p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>另一种理解思路：</p>
<ul>
<li><p>C语言允许你创建只能在函数局部作用域访问的全局变量：</p>
<ul>
<li>函数内：<code>static</code>关键字会把变量保存在存储器中的全局量区。</li>
</ul>
</li>
<li><p><code>static</code>关键字用来控制变量或函数的作用域</p>
<ul>
<li>函数外使用<code>static</code>关键字，表示“只有这个.c文件中的代码能使用这个变量（或函数）”</li>
</ul>
</li>
</ul>
<p>关于“自动化测试”，你又了解多少？</p>
<p>之前读书时做的笔记全部誊抄、整理完毕，上篇中的知识点基本都已熟悉掌握，下篇的内容因为学校时练习不多，实际做项目经验也很少，所以只处于了解、知道的层次，<strong>勤复习，多练习</strong>。笔记内容包含编程过程中的“为什么这样”，也包括一些具体的语法细节、函数使用（实际上后者是不应该杂糅到一起的，但是基础太差）。在以后的复习、练习过程中，争取将语法细节、函数使用这些具体化的内容一点点去掉。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么写头文件：内部链接、外部链接</title>
    <url>/2016/08/13/headfile/</url>
    <content><![CDATA[<p>由内部链接、外部链接引出怎么写头文件。</p>
<p>我看了一下，这篇笔记最早是在六月二号创建的，可是现在 2016/8/13 16:12:05 ，呵呵。一方面是自己懒，另一方面，对于“内部链接、外部链接”的概念，不多了解一些，不敢随便整理啊。</p>
<p>我们先看看 <a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">维基百科- 头文件</a> 中说了什么：</p>
<blockquote>
<p>当一个子程序在定义的位置以外的地方被使用时，就需要进行<strong>前置声明</strong>，声明函数原型等。</p>
</blockquote>
<p>假设一个程序员不用“头文件”，那么他至少需要在两个地方维护函数的声明：一个是包含函数实现的的文件，以及使用该函数的文件。如果使用该函数的文件有很多个，那么对函数的定义进行更改时就是灾难。</p>
<p>从某个方面来说，头文件降低了这种场景中程序员手工操作的复杂度（解放双手，繁琐的工作交给机器/编译器）。更重要的是保证了编写大型项目的易用性，难以想象如果没有头文件，几十万行的代码全都在一个源文件中。</p>
<p>将函数原型移到 XXX 头文件中之后，我们可以在需要的地方通过 <code>#include &lt;XXX&gt;</code> <em>预处理器指令</em> 将其包含进来，这样每次编译时预处理阶段就会将 XXX 文件中的内容替换掉 <code>#include &lt;XXX&gt;</code> ，我们的函数原型也就被“前置声明”了。</p>
<p>阅读 <a href="https://en.wikipedia.org/wiki/Include_directive">wikipedia - include derective</a>，我们可以从更高的层次考虑 Include 行为，想想 Makefile 中的 include，shell 脚本中的 include，表示类似甚至同样意义的关键字还有 import、copy。</p>
<p>在 C 语言中，什么内容需要放在头文件中，什么内容可以放在头文件中相对来说是比较容易区分的。接下来我们看看在 C++ 中，什么东西可以放在 .h 文件中，什么不能，什么东西又可以放在 .cpp 文件中。</p>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>首先需要区分开这两个概念，只是理解所有关键问题的前提。在笔记中暂时不展开说了，如果分不清楚，自行 Google。这里只备注几个容易混淆的条目：</p>
<ul>
<li><p>声明</p>
<ol>
<li><p>仅仅提供函数原型。类外面的，类里面的</p>
</li>
<li><p>class A；</p>
</li>
<li><p>typedef声明</p>
</li>
<li><p>在类中定义的静态数据成员的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义</p>
<ol>
<li><p>在类定义之外，定义并初始化一个静态数据成员。如 A::a=0;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A::a=<span class="number">0</span>；  <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li>
<li><p>在类外定义非内联成员函数</p>
</li>
</ol>
</li>
</ul>
<h1 id="内部链接和外部链接"><a href="#内部链接和外部链接" class="headerlink" title="内部链接和外部链接"></a>内部链接和外部链接</h1><p>参考自：<a href="http://blog.csdn.net/ithzhang/article/details/8119286">参考链接1</a>、<a href="http://developer.51cto.com/art/201107/277364.htm">解析C++中的内部连接与外部连接</a></p>
<p>链接把不同编译单元产生的符号联系起来。有两种链接方式：内部链接和外部链接。</p>
<h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><p>如果一个符号名对于它的编译单元来说是局部的，并且在链接时不可能与其他编译单元中的同样的名称相冲突，那个这个符号就是内部链接。内部链接意味着对此符号的访问仅限于当前的编译单元中，对其他编译单元都是不可见的。</p>
<p>具有内部链接的符号无法作用于当前文件外部，要让其影响程序的其他部分，可以将其放在.h文件中。此时在所有包含此.h文件的源文件都有自己的定义且互不影响。</p>
<ol start="0">
<li><p>所有的声明，包括类的声明，比如：<code>class A;</code>；(有时也将声明看作是无连接的，这里我们统一看成是内部连接的)。</p>
<p> 由于声明只对当前编译单元有用，因此声明并不将任何东西写入.o文件。</p>
<p> 这些声明<strong>本身</strong>不会影响到.o文件的内容。在编译阶段（狭义的，从高级语言到汇编语言到二进制，从 main.i 到 main.o，预处理已过，尚未链接），编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会报错。链接阶段，声明已经没有用了。</p>
<p> 而函数调用会导致一个未定义的符号被写入到.o文件，此后此.o文件与定义此符号的.o文件被连接在一起，前面未定义的符号被解析。</p>
</li>
<li><p>局部变量肯定是内部链接性质的，更应该被看作无连接的；</p>
</li>
<li><p>全局变量，如果使用了 static、const 关键词修饰，其作用域仅仅在当前文件作用域内，其他文件中即使使用extern声明也是无法使用的。因此，带有 static、const 关键字的全局变量也是内部链接性质的；</p>
<p> static 和 const 还是有区别的。static 和 extern不能对同一个变量同时声明；但 const 和 extern 不是同一存储类别，可以同时用在同一个变量的声明。所以，我们可以用使用extern关键字修改const的连接属性。<a href="http://www.cnblogs.com/wangpei0522/p/4459624.html">更多详情</a>、<a href="http://blog.csdn.net/xiexievv/article/details/8491494">特别说明</a></p>
</li>
<li><p>枚举 enum、联合 union 类型是内部链接性质的；</p>
</li>
<li><p><strong>类的定义</strong>是内部链接性质的：</p>
<ul>
<li><p>定义，意味着在同一编译单元中不能重复出现；</p>
</li>
<li><p>内部链接性质，意味着如果需要在其他编译单元使用，类必须被定义在头文件且被其他文件包含。</p>
<p>  仅仅在其他文件中使用class a;声明是不行的，原因就是类的定义是内部链接，不会在目标文件导出符号。也就不会被其他单元解析它们的未定义符号。</p>
</li>
</ul>
</li>
<li><p>内联函数定义（包括自由函数和非自由函数）。</p>
<p> 内联函数之所有具有内部链接，因为编译器在可能的时候，会将所有 对函数的调用替换为函数体，不将任何符号写入.o文件。</p>
</li>
<li><p>名字空间(包括全局名字空间)中的静态自由函数、静态友元函数、静态变量的定义。<a href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
</li>
</ol>
<h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p>在一个多文件的程序中，如果一个符号在链接时可以和其他编译单元交互，那么这个名称就有外部链接。外部链接意味着该定义不仅仅局限在单个编译单元中。它可以在.o文件中产生外部符号。可以被其他编译单元访问用来解析它们未定义的符号。因此它们在整个程序中必须是唯一的，否则将会导致重复定义。</p>
<p><strong>区分：</strong>判断一个符号是内部链接还是外部链接的一个很好的方法就是看该符号是否被写入.o文件。</p>
<ol>
<li><p>类非内联成员函数，包括类成员函数和类静态成员函数</p>
</li>
<li><p>类的静态数据成员的定义具有外部链接性质</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 内部链接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::a = <span class="number">0</span>;  <span class="comment">// 外部链接</span></span><br></pre></td></tr></table></figure></li>
<li><p>非内联函数</p>
</li>
<li><p>名字空间(包括全局名字空间)中非静态自由函数、非静态友元函数及非静态变量。<a href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
<p> 前提是认为，类之外一般不存在使用 inline 修饰的函数。</p>
</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a href="http://www.52rd.com/Blog/Detail_RD.Blog_imjacob_5682.html">摘抄来源</a></p>
<p>Linkage</p>
<p>To understand the behavior of C and C++ programs, you need to know about linkage. In an executing program, an identifier is represented by storage in memory that holds a variable or a compiled function body. Linkage describes this storage as it is seen by the linker. There are two types of linkage: internal linkage and external linkage.</p>
<p>Internal linkage means that storage is created to represent the identifier only for the file being compiled. Other files may use the same identifier name with internal linkage, or for a global variable, and no conflicts will be found by the linker – separate storage is created for each identifier. Internal linkage is specified by the keyword static in C and C++.</p>
<p>External linkage means that a single piece of storage is created to represent the identifier for all files being compiled. The storage is created once, and the linker must resolve all other references to that storage. Global variables and function names have external linkage. These are accessed from other files by declaring them with the keyword extern. Variables defined outside all functions (with the exception of const in C++) and function definitions default to external linkage. You can specifically force them to have internal linkage using the static keyword. You can explicitly state that an identifier has external linkage by defining it with the extern keyword. Defining a variable or function with extern is not necessary in C, but it is sometimes necessary for const in C++.</p>
<p>Automatic (local) variables exist only temporarily, on the stack, while a function is being called. The linker doesn’t know about automatic variables, and so these have no linkage.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>综上，我们可以知道：将具有外部链接的定义放在头文件中几乎都是编程错误。因为如果该头文件中被多个源文件包含，那么就会存在多个定义，链接时就会出错。</p>
<p>在头文件中放置内部链接的定义却是合法的，但不推荐使用的。</p>
<p>链接，本质上都是具有<strong>外部链接性质的符号们</strong>的事情！</p>
<h2 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h2><p>头文件为相关声明提供了一个集中存放的位置。头文件一般包含类的定义、枚举的定义、extern变量的声明、函数的声明、const int的定义、inline函数的定义。使用或者定义这些实体的文件要包含适当的头文件。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>linux 常见的应用安装方式</title>
    <url>/2017/03/17/how-to-install-applications-1/</url>
    <content><![CDATA[<p>来自：<a href="http://blog.chinaunix.net/uid-24612962-id-3181499.html">http://blog.chinaunix.net/uid-24612962-id-3181499.html</a></p>
<h1 id="安装包类型"><a href="#安装包类型" class="headerlink" title="安装包类型"></a>安装包类型</h1><p>解析Linux应用软件安装包，通常Linux应用软件的安装包有四种：</p>
<ol>
<li><strong>tar</strong> 包，如 software-1.2.3-1.tar.gz。它是使用 UNIX 系统的打包工具 tar 打包的。 </li>
<li><strong>rpm</strong> 包，如 software-1.2.3-1.i386.rpm。它是 Redhat Linux 提供的一种包封装格式。 </li>
<li><strong>dpkg</strong> 包，如 software-1.2.3-1.deb。它是 Debain Linux 提供的一种包封装格式。 </li>
<li><strong>bin</strong> 包，如 jdk-1_5_0_05-linux-i586.bin，有些 Linux 软件不公开源代码，只发布二进制可执行程序，这类程序一般会以 bin 来标记。 </li>
</ol>
<a id="more"></a>

<p>而且，大多数 Linux 应用软件包的命名也有一定的规律，它遵循：名称-版本-修正版-类型。例如：</p>
<table>
<thead>
<tr>
<th>安装包名</th>
<th>软件名称</th>
<th>版本号</th>
<th>修正版本号</th>
<th>可用平台</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>software-1.2.3-1.tar.gz</td>
<td>software</td>
<td>1.2.3</td>
<td>1</td>
<td></td>
<td>tar.gz，说明是个 tar 包。</td>
</tr>
<tr>
<td>software-1.2.3-1.i386.rpm</td>
<td>software</td>
<td>1.2.3</td>
<td>1</td>
<td>i386，适用于 Intel 80x86 平台。</td>
<td>rpm，说明是个 rpm 包。</td>
</tr>
</tbody></table>
<p>注：由于rpm格式的通常是已编译的程式，所以需指明平台。</p>
<h2 id="了解包里的内容"><a href="#了解包里的内容" class="headerlink" title="了解包里的内容"></a>了解包里的内容</h2><p>一个 Linux 应用程式的软件包中能包含两种不同的内容：</p>
<ol>
<li>一种就是<strong>可执行文件</strong>，也就是解开包后就能直接运行的。在视窗系统中所 有的软件包都是这种类型。安装完这个程式后，你就能使用，但你看不到源程式。而且下载时要注意这个软件是否是你所使用的平台，否则将无法正常安装。</li>
<li>另一种则是<strong>源程式</strong>，也就解开包后，你还需要使用编译器将其编译成为可执行文件。这在视窗系统系统中是几乎没有的，因为视窗系统的思想是不开放源程式的。 </li>
</ol>
<p>通常，用 <strong>tar 打包的，都是源程式</strong>；而用 <strong>rpm、bin、dpkg 打包的则常是可执行程式</strong>。一般来说，自己动手编译源程式能够更具灵活性，但也容易遇见各种问题和困难。而相对来说，下载那些可执行程式包，反而是更容易完成软件的安装，当然那样灵活性就差多了。所以一般一个软件总会提供多种打包格式的安装程式的。你能根据自己的情况来选择。</p>
<h1 id="使用-tar-打包的应用软件"><a href="#使用-tar-打包的应用软件" class="headerlink" title="使用 tar 打包的应用软件"></a>使用 tar 打包的应用软件</h1><p>搞定使用 tar.gz(bz 或 bz2 等)打包的应用软件，这种软件包里面都是源程序，没有编译过，需要编译后才能安装。 </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>整个安装过程能分为以下几步：</p>
<ol>
<li>取得应用软件：通过下载、购买光盘的方法获得； </li>
<li>解压缩文件：一般 tar 包，都会再做一次压缩，如 gzip、bz2 等，所以你需要先解压。如果是最常见的 gz 格式，则能执行：<code>tar -xvzf 软件包名</code>，就能一步完成解压和解包工作。如果不是，则先用解压软件，再执行 <code>tar -xvf 解压后的tar包</code> 进行解包； </li>
<li>阅读附带的 INSTALL 文件、README 文件； </li>
<li>执行 <code>./configure</code> 命令为编译做好准备； </li>
<li>执行 <code>make</code> 命令进行软件编译； </li>
<li>执行 <code>make install</code> 完成安装； </li>
<li>执行 <code>make clean</code> 删除安装时产生的临时文件。 </li>
</ol>
<p>好了，到此大功告成。我们就能运行应用程式了。但这时，有的读者就会问，我怎么执行呢？这也是个 Linux 特色的问题。其实，一般来说，Linux 的应用软件的可执行文件会存放在 /usr/local/bin 目录下！不过这并不是“放四海皆准”的真理，最可靠的还是看这个软件的 INSTALL 和 README 文件，一般都会有说明。</p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ol>
<li>打开一个 SHELL，即终端 </li>
<li>用 <code>cd</code> 命令进入配置后的软件目录，即安装时的目录 </li>
<li>执行反安装命令：<code>make uninstall</code></li>
</ol>
<p>安装目录：留意 <code>make install</code> 命令过程中的安装目录，或者阅读安装目录里面的 README 文件，当然最好的办法是在安装的过程中指定安装目录，即在 <code>./configure</code> 命令后面加参数 <code>--prefix=/**</code>，<br>如： <code>./configure --prefix=/usr/local/aaaa</code> 即把软件装在 /usr/local/ 路径的 aaaa 这个目录里。一般的软件的默认安装目录在 /usr/local 或者 /opt 里，可以到那里去找找。</p>
<p>注：通常软件的研发者非常少考虑到怎么卸载自己的软件，而 tar 又仅是完成打包的工作，所以并没有提供良好的卸载方法。那么是不是说就不能够卸载呢！其实也不是，有两个软件能够解决这个问题，那就是 Kinstall 和 Kife，它们是 tar 包安装、卸载的黄金搭档。</p>
<h1 id="使用-rpm-打包的应用软件"><a href="#使用-rpm-打包的应用软件" class="headerlink" title="使用 rpm 打包的应用软件"></a>使用 rpm 打包的应用软件</h1><p>rpm 可谓是 Redhat 公司的一大贡献，它使 Linux 的软件安装工作变得更加简单容易。 </p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>rpm -ivh 软件包名</code>，更高级的，请见下表：</p>
<table>
<thead>
<tr>
<th>rpm 参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>安装软件</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>测试安装，不是真的安装</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>显示安装进度</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>忽略所有错误</td>
</tr>
<tr>
<td><code>-U</code></td>
<td>升级安装</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>检测套件是否正确安装</td>
</tr>
</tbody></table>
<p>这些参数能同时采用。更多的内容能参考RPM的命令帮助。</p>
<h2 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h2><p><code>rpm -e 软件名</code>，不过要注意的是，后面使用的是软件名，而不是软件包名。</p>
<p>例如，要安装 software-1.2.3-1.i386.rpm 这个包时，应执行：<code>rpm -ivh software-1.2.3-1.i386.rpm </code>，而当卸载时，则应执行：<code>rpm -e software</code>。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看安装了哪些软件 <code>rpm -qa |grep MYSQL</code></p>
<h1 id="使用-deb-打包的应用程式"><a href="#使用-deb-打包的应用程式" class="headerlink" title="使用 deb 打包的应用程式"></a>使用 deb 打包的应用程式</h1><p>这是 Debian Linux 提供的一个包管理器，它和 RPM 十分类似。但由于 RPM 出现得更早，所以在各种版本的 Linux 都常见到。而 debian 的包管理器 dpkg 则只出目前 Debina Linux 中，其它 Linux 版<br>本一般都没有。我们在此就简单地说明一下：</p>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><p><code>dpkg -i deb软件包名</code>，如：<code>dpkg -i software-1.2.3-1.deb</code></p>
<h2 id="卸载-2"><a href="#卸载-2" class="headerlink" title="卸载"></a>卸载</h2><p><code>dpkg -e 软件名</code>，如：<code>dpkg -e software</code></p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><blockquote>
<p>虽然我们在使用 dpkg 时，已经解决掉了 软件安装过程中的大量问题，但是当依赖关系不满足时，仍然需要手动解决，而 apt 这个工具解决了这样的问题，linux distribution 先将软件放置到对应的服务器中，然后分析软件的依赖关系，并且记录下来，然后当客户端有安装软件需求时，通过清单列表与本地的 dpkg 以存在的软件数据相比较，就能从网络端获取所有需要的具有依赖属性的软件了。<a href="https://segmentfault.com/a/1190000011463440">引用来源</a></p>
</blockquote>
<h1 id="bin-文件"><a href="#bin-文件" class="headerlink" title="bin 文件"></a>bin 文件</h1><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><ol>
<li>打开一个 SHELL，即终端 </li>
<li>用 <code>cd</code> 命令进入源代码压缩包所在的目录 </li>
<li>给文件加上可执行权限：<code>chmod +x ******.bin</code>（中间是字母 <code>x</code>，小写） </li>
<li>执行命令：<code>./******.bin</code>(realplayer for linux 就是这样的安装包)，执行安装过程中可以指定安装目录，类似于 Windows 下安装。</li>
</ol>
<h2 id="卸载-3"><a href="#卸载-3" class="headerlink" title="卸载"></a>卸载</h2><p>把安装时选择的安装目录删除就 OK</p>
<h1 id="执行软件"><a href="#执行软件" class="headerlink" title="执行软件"></a>执行软件</h1><p>安装完软件后如何执行。安装完软件后可以有好多种方法执行软件：</p>
<ol>
<li>有些软件安装后会自动在应用程序列表里加上快捷链接，和 Windows 一样，到那里找就行了。 </li>
<li>如果在应用程序列表里找不到的话，可以直接在 开始/运行命令 里输入命令。启动命令一般就是软件名，如 firefox、realplay、xmms 等。 </li>
<li>也可以打开一个 shell 终端，输入软件名，和在“运行命令”里一样。如果不知道命令全称的话，可以输入开头的字母，然后按 tab 键查找，系统会自动显示以输入字母开头的所有命令。</li>
<li>你也可以直接到安装目录下运行启动文件，Linux 下的可执行图标和 shell 终端图标很像。 </li>
<li>到 /usr/bin 目录里寻找。Linux 系统在 /usr/bin 目录里为所有可执行文件都作了启动连接，你可以去那个目录寻找你安装的文件的启动命令，双击启动。</li>
</ol>
<h1 id="rpm-bin-与-bin-文件的区别"><a href="#rpm-bin-与-bin-文件的区别" class="headerlink" title="rpm.bin 与 bin 文件的区别"></a>rpm.bin 与 bin 文件的区别</h1><ol>
<li>用 bin 文件和用 windows 的 exe 一样 </li>
<li>rpm 就像 rar 不管愿意与否，都解在同一个地方，好的是只用点确定。 </li>
<li>有些 Linux 软件不公开源代码，只发布二进制可执行程序，这类程序一般会以 bin 来标记； </li>
<li>另一类软件是二进制安装程序和源代码一起发布，二进制程序文件以 bin.rpm 标记（以 RedHat 包为例），源代码以 source.rpm 标记。 </li>
<li>bin 是可以直接运行的二进制文件，rpm 是红帽公司用的软件包管理器，一般来说，双击也可以直接安装，不过只限于支持 RPM 的发行版，如红帽等。Ubuntu 就不可以，它支持 deb 包 </li>
<li>jdk-1_5_0_16-linux-i586-rpm.bin 运行后会解压出来一个 rpm 包，可用 <code>rpm -iUh</code> 命令安装。 </li>
<li>jdk-1_5_0_16-linux-i586.bin 运行后会直接把所有文件解压到当前目录的 jdk 子目录下。</li>
</ol>
<p>来自：<a href="http://blog.chinaunix.net/uid-24612962-id-3181499.html">http://blog.chinaunix.net/uid-24612962-id-3181499.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux 安装应用</title>
    <url>/2017/03/17/how-to-install-applications/</url>
    <content><![CDATA[<p>2015年12月31日 17:10:54</p>
<p>linux distribution 是 Linux 发行版。其实 Linux 是指的系统的内核，不能认为是一个系统。有人在内核的基础上增加一些软件，就成了一个操作系统了。这个系统因为以 Linux 为内核，所有就叫 Linux 发行版。大部分人为了简单，所以把发行版省掉了，实际上没有 Linux 这个操作系统，因为它只是个内核。现在出现 Linux 这一称呼，实际上是 Linux 发行版。这是正规的说法。</p>
<p><a href="http://blog.csdn.net/sftxlin/article/details/45722229">学linux，不用必须使用linux的图形界面</a>，这个也是我接触 Debian、SUSE 一两个月之后的想法。为什么在 linux 上必须使用图形界面呢？X-Window 对资源的消耗不比 windows 小，贪图界面为什么不用windows 呢，装 B 吗</p>
<a id="more"></a>

<h1 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h1><p>了解 <a href="http://bbs.csdn.net/topics/390138640">各发行版的定位</a>，按照发行版的定位去使用 Linux 和安装软件。Linux 下应用软件的几种 <a href="https://tnie.github.io/2017/03/17/how-to-install-applications-1/">常见安装方式</a>，可以通过 rpm、dpkg 等包管理器安装，也可以通过 tar 包、bin 包等源码或者可执行程序安装。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">软件包管理器</a> 既可以连接互联网在线安装，也可以使用包管理器线下安装 rpm 软件包、deb 软件包等。使用软件包管理系统将大大简化在 Linux 发行版中安装软件的过程。在线安装时，配置安全可靠的源很重要。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/LinuxDistributions.png" alt="来源：Linux发行版.mmap"></p>
<p><a href="https://github.com/tnie/MarkdownPhotos/raw/master/mmap/Linux%20%E5%8F%91%E8%A1%8C%E7%89%88.mmap">附件下载：Linux发行版.mmap</a></p>
<h1 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a><a href="https://www.debian.org/">Debian</a></h1><p>初次正式了解 Linux 时（Now）我选择了 Debian，不细究当初种种了。在所知无几的情况下，重要的是赶紧行动，进入 Linux 的世界，而不是强迫性地反复思考，无穷地分析，然后去做选择。</p>
<p>最初是在 X240 上安装有 win10 的前提下安装了 Debian8.1 双系统（最初磁盘分区时就留有空间），后来新入职有办公笔记本 E431 之后，就很少使用 X240 进行专业方面的操作了，基本上是一个娱乐的玩意。在 E431 安装双系统是不现实的，所以就在虚拟机中安装了 Debian。备注，工作使用的是 SLES10，太老的版本了。</p>
<p>结论：对于新入门的上班族，建议还是使用虚拟机；如果是学生，估计可以死磕 Linux。整体来讲，建议通过虚拟机对 Linux 安装、常用命令、安装卸载应用熟悉到一定程度之后再行用物理机操作。</p>
<p>截至 2016/3/14 16:01:03 ，Debian 最新的稳定版 （stable release） 版本是 8.3。</p>
<h2 id="安装应用（apt-get）"><a href="#安装应用（apt-get）" class="headerlink" title="安装应用（apt-get）"></a>安装应用（apt-get）</h2><p>2019/5/5 14:40:43 更新：新时代的 <code>apt</code> 命令，<a href="https://www.sysgeek.cn/apt-vs-apt-get/">Linux 中 apt 与 apt-get 命令的区别与解释</a></p>
<p>刚做好系统之后，怎么安装应用？好慌啊，不知道怎么办。</p>
<p>好折腾了大半天，因为需要配置安全可靠的源。安全！可靠！在大陆上网什么最蛋疼？墙啊，是墙啊。当年开发 Android，搭建环境折腾两三天，发现是墙；如今想用谷歌，用 Kindle 插件，用 Chrome 浏览器，用插件，得找梯子；到了要装 Linux 了，发现在 Debian 官方的源也被禁了。妥妥的局域网啊，<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">防火长城</a> 你就不怕墙里先烧起来啊，话说墙外想进来貌似也得翻，无语。</p>
<p>ps：如果是在国外的（比如 Bandwagon）服务器上，就不需要人工修改配置源，使用默认的（即官方的）即可。</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>所谓配置软件源，其实就是修改 /etc/apt/source.list 文件，按照规定格式指定和系统版本相匹配的用来安装、更新应用的远程软件仓库。刚做好系统之后，是有一个默认的官方源的。</p>
<p>即便不懂 <a href="http://www.cnblogs.com/beanmoon/p/3387652.html">source.list 的文件格式</a>，影响也不是很大，你完全可以从网上下载完整的文件替换（替换之前做好备份），或者直接拷贝覆盖原有的文件内容。但链接的帖子还是值得一看的，比如高版本 Debian 使用低版本 source.list，就会遇到很多软件依赖问题无法解决。所以看到这个问题，就需要考虑更换/更新 souce 源了。</p>
<p>在 <a href="http://forum.ubuntu.org.cn/viewtopic.php?t=366506">Debian、Ubuntu 源列表说明</a> 这篇帖子中提到的源我依次试用，都会报安全证书之类的错误，列在这里作为参考。</p>
<p><a href="http://guanglin.blog.51cto.com/3038587/1689670">国内</a> 用着还凑合的源有 <a href="http://mirrors.163.com/.help/debian.html">网易</a> 的、<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/debian">中科大</a> 的，配置时首先要注意的就是版本，像是中科大 debian 首页给出的示例中，</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ustc-stable.png" alt="ustc-stable"></p>
<p>使用“stable”作为版本标识是很不建议的，因为今年 stable 版是 Jessie，前两年就不是，过两年也不是了呢。建议使用其软件源配置生成器：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ustc-jessie.png" alt="ustc-jessie"></p>
<p>备注：</p>
<ol>
<li>网上好多帖子中提到 apt-spy 工具，用来测试源的连接状况。但是我试过的源都没有此应用。</li>
<li>Jessie 和 stable 在 2016/3/14 17:43:09 现实阶段理论上是一致的，但如果使用 stable，<code>apt-get update</code> 之后报错，就使用 Jessie。工具而已，使用时哪个能用用哪个，不必细究。有闲散时间时再做讨论。</li>
</ol>
<p>Q1：<code>apt-get</code> 安装软件时出现：“无法下载…大小不符” 问题</p>
<blockquote>
<p>A1：一般来讲是运营商缓存问题。换源，挂代理或等几小时再试。——事实是我从公司内网（网线，也能连接互联网）切换到外网之后，真的就顺利安装了，太坑爹。运营商缓存，无语！</p>
</blockquote>
<p>Q2：报错“<a href="http://www.cnblogs.com/LeoGodfrey/p/3316834.html">软件包有未满足的依赖关系</a>”问题</p>
<blockquote>
<p>A2：这个也是配置源的问题，换源，清理有问题的源。见前文，多是高版本 Debian 配置了低版本 source.list。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在 <a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">软件包管理器</a> 词条中，我们知道 Debian 安装应用前端用到的是 apt 命令，事实上对于纯 24K 金的新兵蛋子，推荐使用新立得包管理器（图形界面）。</p>
<p>用 <code>apt-get</code> 可能不知道安装时要输什么，synaptic 也会自动解决依赖问题。ubuntu 等还有个软件管理中心，也不错。要是源里没有的那就更麻烦了。总之，新手：软件管理中心—&gt;<a href="http://www.2cto.com/os/201310/248925.html">synaptic—&gt;aptitude—&gt;apt-get</a>（yum）—&gt;sources。</p>
<p>另外，在 debian 下，用 apt 方式安装软件除了可以以网络上的资源为源之外，还可以 <a href="http://blog.csdn.net/yang_dk/article/details/1705319">使用本地的资源</a>。比如光盘。</p>
<p>说一下最关心的，如果在 Debian 上进行 C++ 的开发，都需要安装什么工具呢？</p>
<ul>
<li><p>如果是快速搭建的话，</p>
<p>  用 <code>apt-get</code> 下载并安装下面的 package：make、gcc、g++、manpages-dev。至此, 一个可以 build c/c++ 工程的环境搭建好了。<br>  当然也可以用 <code>apt-get install build-essential</code></p>
</li>
<li><p>如果要完整构建的话，用如下命令：利用 <code>apt-get build-dep</code></p>
<p>  安装 Gnome 开发环境（包括了 C，Gtk，Gnome 等）：<code>apt-get build-dep gedit</code><br>  安装 KDE 开发环境（包括了 C++，Qt，KDE）：<code>apt-get build-dep kate</code></p>
</li>
</ul>
<h3 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h3><p>在 Linux 上安装 mysql 有很多种途径。可以参考官网。最简单的一种：<a href="http://dev.mysql.com/doc/refman/5.5/en/linux-installation-native.html">Installing MySQL on Linux Using Native Package Managers</a></p>
<h2 id="使用系统"><a href="#使用系统" class="headerlink" title="使用系统"></a>使用系统</h2><p>我们自己搭建 Linux 环境时一般就是在笔记本、台式机上直接物理机安装，或者虚拟机安装，使用时开机，主机前操作。</p>
<p>但在实际的工程应用、业务运行中，主机前操作是很少的，除非是硬件损坏、升级的情况下，才可能接触到主机，否则，多数情况下都是远程操作。</p>
<p>Windows 下有系统自带的远程桌面连接，连接微软自己的服务器时还是蛮方便的，怎么控制权限就不懂了。</p>
<p>Linux 的远程连接及操作，我是来到新公司之后才接触到的，工作中使用的是 Xshell 和 Xftp，挺好用的，也就没有再了解别的工具。</p>
<p><a href="http://hatech.blog.51cto.com/8360868/1558366">使用 Xshell</a> 时，服务器（远程主机）只要安装有 SSH 服务器即可，终端（我们的笔记本）需要安装 Xshell 客户端。</p>
<h1 id="SUSE"><a href="#SUSE" class="headerlink" title="SUSE"></a>SUSE</h1><p>分为两支：SUSE Linux Enterprise 和 openSUSE。两者之间的纠葛请自行 google，我弄不清。</p>
<p>SUSE Linux Enterprise 11 包括下列解决方案：</p>
<ul>
<li>SUSE Linux Enterprise Server（企业级服务器系统）— 数据中心关键任务负载使用的最佳平台；</li>
<li>SUSE Linux Enterprise Desktop（企业级桌面系统）— 业通用桌面系统；</li>
<li>Novell Customer Center（客户中心）— 此获取技术支持、更新及续订 SUSE Linux Enterprise 产品；</li>
</ul>
<p>SUSE Linux Enterprise Desktop 桌面系统：<a href="http://server.zol.com.cn/128/1289010.html">比 Win7 还炫！SUSE Linux11 系统全面体验</a></p>
<p>2015年11月4日，openSUSE 项目发布了其最新的 <a href="http://www.linuxstory.org/opensuse-leap-42-1-released/">openSUSE Leap 42.1 系统</a>，openSUSE 的上一个版本是 openSUSE 13.2，现在整这么个版本号，要么就是真牛，要么…感觉挺矫情的。</p>
<h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><p>正如笔记第一章中给出的 Linux 发行版列表中提到的，redhat 安装应用的前端命令是 yum；debian 安装应用的前端命令是 apt；在 suse 中与之对应的安装应用的前端命令是 zypper。</p>
<p>各自也都有相应的图形界面用来安装应用：debian 上的新立得；suse 上的 yast。</p>
<p>虽然工作中接触的是 suse，但我并没有 <a href="http://lengxuezhixuan.blog.chinaunix.net/uid-20639775-id-3433023.html">使用 zypper 安装软件</a> 的任何经验，也不曾 <a href="https://www.suse.com/zh-cn/documentation/sles10/book_sle_reference/data/sec.yast2.sw.html">使用 YaST 安装软件</a>，网上直接搜索 linux 安装应用的搜索结果中，大多帖子、教程都默认使用 root 权限执行，而公司的服务器是不可能下放 root 的权限给我用的。所以在自己虚拟机环境中试验 debian 安装应用顺利很多，无论是使用新立得直接图形界面安装（也需要更新 source 源），还是在 root 权限下编辑 source 源使用 <code>apt-get</code> 命令，按照网上搜到的教程按部就班，大都得心应手。而在 suse 上，有限的经验只局限与安装 .src.rpm 源包、安装 tar 源包到当前用户 home 目录下（/usr 下的系统目录果断是没有权限的），前者还从来没安装成功过。</p>
<p>而使用源码安装应用是就有很大的通用性的，通过 .src.rpm 源包在 redhat 系的 linux 发行版中都可以使用，通过 tar 源包更是在所有 linux 发行版中可用。</p>
<h1 id="Linux-发行版共性"><a href="#Linux-发行版共性" class="headerlink" title="Linux 发行版共性"></a>Linux 发行版共性</h1><h2 id="安装应用（-rpm-amp-src-rpm）"><a href="#安装应用（-rpm-amp-src-rpm）" class="headerlink" title="安装应用（.rpm &amp; .src.rpm）"></a>安装应用（.rpm &amp; .src.rpm）</h2><p>对于 redhat 系的 linux 发行版目前接触有限，<a href="http://www.linuxidc.com/Linux/2015-05/117967.htm">rpm 包有的是可以指定安装路径的</a>，也就意味着可以使用普通权限安装应用。但是对于大多数的 rpm 包（我一连查了 10 个，阿西吧）其 Relocations: （not relocatable）属性表示不能更改安装目录，基本上所有无 root 权限安装应用时都要更改默认安装路径的，所以使用 .rpm 包安装在 90%~100% 上意味着必须拥有 root 权限。</p>
<p>那么 .src.rpm 源包呢，是不是就可以普通权限安装了？理论上是的，<a href="http://ontheroad-luckhouge.iteye.com/blog/1124215">rpm 和 .src.rpm 两者之间的区别</a> 从字面就可以理解，需要熟悉的其实还是不同的操作命令，对于 .src.rpm 源包主要用到 <a href="http://sunflowers.iteye.com/blog/470264">rpmbuild 命令</a>，好多参数啊。</p>
<p>事实上，在 SUSE10 上安装 thrift 时，我按照以上帖子安装 .src.rpm 源包时，使用 -bb 或者 -bp 参考执行 rpmbuild 都没成功，递归层次超标。估计是系统版本太老了。</p>
<h2 id="安装应用（源码）"><a href="#安装应用（源码）" class="headerlink" title="安装应用（源码）"></a>安装应用（源码）</h2><p>直接看下一节。</p>
<h2 id="无root权限"><a href="#无root权限" class="headerlink" title="无root权限"></a>无root权限</h2><p>如果你可以指定安装路径（包括依赖包的安装路径），那么也就表示你可以使用普通权限安装。安装之后，需要更新PATH路径和动态库路径 LD_LIBRARY_PATH。</p>
<ul>
<li><a href="http://bioyang.me/2015/08/25/w-htm/">Linux中没有root权限安装常用软件和packages</a></li>
<li><a href="https://tlanyan.me/work-with-linux-without-root-permission/">linux下非root用户安装软件入门</a>，我爱死这篇帖子的排版了，使用 wiz 的 chrome 插件剪下来还是这么简洁美观。其他的网站、博客我忍了又忍，没办法，知识重要啊。</li>
</ul>
<p>以上两篇帖子，推荐先看后一个了解原理，具体的操作步骤参考前者。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>初始化</title>
    <url>/2016/11/03/initialization/</url>
    <content><![CDATA[<p>2018/9/19 17:46:55 这篇罗列概念很没水平，就别看了。</p>
<p>后记：这篇笔记限于罗列书中的概念，自己的理解并不多，组织章节也不好。后来又整理过一篇： <a href="https://tnie.github.io/2016/12/20/initialization2nd/">《再谈初始化》</a> ，两者不分先后，没有依赖关系。</p>
<p>参考《C++ Primer》和网上资源誊抄完正文后，自己总结如下：</p>
<ol>
<li><p>定义一个变量/对象时，如果不进行显式地初始化，就是<strong>默认初始化</strong>（除了使用 <code>extern</code> 进行纯粹的声明的）。需要关注的是，默认初始化时编译器究竟赋予了变量/对象什么内容。</p>
</li>
<li><p>默认初始化变数太多，比如造成内置类型未定义行为，对于使用编译器合成的默认构造函数的类也可能产生不良影响，所以在定义变量时最好进行初始化！初始化的语法格式有好多种呢：</p>
<ul>
<li>根据是否使用等号分为拷贝初始化和直接初始化；</li>
<li>根据是否使用了花括号，区分出列表初始化；</li>
</ul>
</li>
<li><p>想在初始化时偷懒，不想写太多参数（<code>vector</code> 值初始化）；但又操心默认初始不好使（<code>new</code> 动态分配时值初始化）。所以，又出现了值初始化。</p>
</li>
</ol>
<a id="more"></a>

<blockquote>
<p>值初始化和（拷贝初始化、直接初始化、列表初始化）是不同的概念。后者说明的是“用什么样的语法格式来初始化变量”，而值初始化不但要说明“用什么样的语法格式来初始化变量 “( C++中用 <code>new</code> 开辟的空间通过在要初始化的空间的类型名后跟 <code>()</code> 来启用值初始化，而库类型则自动对未初始化的变量启用值初始化 )，而且还要说明是”用什么值来初始化变量”。</p>
<ol>
<li>当变量为内置类型，值初始化用 <code>0</code> 来对其初始化。</li>
<li>当变量为类类型，值初始化用该类的默认构造函数初始化。</li>
<li>当变量为类类型且没有默认构造函数时，值初始化要求程序员提供初始化值。</li>
</ol>
<p>说明：<strong>值初始化</strong>通常用在初始化一段<strong>连续的内存区</strong>( 如 <code>vector</code> 容器，<code>new</code> 一段空间 )。</p>
</blockquote>
<p>在个人编码过程中推荐列表初始化方式，整篇文章整理的知识点其实主要针对阅读代码。在 C++11 之后，<a href="https://www.zhihu.com/question/36735960">列表初始化其实是最一般、最通用的初始化方式</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">new</span>] T [object] &#123; arg1, arg2, ... &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Default-Initialization-默认初始化（P39）"><a href="#Default-Initialization-默认初始化（P39）" class="headerlink" title="Default Initialization 默认初始化（P39）"></a>Default Initialization 默认初始化（P39）</h1><p>如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，<strong>同时定义变量的位置也会对此有影响。</strong></p>
<h2 id="内置类型的变量未被显式初始化时："><a href="#内置类型的变量未被显式初始化时：" class="headerlink" title="内置类型的变量未被显式初始化时："></a>内置类型的变量未被显式初始化时：</h2><ul>
<li>定义于任何函数体之外的变量被初始化为 <code>0</code>；</li>
<li>定义在函数体内部的内置类型变量将<strong>不被初始化</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> global_default_initialization;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> list_initialization&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> inner_default_initialization;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;list initialization: &quot;</span> &lt;&lt; list_initialization &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default initialization(inner): &quot;</span> &lt;&lt; inner_default_initialization &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default initialization(global): &quot;</span> &lt;&lt; global_default_initialization &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">niel@debian8light:~/code/test_initialize$ g++ --version</span><br><span class="line">g++ (Debian 4.9.2-10) 4.9.2</span><br><span class="line">Copyright (C) 2014 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">niel@debian8light:~/code/test_initialize$ make test CXXFLAGS=--std=c++11</span><br><span class="line">g++ --std=c++11    test.cpp   -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:7:31: warning: narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside &#123; &#125; [-Wnarrowing]</span><br><span class="line">   int list_initialization&#123;3.14&#125;;</span><br><span class="line">                               ^</span><br><span class="line">niel@debian8light:~/code/test_initialize$ ./test </span><br><span class="line">list initialization: 3</span><br><span class="line">default initialization(inner): 4196240</span><br><span class="line">default initialization(global): 0</span><br><span class="line">niel@debian8light:~/code/test_initialize$ </span><br></pre></td></tr></table></figure>
<h2 id="类的对象如果没有显式地初始化，则其值由类确定"><a href="#类的对象如果没有显式地初始化，则其值由类确定" class="headerlink" title="类的对象如果没有显式地初始化，则其值由类确定"></a>类的对象如果没有显式地初始化，则其值由类确定</h2><p><code>std::string</code> 不是内置类型，而是类！</p>
<h1 id="Initialization-初始化（P39）"><a href="#Initialization-初始化（P39）" class="headerlink" title="Initialization 初始化（P39）"></a>Initialization 初始化（P39）</h1><p>C++语言定义了初始化的好几种不同方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>写在前面：等号 <code>=</code> 可以用来初始化，也可以用来赋值。我们可能更熟悉、更习惯 <code>=</code> 的赋值操作。事实上在 C++ 语言中，初始化和赋值是两个完全不同的概念，所以 <code>=</code> 在这两种情况下的应用也是两个完全不同的操作。</p>
<p><strong>显式初始化（P76）</strong>：强调“显式”是为了与“默认初始化”的“未指定初值”区分。在大多情况下，谈及“初始化”都是指非“默认初始化”的情况。“初始化”一般不包括“默认初始化”！</p>
<p>按照初始化时是否使用等号分为拷贝初始化和直接初始化；按照是否使用了花括号，区分出列表初始化。</p>
<h2 id="copy-initialization-拷贝初始化"><a href="#copy-initialization-拷贝初始化" class="headerlink" title="copy initialization 拷贝初始化"></a>copy initialization 拷贝初始化</h2><p>如果使用等号（<code>=</code>）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。</p>
<h2 id="direct-initialization-直接初始化"><a href="#direct-initialization-直接初始化" class="headerlink" title="direct initialization 直接初始化"></a>direct initialization 直接初始化</h2><p>与拷贝初始化相反，如果不使用等号，则执行的是直接初始化（direct initialization）。</p>
<h2 id="List-Initialization-列表初始化（P39）"><a href="#List-Initialization-列表初始化（P39）" class="headerlink" title="List Initialization 列表初始化（P39）"></a>List Initialization 列表初始化（P39）</h2><p>作为 C++11 新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项（P88）"><a href="#注意事项（P88）" class="headerlink" title="注意事项（P88）"></a>注意事项（P88）</h2><p>在大多数情况下这些初始化方式（显式的）可以相互等价地使用，不过也并非一直如此：</p>
<ol>
<li><p>使用拷贝初始化时（即使用 <code>=</code> 时），只能提供一个初始值；</p>
<p> 当（显式地）初始化只使用一个值时，使用直接初始化或拷贝初始化都行。如果像 <code>string s4(n, &#39;c&#39;);</code> 这样初始化时要用到的值有多个，一般来说只能使用直接初始化的方式：（P76）</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hiya&quot;</span>;  <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;   <span class="comment">// 直接初始化，s7 的内容是 ccccc</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果提供的是一个类内初始值（in-class initializer），则只能使用拷贝初始化或使用花括号的形式初始化；</p>
<p> 创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。对类内初始值的限制与之前介绍的类似（原文：In-class initializers are restricted as to the form we can use: They must either be enclosed inside …）：<em>或者放在花括号里，或者放在等号右边，记住不能使用圆括号</em>。（P65）</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">ales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;  <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v1</span><span class="params">(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>)</span></span>;  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h1 id="Value-initialization-值初始化"><a href="#Value-initialization-值初始化" class="headerlink" title="Value initialization 值初始化"></a>Value initialization 值初始化</h1></li>
</ol>
<h2 id="初始化-vector-对象（P88）"><a href="#初始化-vector-对象（P88）" class="headerlink" title="初始化 vector 对象（P88）"></a>初始化 <code>vector</code> 对象（P88）</h2><p>我们可以只提供 <code>vector</code> 对象容纳的元素数量而略去初始值（原文：We can usually omit the value and supply only a size. ）。此时库会创建一个值初始化的元素初值（原文：a value-initialized element initializer），并把它赋给容器中的所有元素，这个初值由 <code>vector</code> 对象中元素的类型决定。 </p>
<p>如果 <code>vector</code> 对象的元素是内置类型，比如 <code>int</code>，则元素初始值自动设为<code>0</code>。如果元素是某种类类型，比如 <code>std::string</code>，则元素由类默认初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//10个元素，每个都是空string对象</span></span><br></pre></td></tr></table></figure>
<p>对这种初始化的方式有两个特殊限制：</p>
<ol>
<li><p>有些类要求必须明确地提供初始值，如果 <code>vector</code> 对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。</p>
</li>
<li><p>如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = <span class="number">10</span>;  <span class="comment">//错误，必须使用直接初始化的形式指定向量的大小</span></span><br></pre></td></tr></table></figure>
<p> 这里的 <code>10</code> 是用来说明如何初始化 <code>vector</code> 对象的，我们用它的本意是想创建含有 10 个值初始化了的元素的 <code>vector</code> 对象，而非数字 10 “拷贝” <code>vector</code> 中。因此，此时不宜使用拷贝初始化。</p>
</li>
</ol>
<h2 id="使用-new-动态分配和初始化对象（P407）"><a href="#使用-new-动态分配和初始化对象（P407）" class="headerlink" title="使用 new 动态分配和初始化对象（P407）"></a>使用 <code>new</code> 动态分配和初始化对象（P407）</h2><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将执行默认构造函数进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>;  <span class="comment">//初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;        <span class="comment">//pi指向一个未初始化的int</span></span><br></pre></td></tr></table></figure>
<h3 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h3><p>我们可以使用直接初始化方式来初始化动态分配的对象。我们可以使用传统的构造方式，在新标准下，也可以使用列表初始化（使用花括号）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);           <span class="comment">//pi指向的对象的值为1024</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>，<span class="string">&#x27;9&#x27;</span>);  <span class="comment">//*派生为“9999999999”</span></span><br><span class="line"><span class="comment">//vector有10个元素，值依次从0-9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h3><p>也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps1 = <span class="keyword">new</span> <span class="built_in">string</span>；  <span class="comment">//默认初始化为空string</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>();  <span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>;         <span class="comment">//默认初始化；*pi1的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="keyword">int</span>();       <span class="comment">//值初始化为0；*pi2的值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>对于定义了自己的构造函数的类类型来说，要求值初始化是没有意义的</strong>；不管采用什么方式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就大了；<strong>值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。</strong>类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内初始化，那么它们的值也是未定义的。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数的问题</title>
    <url>/2019/11/29/initialization3rd/</url>
    <content><![CDATA[<p>在工作中，遇到的几个关于构造函数的问题，以及语言边缘的坑（如何避开）。</p>
<h1 id="显式类型转换函数和构造函数优先级"><a href="#显式类型转换函数和构造函数优先级" class="headerlink" title="显式类型转换函数和构造函数优先级?"></a>显式类型转换函数和构造函数优先级?</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Minimal(src)；	<span class="comment">// 不是类型转换语法吧？</span></span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line">(Minimal)src;</span><br></pre></td></tr></table></figure>
<p>会先按照构造函数解析，还是</p>
<h1 id="构造函数能不能相互调用？"><a href="#构造函数能不能相互调用？" class="headerlink" title="构造函数能不能相互调用？"></a>构造函数能不能相互调用？</h1><p><del><a href="http://www.cppblog.com/wolf/articles/63490.html">http://www.cppblog.com/wolf/articles/63490.html</a></del></p>
<p><a href="http://www.cnblogs.com/chio/archive/2007/10/20/931043.html"><del>http://www.cnblogs.com/chio/archive/2007/10/20/931043.html</del></a></p>
<p>传统的 <code>func(var)</code> 调用方式肯定不行，因为这意味着在某构造函数中又创建了个临时对象。</p>
<a id="more"></a>

<p><del>但通过评论中提到的方式，还是可以复用构造函数定义的：</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;ClassName::ClassName() </span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">this</span>)CLS(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 经测试两种方法结果都是正确的。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>补充一点，构造函数是可以调用的，但是调用方式是这样的： <code>obj.ClassName::ClassName();</code></del><br><del>在构造函数内部调用是这样的： <code>this-&gt;ClassName::ClassName()</code></del><br><del>楼主的调用方式是错误的，是在创建一个临时对象，不是调用构造函数</del></p>
</blockquote>
<p>上述两篇帖子分别是 07/08 年的，<a href="https://stackoverflow.com/questions/308276/can-i-call-a-constructor-from-another-constructor-do-constructor-chaining-in-c">在 c++11 中支持</a> 定义构造函数时通过初始化列表的形式调用其他构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  Foo(<span class="keyword">char</span> x, <span class="keyword">int</span> y) &#123;&#125;</span><br><span class="line">  Foo(<span class="keyword">int</span> y) : Foo(<span class="string">&#x27;a&#x27;</span>, y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，委托构造函数的语法</p>
<blockquote>
<p>在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。摘自《C++ Primer(5th)》P261</p>
</blockquote>
<p>以下代码编译无法通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 委托构造函数不能具有其他成员初始值设定项</span></span><br><span class="line">    Foo(<span class="keyword">char</span> x, <span class="keyword">int</span> y): Foo(y), x_(x) &#123;&#125;</span><br><span class="line">    Foo(<span class="keyword">int</span> y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> x_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不同的默认构造"><a href="#不同的默认构造" class="headerlink" title="不同的默认构造"></a>不同的默认构造</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    Y() &#123; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_trivial&lt;X&gt;::value, <span class="string">&quot;X should be trivial&quot;</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_pod&lt;X&gt;::value, <span class="string">&quot;X should be POD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_trivial&lt;Y&gt;::value, <span class="string">&quot;Y should not be trivial&quot;</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_pod&lt;Y&gt;::value, <span class="string">&quot;Y should not be POD&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/20828907/the-new-keyword-default-in-c11">https://stackoverflow.com/questions/20828907/the-new-keyword-default-in-c11</a></p>
<blockquote>
<p>Giving a user-defined constructor, even though it does nothing, makes the type <strong>not an aggregate</strong> and also <strong>not trivial</strong>. </p>
<p>If you want your class to be an aggregate or a trivial type (or by transitivity, a POD type), then you need to use <code>= default</code>.</p>
</blockquote>
<h3 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Test() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Test acb;   //error C2248: “Test::Test”: 无法访问 private 成员</span></span><br><span class="line">    Test abc&#123;&#125;; <span class="comment">// THIS COMPILES</span></span><br><span class="line">    abc.hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h2><p>常用方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Derived(<span class="keyword">int</span> a):Base(a) &#123;&#125;</span><br><span class="line">  Derived(<span class="built_in">std</span>::<span class="built_in">string</span> a):Base(a) &#123;&#125;</span><br><span class="line">  Derived(<span class="keyword">int</span> a, doubel b):Base(a, b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 c++11 新标准中，可以简化为（是不是类似语法糖的东东？）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Derived</span><br><span class="line">&#123;</span><br><span class="line">  using Base::Base; &#x2F;&#x2F; 继承 Base 的构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类不能继承默认、拷贝和移动构造函数。摘自《C++ Primer(5th)》P557</p>
</blockquote>
<h1 id="无效初始化"><a href="#无效初始化" class="headerlink" title="无效初始化"></a>无效初始化</h1><p>最坑的地方，在于以下代码误将成员变量 <code>_tick_count</code> 绑定到了临时变量，使用时其指向垃圾值。编译不报错，运行也不崩溃，无法达到预期目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmdlet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    cmdlet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; label) :</span><br><span class="line">        label(label), _others()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    cmdlet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; label, <span class="keyword">unsigned</span> _tick_count) :</span><br><span class="line">        label(label),  _tick_count(_tick_count)	  <span class="comment">// 引用类型，覆盖掉 ① 处的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 并未达到预期，使得 _tick_count 作为 _other[0] 的别名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="comment">// others</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp; _tick_count = _others[<span class="number">0</span>];   <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">    cmdlet(<span class="keyword">const</span> cmdlet &amp; rhs) : label(rhs.label), _others(rhs._others)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">unsigned</span>, 3&gt; _others;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 MySQL</title>
    <url>/2017/03/07/installMySQL/</url>
    <content><![CDATA[<p>完全没想到安装 mysql 会消耗掉将近一天的时间。从上午十一点，没吃饭没睡觉一直折腾到下午四点半，网上已经有了很详细的安装指导，却依旧卡在某个问题上两三个小时。文中会详细叙述。</p>
<p>我们可以在不同的平台以“不同的姿势”搭建 mysql 环境。</p>
<h1 id="Debian-安装-MySQL"><a href="#Debian-安装-MySQL" class="headerlink" title="Debian 安装 MySQL"></a>Debian 安装 MySQL</h1><p>通过 <a href="http://dev.mysql.com/doc/refman/5.5/en/linux-installation-native.html">官方指导手册</a> 的章节标题我们就能感受到“姿势”的多种多样了。因为我使用的 Debian8，其官方软件库中 mysql-server-5.5，所以在此贴的链接也是 5.5 版本的。</p>
<blockquote>
<ul>
<li><p>Installing MySQL on Unix/Linux Using Generic Binaries</p>
</li>
<li><p>Installing MySQL on Linux</p>
<ul>
<li>Installing MySQL on Linux Using Debian Packages</li>
<li><a href="http://dev.mysql.com/doc/refman/5.5/en/linux-installation-native.html">Installing MySQL on Linux Using Native Package Managers</a></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Installing MySQL from Source</li>
</ul>
</blockquote>
<p>如果你有管理员权限，很明显使用 Debian 原生的 apt-get 包管理器进行安装是最方便的。我也是敲入以下命令直接装的：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install mysql-client-5.5 mysql-server-5.5</span><br></pre></td></tr></table></figure>
<p>关于 mysql-server 和 mysql-client 的区别：</p>
<blockquote>
<p>来一段引用或者 链接</p>
</blockquote>
<p>打算使用 windows 上的 Navicat 访问、管理数据库的。但是在虚拟机使用 NAT 模式前提下，windows 主机无法访问安装在 Debian 虚拟机中的 mysql 数据库。从网上查找资料了解到，修改为“Bridge”模式可以让宿主机、虚拟机彼此访问，但是涉及笔记本双网卡、气象局网络环境等，还要了解虚拟机三种网络模式，不想背离初衷（上午十点我只是打算写段访问数据库的 C++11 代码）太远，所以选择放弃！以后碰到了，再回来接续这些技能。</p>
<p>在 Debian8Light 上卸载 mysql-server-5.5，保留了 mysql-client-5.5。</p>
<h1 id="Windows7-安装-MySQL"><a href="#Windows7-安装-MySQL" class="headerlink" title="Windows7 安装 MySQL"></a>Windows7 安装 MySQL</h1><p>windows 下是“姿势”多多。既然是在 windos 上安装，就使用最新的 5.7 版本了。</p>
<blockquote>
<ul>
<li>Installing MySQL on Microsoft Windows Using MySQL Installer</li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/windows-install-archive.html">Installing MySQL on Microsoft Windows Using a noinstall Zip Archive</a></li>
</ul>
</blockquote>
<p>使用 <a href="http://dev.mysql.com/downloads/windows/installer/5.7.html">MySQL Installer</a> 安装包安装很简单，需要花费精力的是“尽可能的安装最小集，只安装那些你需要的”。对于这次的使用场景来说，我是练习写 C++ 代码用，而且已经有了 Navicat 工具。所以，我只需要安装 MySQL Server 和开发时所用的 Connector，其他的任何 GUI 工具和 Java、Python 连接器我都不需要。</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/mysql_custom.png" alt="MySQL 自定义安装"></p>
<p>剔除那些根本就不会用到的功能花费了一些时间，除此之外，整个安装过程很顺利，装完之后连接成功直接使用。</p>
<p>在好奇心和心理洁癖的驱使下，我尝试搭建了 <a href="http://dev.mysql.com/downloads/mysql/">解压版 MySQL</a>。就是在这个过程中遇到了意外，花费了两个小时才解决。</p>
<p>解压版本重点在于配置，根据网上的示范（5.5版本、5.6版本）搭建完毕，可是启动服务时老是失败，报错“本地计算机上的mysql服务启动后停止，……”。我当时脑袋也是不清醒，下意识地以为是配置文件的问题，或者是一台电脑安装两个实例带来的冲突。配置文件，我是把安装版的 my.ini 稍作修改直接拿过来用的，担心漏掉了某条配置没有改，造成冲突。可是校对之后仍没能解决问题；然后将安装版本卸载之后，还是出现这个错误，才反应过来直接 Google 这句错误信息。网上搜到的信息不多，但很有效。</p>
<p>这是一个在 5.7.7 版本之后才有的现象，新的版本需要 <a href="http://dev.mysql.com/doc/refman/5.7/en/windows-initialize-data-directory.html">Initializing the Data Directory</a>。如果英文水平不高，可以直接参考 <a href="http://jingyan.baidu.com/article/0f5fb0991636376d8234ea7a.html">MySQL 5.7.9 ZIP 免安装版本配置过程</a>。</p>
<p>而现在 2016/7/16 18:56:44 ，我要开始码代码了。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>在 windows 上安装 msi 版本后，查看在其 /Data/ 目录下的 my.ini 配置文件。</p>
<p>整个配置文件分为两部分： Client Section 和 Server Section。强调 mysql 和 mysqld 是不同的两个功能，尤其是用 mysql、mysqladmin等<strong>客户端工具</strong>连接数据库时（默认）使用 Client Section 区域的 port，mysqld 启动<strong>数据库服务</strong>时监听 Server Section 区域的 port 指定的端口。仔细阅读配置文件中的注释！</p>
<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>很很重要的一部分！但目前没有深入了解的必要，参考 <a href="http://www.cnblogs.com/goodhacker/p/3373213.html">MySQL 数据库赋予用户权限操作表</a> 只学习以下几点：</p>
<ul>
<li><p>查看权限：查看自己的权限，查看其他用户的权限</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> dba;</span><br><span class="line"><span class="number">1141</span> <span class="operator">-</span> There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;dba&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> dba<span class="variable">@localhost</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> dba<span class="variable">@localhost</span>                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `testdb`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> developer;</span><br><span class="line"><span class="number">1141</span> <span class="operator">-</span> There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;developer&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> developer@<span class="string">&#x27;192.168.195.%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> developer<span class="variable">@192</span><span class="number">.168</span><span class="number">.195</span>.<span class="operator">%</span>                                                                                                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;developer&#x27;</span>@<span class="string">&#x27;192.168.195.%&#x27;</span>                                                                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">CREATE</span>, <span class="keyword">DROP</span>, <span class="keyword">REFERENCES</span>, INDEX, <span class="keyword">ALTER</span>, <span class="keyword">EXECUTE</span>, <span class="keyword">CREATE</span> <span class="keyword">VIEW</span>, <span class="keyword">SHOW</span> <span class="keyword">VIEW</span>, <span class="keyword">CREATE</span> ROUTINE, <span class="keyword">ALTER</span> ROUTINE <span class="keyword">ON</span> `testdb`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;developer&#x27;</span>@<span class="string">&#x27;192.168.195.%&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> common_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> common_user@<span class="operator">%</span>                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;common_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> `testdb`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;common_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>GRANT语句的主要用途是来给帐户授权的，但也可用来建立新帐户并同时授权。</p>
<p>  创建 testdb 数据库，在其基础上创建 common_user developer dba 用户并授权</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> `testdb`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;common_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;common_user&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>参考 <a href="http://www.cnblogs.com/Richardzhu/p/3318595.html">MySQL之权限管理</a> 了解更多的，记得去官网哦。</p>
</li>
</ul>
<blockquote>
<p> jack@’localhost’ 表示jack用户，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方。<strong>注意：</strong>这里%有的版本不包括本地，以前碰到过给某个用户设置了%允许任何地方登录，但是在本地登录不了，这个和版本有关系，遇到这个问题再加一个localhost的用户就可以了。</p>
<p>WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人。<strong>注意：</strong>经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其它用户授权。</p>
</blockquote>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p><a href="https://dev.mysql.com/doc/connector-cpp/en/">MySQL Connector/C++ Developer Guide</a></p>
<p>在 C++ 中使用 MySQL 数据库，包含上述方法在内一共有 3 种：</p>
<ol>
<li>使用 Connector/C++，库文件命名 (lib)mysqlcppconn.xx</li>
<li>使用 Connector/ODBC</li>
<li>使用 Connector/C，库文件命名 libmysql.xx</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 CC94-9350</span><br><span class="line">C:.</span><br><span class="line">├─Connector.C++ 1.1</span><br><span class="line">│  ├─include</span><br><span class="line">│  │  └─cppconn</span><br><span class="line">│  └─lib</span><br><span class="line">│      └─opt</span><br><span class="line">├─Connector.ODBC 5.3</span><br><span class="line">└─MySQL Connector.C 6.1</span><br><span class="line">    ├─bin</span><br><span class="line">    ├─include</span><br><span class="line">    │  └─mysql</span><br><span class="line">    │      └─psi</span><br><span class="line">    └─lib</span><br><span class="line">        ├─vs10</span><br><span class="line">        ├─vs11</span><br><span class="line">        └─vs12</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中int型和std::string互相转换</title>
    <url>/2016/11/03/int-string-int/</url>
    <content><![CDATA[<p>每次用到时，都要到网上搜索一下的感觉很不好。尤其是经常用到，每次搜索时你完全能认识到你已经查过很多遍了。另外，和不自信（拿不准的心理）以及养成了这种坏习惯都有关系，查得多了自然知道调用 C 标准库 atoi（itoa 不是 C 标准库函数）以及使用 stringstream 流来解决问题，但每每觉得差那么一点意思，不够简洁。每次用到时都要搜索一下，可能是希望找到一种让内心舒坦的转换“手法”吧。</p>
<p>参考 <a href="https://www.ibm.com/developerworks/community/forums/html/topic?id=21b31ae2-0960-4068-a555-ce9e6c27da9b">C++11 中的 string - atoi/itoa</a>，岂止是参考，根本就是抄袭。可是好不喜欢原文的排版。</p>
<a id="more"></a>

<p>我哭，我发现又是从<a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/atoi_and_itoa_conversions_in_c_11?lang=en">英文原文</a>翻译过来的，大致看了一眼，就明白了翻译的不可靠啊。比如译文中叙述</p>
<blockquote>
<p>相比于 atoi，strtol 多了最后一个参数 “radix” 表明函数采用的是几进制（这个进制数可以从2到34，这个数值范围的原因显而易见）</p>
</blockquote>
<p>34显而易见你妹啊，当时就觉得诡异（当然再google一下就知道怎么回事了），相信译者也是笔误而已。来看英文原文：</p>
<blockquote>
<p>strtol’s third parameter specifies the radix whose value is between 2 and 36 inclusively. </p>
</blockquote>
<p>多简洁的表述！！！额。。。译者貌似不是笔误，看英文原文下的评论，汗</p>
<p>我们对比另一个位置的表述：（我怎么这么幼稚呢。。）</p>
<blockquote>
<p>值得注意的是，在 C++98 代码中，虽然字符串的存储使用字符串数组也是完全可以的，</p>
<p>It is noteworthy that although strings can still be stored in c-arrays in C++ code,</p>
</blockquote>
<p>一定要抽空看英文啊，上面发现的问题真是瞟了一眼，并没有通读原文的。<strong>转帖中，认为译文表述不恰当的地方已经用英文原文替代。</strong></p>
<p>懂得历史，才能明白现在。在处理 atoi/itoa 问题时觉得凌乱、不成体系是因为在工作中只求开发效率，只看解决方法时看到的只是时间的一张快照，要回去探索历史，明白其中各自归属就能和内心“和解”了。下面依序描述 C，C++98，C++11 是如何处理 atoi/itoa 问题的：</p>
<h1 id="在C时代"><a href="#在C时代" class="headerlink" title="在C时代"></a>在C时代</h1><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><p>在 C 时代，通常我们遇到 atoi（字符串到数值转换）的问题的时候我们会使用 <code>&lt;stdlib.h&gt;</code> 中的 <code>atoi</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = atoi(cstr);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>cstr</code> 通常为 <code>char*</code> 或者 <code>const char*</code> 类型的字符串。函数返回的结果则是该字符串所表示的一个十进制的 integer。函数的整个效果则等同于 <code>&lt;stdlib.h&gt;</code> 中的另外一个函数<code>strtol</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = strtol(cstr, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>strtol’s third parameter specifies the radix whose value is between 2 and 36 inclusively. 。除去 <code>strtol</code> 会在出错时设置全局的 <code>errno</code> 外，其效果与 atoi 系列中的<code>atol</code>则几乎是完全等同的。</p>
<h2 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h2><p>而 C 时代解决 itoa（数值到字符串的转换）的时候，则采用了 sprintf 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myint;</span><br><span class="line"><span class="keyword">char</span> buf[SIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;my data is %d&quot;</span>, myint);</span><br></pre></td></tr></table></figure>
<p>这里字符的输出控制交给了 <code>%d</code> 这样的特殊字符。通过特殊字符以及变长参数的配合（<code>sprintf</code>是变长参数函数），我们获得预期的 formatted I/O 的输出。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里我们可以看到 C 中对 atoi/itoa 的处理的特点，基本可以归纳如下：</p>
<ol>
<li>atoi 不检查字符串中错误。这对使用 API 的程序员而言意味着他必须检查错误，或者必须判断出错误在实际使用中总是不存在或者是可以被程序忍受的。</li>
<li>atoi 的替代版本 strtol 检查字符串的错误，但使用的是 POSIX中 的标准方式，设置 errno。这意味着使用 strtol 的程序员如果要检测字符串中的错误，需要在调用 strtol 后检测全局变量 errno。</li>
<li>sprintf 不负责任何的内存管理。通常情况下，程序员都会被告诫使用 snprintf 或者其它有内存边界检查的版本替代 sprintf 。这样一来会减少发生缓冲区溢出的可能性。不过总的来说这只是一种编程中的防御手段，从程序员的角度而言，内存管理的烦恼依然存在。</li>
<li>sprintf 跟 printf 一样，不检查参数类型（因为是以变长函数的方式实现的），所以如果参数和 escape character 不匹配的话，会在运行时才发现不匹配的输出。不过相对于其它三点，这种错误是最容易修正的。</li>
</ol>
<p>所以说 C 中的 atoi/itoa 问题的解决方式并算不得让程序员愉悦。在坏的输入情况下，程序员必须小心处理各种异常，以防程序误入歧途。不过反过来看，C 中的 atoi/itoa 的处理也非常直观，易于理解，所以即使在 C++ 中这样的代码也并非少见。</p>
<h1 id="C-98时代"><a href="#C-98时代" class="headerlink" title="C++98时代"></a>C++98时代</h1><p>先强调一点：在 C++ 代码中，虽然字符串的存储使用C风格的字符数组也是完全可以的，但在 C++ 代码中使用 <code>std::string</code> 类型，内存可以自行有效地管理，而且成员函数可以抛出异常，所以更适用于 C++ 代码。</p>
<h2 id="atoi-itoa"><a href="#atoi-itoa" class="headerlink" title="atoi/itoa"></a>atoi/itoa</h2><p>到了 C++98 时代，atoi/itoa 可以使用新的 C++ 标准库来完成。具体地就是使用 C++ 的流（stream）模板类。而关于 <code>std::string</code> 类型的流模板类型就是 <code>std::stringstream</code>。通过全局重载的 operator <code>&lt;&lt;</code>以及 operator <code>&gt;&gt;</code>，<code>std::stringstream</code> 可以很轻松地完成 atoi 或者是 itoa 的任务，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> oss;</span><br><span class="line">oss &lt;&lt; <span class="number">15</span> &lt;&lt; <span class="string">&quot; is int, &quot;</span> &lt;&lt; <span class="number">3.14f</span> &lt;&lt; <span class="string">&quot; is float.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; oss.str();</span><br></pre></td></tr></table></figure>
<p>oss 就是一个字符串流对象，可以用于 itoa 的工作。而</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(<span class="string">&quot;12 14.1f&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line">iss &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中的 iss 字符串流对象，则可用作 atoi。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>从设计上讲，<code>std::stringstream</code> 算得上是一种好的设计。这是由于使用 <code>std::stringstream</code> 的代码看起来非常地直观。As a standard component of ISO C++ library, it relieves programmers of handling exceptions–因为如果代码没有 try-catch block 的话，exception 一旦抛出，程序就会直接直接终止（调用 std::terminate）。这种解决出错的方式对于程序员来说更为爽快，因为程序在问题点终止，就很容易找到出问题的代码位置。而 C 时代的 atoi/itoa，如同我们讲到的，需要程序员关注异常，如果漏过处理异常之后（其实这很常见），程序可能带病运行。当然，由于 stringstream 总是”附着”于一个内存可以自行管理的 string 对象，所以程序员通常也不必担心任何的内存分配问题。</p>
<p>从设计角度出发看，<code>std::stringstream</code> 几乎无可挑剔。但在实际使用中，如我们在上面提到的，很多人还是愿意使用 C 中的处理方法来完成 atoi/itoa。这大概有两方面的原因：</p>
<ol>
<li><code>std::stringstream</code> 在概念上的间接性。这点间接性来源于 <code>std::stringstream</code> 和 <code>std::string</code> 间的关联。通常情况下，一个 <code>std::stringstream</code> 对象总是会与其”附着”的 <code>std::string</code> 对象发生联系。或者其是从一个string对象（上例中的 <code>iss(&quot;12 14.1f&quot;)</code>）构造而来以使用，或者其必须转化为一个string对象（上例中的 <code>oss.str()</code>）而使用。而新手常会会直觉地写出 <code>string a &lt;&lt; 12 &lt;&lt; &quot; is int&quot;;</code> 这样的错误代码。</li>
<li>格式化输出的不便利性。相比于<code>sprintf</code>，<code>std::stringstream</code>是一个流对象，意味着其也有了更高的学习代价。简单的 sprintf，只需要翻查 escape character 的手册，就能漂亮地进行格式化的输出。而使用流进行格式化输出的话，则需要控制一个状态机。很多时候，程序员需要关心上一状态对现有输出的影响。而且通常也意味着需要输入更多的代码。很多时候程序员都会觉得非常麻烦。所以即使 <code>sprintf</code> 在C++代码中缺失了类型匹配、异常处理、内存管理等等，程序员依然义无反顾地使用了它。（关于这一点，boost::format 可能给出了一种跨平台的中间的解决方案）</li>
</ol>
<p>从以上两个方面看，使用 <code>std::stringstream</code> 完成 atoi/itoa 虽然是更为 C++ 风格地、功能完备方式，但由于学习代价的增高以及格式化输出中的不便利性，其在实际场景中的应用也大大受限。</p>
<h1 id="C-11时代"><a href="#C-11时代" class="headerlink" title="C++11时代"></a>C++11时代</h1><p>新标准中又有什么新特性等着我们呢？</p>
<h2 id="itoa-1"><a href="#itoa-1" class="headerlink" title="itoa"></a>itoa</h2><p>到了 C++11 中，标准委员会可能是注意到这种”简单比完备”更重要的情况，于是在 C++11 中，标准增加了全局函数 <code>std::to_string</code>，以及 <code>std::stoi/stol/stoll</code> 等等函数。（最初的 paper 称之为 simple numeric access，N1982）其用法非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s += to_string(<span class="number">12</span>) + <span class="string">&quot; is int, &quot;</span>;</span><br><span class="line">s += to_string(<span class="number">3.14f</span>) + <span class="string">&quot; is float.&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>to_string</code> 会根据参数的类型完成相应类型地转换。在多线程中禁用，要么加锁——好坑爹</p>
<blockquote>
<p><code>std::to_string</code> 由于格式化目的依赖本地环境，从而从多个线程同时调用 <code>std::to_string</code> 可能会导致调用的部分序列化结果。 C++17 提供高性能、不依赖本地环境的替用品 <code>std::to_chars</code> 。</p>
</blockquote>
<h2 id="atoi-1"><a href="#atoi-1" class="headerlink" title="atoi"></a>atoi</h2><p>而： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;12&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = stoi(s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这样的代码则可以顺利完成 atoi 的任务。由于其是 C++11 引入的函数，所以具备 C 所不具备的所有的 C++ 库代码特征：根据类型的处理，抛出异常，以及自动内存管理。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>可以看到，<code>std::to_string</code> 在实际使用中可能会涉及一些字符串的连结。如我们在文章一开始提到的，C++98 中字符串连结一直是 C++ 语言被诟病性能低于C的一个重要方面。而这在 C++11 引入了右值引用后得到了很大的缓解。因此此时 <code>std::to_string</code> 这样的函数的实用性就大大增强了。不过 <code>std::to_string</code> 并不是itoa的一种终极方式。以浮点数为例， <code>to_string</code> 甚至连浮点数小数位显示控制这样基本的控制功能都不具备，因此其最大地特点还是突出在其易用性上。C++ 程序员不必定义一个 <code>std::stringstream</code> 对象就可以完成安全有效且不必关心任何内存的 itoa 工作。</p>
<p>而 std::stoi/stol/stoll…系列更是简单到只能完成一个数值的转换，比起总是返回 <code>std::stringstream &amp;</code> 的 operator <code>&gt;&gt;</code> 比起来功能性就差很远了。后者能在一行代码中转化出多个数值。但前者最大地特点仍然突出在易用性上，不必”附着”一个 <code>std::stringstream</code> 类型。这对很多无需复杂 atoi 的程序而言也就足够了。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>iocp</title>
    <url>/2020/12/25/iocp/</url>
    <content><![CDATA[<p>内核对象的概念，是什么？</p>
<p>设备内核对象？</p>
<p>事件内核对象？</p>
<a id="more"></a>

<p><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP 概念</a></p>
<blockquote>
<p>An I/O completion port is associated with the process that created it and is not sharable between processes. However, a single handle is sharable between threads in the same process.</p>
</blockquote>
<p>IOCP 相关的基础 API 只有这三个，相关类型和函数的描述：</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/createiocompletionport">CreateIoCompletionPort </a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// An open file handle or INVALID_HANDLE_VALUE.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE    FileHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// A handle to an existing I/O completion port or NULL.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ HANDLE    ExistingCompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// Use the CompletionKey parameter to help your application track which I/O operations have completed.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG_PTR CompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD     NumberOfConcurrentThreads</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE       CompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD      lpNumberOfBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">  PULONG_PTR   lpCompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 指针的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED *lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/postqueuedcompletionstatus">PostQueuedCompletionStatus</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">PostQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE       CompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 后面三个参数直接转给 GetQueuedCompletionStatus，内部不使用也不做合法校验，可以不做有效赋值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD        dwNumberOfBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG_PTR    dwCompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// In particular, the lpOverlapped parameter need not point to an OVERLAPPED structure.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED </a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OVERLAPPED</span> &#123;</span></span><br><span class="line">  <span class="comment">// The status code for the I/O request.</span></span><br><span class="line">  ULONG_PTR Internal;   <span class="comment">//系统内部使用</span></span><br><span class="line">  <span class="comment">// The number of bytes transferred for the I/O request.</span></span><br><span class="line">  ULONG_PTR InternalHigh;   <span class="comment">//系统内部使用</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      DWORD Offset;</span><br><span class="line">      DWORD OffsetHigh;</span><br><span class="line">    &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    PVOID Pointer;  <span class="comment">// 系统内部使用</span></span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  HANDLE    hEvent;</span><br><span class="line">&#125; OVERLAPPED, *LPOVERLAPPED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WSAOVERLAPPED</span> &#123;</span></span><br><span class="line">  DWORD    Internal;</span><br><span class="line">  DWORD    InternalHigh;</span><br><span class="line">  DWORD    Offset;</span><br><span class="line">  DWORD    OffsetHigh;</span><br><span class="line">  WSAEVENT hEvent;</span><br><span class="line">&#125; WSAOVERLAPPED, *LPWSAOVERLAPPED;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Any unused members of this structure should always be initialized to zero before the structure is used in a function call.</p>
</blockquote>
<p>其余三个属性一般置零 <code>l.Offset = l.OffsetHigh = 0; l.hEvent = NULL;</code></p>
<blockquote>
<p>The <code>WSAOVERLAPPED</code> structure is compatible with the Windows <code>OVERLAPPED</code> structure.</p>
</blockquote>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile </a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE       hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID       lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 以下两个指针分属同步、异步场景中使用，否则置零</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD      lpNumberOfBytesRead,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="">WSAStartup</a> </li>
</ul>
<blockquote>
<p>The <code>WSAStartup</code> function initiates use of the Winsock DLL by a process.</p>
</blockquote>
<blockquote>
<p>The <code>WSAStartup</code> function must be the first Windows Sockets function called by an application or DLL. </p>
</blockquote>
<ul>
<li><a href="">WSASocket</a> 和 <a href="">socket </a></li>
</ul>
<blockquote>
<p>By default, a socket created with the <code>WSASocket</code> function will not have this overlapped attribute set.<br>In contrast, the <code>socket</code> function creates a socket that supports overlapped I/O operations as the default behavior.</p>
</blockquote>
<ul>
<li><p><a href="">WSAAccept </a> 和 </p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsarecv">WSARecv</a></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET                             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// A pointer to an array of WSABUF structures.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSABUF                           lpBuffers,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// The number of WSABUF structures in the lpBuffers array.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwBufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpNumberOfBytesRecvd,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// A pointer to a WSAOVERLAPPED structure</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSASend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET                             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSABUF                           lpBuffers,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwBufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpNumberOfBytesSent,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 C++</title>
    <url>/2016/07/30/learnSche_cpp/</url>
    <content><![CDATA[<p>跌跌撞撞，兜来绕去，终究还是在 C++ 这个圈子里。毕业时，因为身外事去选择工作单位，而工作单位决定了工作性质，决定了自己处在做软件的边缘，甚至一度成为网管。两年之后跳出陷阱时，背负着“过去的选择”走进了 C++ 的世界，因为一无所长，在诸多技术更迭交替的 IT 圈我像个刚入门的新人似的，只了解一点点 VC++。我没有从头来过的魄力，我也并不清楚 Java 是否更有前途，互联网是否更多辛苦。</p>
<p>在毕业刚好三年的边上，想着“就是 C++ 了”其实很愚蠢。通过做决定安慰自己“明智”，其实只是没得选择的妥协。此时此刻应该想的是“如何学好 C++”，更现实一点“掌握 C++ 的哪些内容，能找到更好的工作”。暂时确定的目标：</p>
<ol>
<li>会写代码。强调编码规范。</li>
<li>会编写类，使用类。强调抽象思维。</li>
<li>数据库操作，封装</li>
<li>并发（多线程），POSIX、boost、C++11原生支持</li>
<li>通信，socket 编程</li>
</ol>
<p>曾经完美主义，现在坚持实用主义。站在公司的角度考虑，现实中生产使用，强调实用性。如果新特性带不来生产力上的提升，是不会有公司买账的。就是说是否掌握 C++11 甚至更新的特性，对找工作没有最直接的影响，如果带不了更高的生产力，都是空谈。不应该只为了关注新特性，学究式地死板地投入时间精力，要明白花时间做一件事的初衷、目的、意义和价值。举例来说，做并发时是否使用 C++11 的原生支持，在投产使用时没有什么影响的，重要的是能否解决问题，解决问题的能力，关键是把并发做出来，用什么技术往往并不重要。</p>
<p>那就好好学 C++11。工欲善其事，必先利其器。有兴趣可以看看<a href="http://www.csdn.net/article/2012-08-13/2808540">各编译器对 C++11 的支持情况</a>、<a href="http://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a>，但选择 g++ 总是省心的，前提是版本足够新，有条件就用最新的。编译器有了，<strong>编辑</strong>代码呢？主要关注代码提示，开发者体验。</p>
<ul>
<li>在 Windows 上考虑使用 VS2015，<a href="https://www.zhihu.com/question/23776769">轮子哥的观点 - 知乎</a>。个人观点，除了太大并不排斥 VS。</li>
<li>Linux 上呢？很难找到完善支持 C++11 代码提示的 IDE…<a href="http://zuyunfei.com/2013/05/16/killer-plugin-of-vim-youcompleteme/">Vim代码补全</a></li>
<li><a href="https://www.zhihu.com/question/22096642">Vim 和 IDE 之争 - 知乎</a>，个人观点，两者会越来越像，追求生产力。</li>
</ul>
<a id="more"></a>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在此介绍基础知识，惯用函数，std::string常用方法，常用容器的使用等等，原则就是“作为日常编写代码时的参考”。</p>
<h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p>我把 C++ 学习过程中整理的帖子分为三类：</p>
<ol>
<li>code？这个名字待定，多是一些基本操作、函数的用法等等，标题可以用“如何XXXX”开篇的</li>
<li>idioms 惯用法，包括 RAII 等，广义上还包括设计模式在内</li>
<li>concept 概念，指对 C++ 中概念的理解，广义上包括对关键词的理解</li>
<li>others 比如学习计划、学习书籍和学习笔记等，但也都和 C++ 有关。这个不再单拎出来，就在 cpp 下</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>LIB和DLL，MT(d)和MD(d)</title>
    <url>/2017/04/19/lib-dll-mt-md/</url>
    <content><![CDATA[<p>2016/3/26 20:02:05</p>
<h1 id="静态库（LIB）和动态库（DLL）"><a href="#静态库（LIB）和动态库（DLL）" class="headerlink" title="静态库（LIB）和动态库（DLL）"></a>静态库（LIB）和动态库（DLL）</h1><p>放两个链接，以后再一次用到时再做整理。</p>
<ul>
<li><a href="http://www.cppblog.com/amazon/archive/2009/09/04/95318.html">LIB和DLL的区别与使用</a></li>
<li><a href="http://www.cnblogs.com/kex1n/archive/2011/09/06/2168435.html">静态链接与动态链接的区别</a></li>
</ul>
<p>关于“导入库”：</p>
<ul>
<li><a href="http://www.cnblogs.com/chio/archive/2008/08/05/1261296.html">动态链接库dll，静态链接库lib, 导入库lib</a></li>
<li><a href="http://www.cnblogs.com/skynet/p/3372855.html">C++静态库与动态库</a></li>
</ul>
<a id="more"></a>

<h1 id="VS运行时库"><a href="#VS运行时库" class="headerlink" title="VS运行时库"></a>VS运行时库</h1><p>同上，以后用到时再做整理。</p>
<ul>
<li><a href="http://blog.csdn.net/ybxuwei/article/details/9095067">visual studio运行时库MT、MTd、MD、MDd的研究</a></li>
<li><a href="http://blog.csdn.net/tomorrowsprogress/article/details/5704233">MTD和MDd导致的问题</a></li>
<li><a href="http://qimo601.iteye.com/blog/1550348">VC 运行时库 /MD、/MDd 和 /MT、/MTd</a></li>
</ul>
<h1 id="动态库和-C"><a href="#动态库和-C" class="headerlink" title="动态库和 C++"></a>动态库和 C++</h1>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>硬链接是别名；软链接关键在于路径</title>
    <url>/2017/03/20/ln-command/</url>
    <content><![CDATA[<p>2015年12月1日 20:00:13</p>
<p>结论在前：如果不使用相对路径，则软链接、硬链接再怎么交叉混用都不会有问题。</p>
<ul>
<li>ln 直接创建硬链接到目标目录，和创建到当前目录，再mv到目标目录，效果一致。硬链接就是别名，全场通用。注意其应用限制。</li>
<li>ln 的软链接关键在于依据路径是否能查找到文件。软链接的关键在于路径。</li>
<li><strong>cp 操作，总是拷贝原文件到新副本，和链接毫无关联。</strong></li>
</ul>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmq@baba-db01:~/lib&gt; ls -l | grep source</span><br><span class="line">-rwxr-xr-x 1 rmq mq 3893576 Dec  1 09:08 source</span><br><span class="line">rmq@baba-db01:~/lib&gt; ln source source.ln #创建硬链接</span><br><span class="line">rmq@baba-db01:~/lib&gt; ln -s source source.lns_relative #使用相对路径创建软连接</span><br><span class="line">rmq@baba-db01:~/lib&gt; ln -s /data/rmq/lib/source source.lns_absolute #使用绝对路径创建软连接</span><br><span class="line">rmq@baba-db01:~/lib&gt; ln source.lns_relative source.lns_relative.ln #创建软连接的硬链接</span><br><span class="line">rmq@baba-db01:~/lib&gt; ln source.lns_absolute source.lns_absolute.ln</span><br><span class="line">rmq@baba-db01:~/lib&gt; ls -li | grep source #查看文件类型、inode值</span><br><span class="line">106570762 -rwxr-xr-x 2 rmq mq 3893576 Dec  1 09:08 source</span><br><span class="line">106570762 -rwxr-xr-x 2 rmq mq 3893576 Dec  1 09:08 source.ln</span><br><span class="line">106570766 lrwxrwxrwx 2 rmq mq      20 Dec  1 09:34 source.lns_absolute -&gt; /data/rmq/lib/source</span><br><span class="line">106570766 lrwxrwxrwx 2 rmq mq      20 Dec  1 09:34 source.lns_absolute.ln -&gt; /data/rmq/lib/source</span><br><span class="line">106570765 lrwxrwxrwx 2 rmq mq       6 Dec  1 09:34 source.lns_relative -&gt; source</span><br><span class="line">106570765 lrwxrwxrwx 2 rmq mq       6 Dec  1 09:34 source.lns_relative.ln -&gt; source</span><br><span class="line">rmq@baba-db01:~/lib&gt; </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ln-command-1.png"></p>
<p>1-1. 硬链接和原文件是无法区分的，都是 ‘-’ 文件类型（文件）；<br>1-2. 软链接相当于windows系统下的快捷方式，但是区分相对路径、绝对路径；【建议不要用相对路径】<br>1-3. 软链接的硬链接是 ‘l’ 文件类型（link）；硬链接其实就是别名。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ln-command-2.png"></p>
<p>2-1. cp操作， 依据相对路径创建的软链接？依据文件类型不再为 ‘l’ ，猜测已失效。但是实际上cp 是不复制软链接、硬链接的<br>——实际验证【补充验证方法】，是有效的。因为文件类型不再，且文件大小与原文件（非软链接）大小一致，猜测cp softlinkname 实际拷贝的是原文件，而不是快捷方式。可通过删除源文件验证。<br>2-2. 依据绝对路径创建的软链接？同上<br>2-3. cp操作，<del>硬链接其实都已失效；</del><br>——参考2-1，cp操作拷贝的是原文件，是针对文件类型为 ‘-’ 的文件，是（A）对原文件的userdata（datablock）创建副本、绑定新的metadata（inode、filename），或者（B）没有创建userdata（datablock）的副本，只是绑定了新的metadata（inode、filename）。参考rm 操作、inode和链接计数器（link count），估计应该是前者A。<br>2-4. 综上，cp操作之后都文件类型肯定是 ‘-’（暂不考虑目录‘d’），且硬链接数目肯定是 1<br>2-5. 对不存在的文件nielong创建软链接niel，然后cp niel 提示文件不存在。变相证明了 2-1的论点。下图：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ln-command-3.png"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/ln-command-4.png"></p>
<p>3-1. mv 操作，依据相对路径创建的软链接失效，在当前目录中映射“source”文件失败；在其基础上的硬链接同样映射“source”文件失败；<br>3-2. 原文件的硬链接？依据 inode 值，猜测有效。<br>——经验证，有效。<br>3-3. 依据绝对路径创建的软链接？在当前目录中映射“/data/rmq/lib/source”文件成功；在其基础上的硬链接？同上；</p>
<h1 id="结论在最后"><a href="#结论在最后" class="headerlink" title="结论在最后"></a>结论在最后</h1><p>综述：如果不使用相对路径，则软链接、硬链接再怎么交叉混用都不会有问题。</p>
<ul>
<li>ln 直接创建硬链接到目标目录，和创建到当前目录，再mv到目标目录，效果一致。硬链接就是别名，全场通用。注意其应用限制。</li>
<li>ln 的软链接关键在于依据路径是否能查找到文件。软链接的关键在于路径。</li>
<li><strong>cp 操作，总是拷贝原文件到新副本，和链接毫无关联。</strong></li>
</ul>
<p>延伸阅读：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解 Linux 的硬链接与软链接</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>std::map遍历删除元素</title>
    <url>/2016/11/03/map-erase/</url>
    <content><![CDATA[<h1 id="std-map遍历删除元素"><a href="#std-map遍历删除元素" class="headerlink" title="std::map遍历删除元素"></a>std::map遍历删除元素</h1><p>对容器进行增、删元素操作，可能会使迭代器失效，甚至影响 <code>begin() end()</code> 返回值。——关于这一点，需要复习《C++ Primer》。</p>
<ul>
<li>如果一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用。否则会导致程序无定义的行为。</li>
</ul>
<h2 id="平台间的区别"><a href="#平台间的区别" class="headerlink" title="平台间的区别"></a>平台间的区别</h2><p>顺序容器的 <code>erase()</code> 操作返回指向删除元素下一个元素的迭代器。</p>
<p><code>map.erase()</code> 有 3 个重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span> <span class="params">( iterator position )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">( <span class="keyword">const</span> key_type&amp; x )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span> <span class="params">( iterator first, iterator last )</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 <code>iterator</code> 的<code>erase()</code> 是不符合 STL 标准的。</p>
<a id="more"></a>

<p>见到过这样一句：</p>
<blockquote>
<p>The truth is that ‘erase’ in associative containers doesn’t invalidate any iterators except those that point to elements being erased (that’s also true for ’sid::list’). For this reason, you don’t really need ‘map::erase’ to return an iterator. Just do this</p>
</blockquote>
<p>但是 windows 平台下 map 就有</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator _Where )</span></span></span><br></pre></td></tr></table></figure>
<p>类似顺序容器的操作。</p>
<h2 id="正确的写法"><a href="#正确的写法" class="headerlink" title="正确的写法"></a>正确的写法</h2><p>正确的写法：（只需要记住正确的写法，其他的即便不是错的也是不规范的）</p>
<ol>
<li>使用删除之前的迭代器定位下一个元素。<strong>STL建议的使用方式</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ITER iter=mapTest.begin();iter!=mapTest.end();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    mapTest.erase(iter++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>erase()</code> 成员函数返回下一个元素的迭代器 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ITER iter=mapTest.begin();iter!=mapTest.end();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 在windows下可以，但是在linux下不行。</span></span><br><span class="line">    iter=mapTest.erase(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>有料的博客</title>
    <url>/2016/12/14/memo-url/</url>
    <content><![CDATA[<p>书山有路勤为径</p>
<h1 id="有料"><a href="#有料" class="headerlink" title="有料"></a>有料</h1><ul>
<li><a href="https://program-think.blogspot.com/">编程随想的博客</a></li>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://www.midphoto.com/chinese/chinese.htm">杨飞工作室</a></li>
<li><a href="http://www.playpcesor.com/">電腦玩物</a></li>
<li><a href="http://sspai.com/tag/android">少数派-Android</a></li>
<li><a href="http://www.rainymood.com/">雨声</a></li>
</ul>
<h1 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h1><ul>
<li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">Linux工具快速教程</a></li>
<li><a href="http://linux-wiki.cn/">Linux 中文知识库</a></li>
<li><a href="http://blog.jobbole.com/82633/">有哪些实用的计算机相关技能，可以在一天内学会？</a></li>
<li><a href="http://www.cnblogs.com/haippy/p/3284540.html">C++11 并发指南系列 - cnblogs</a></li>
</ul>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2019/11/29/memoryLeak/</url>
    <content><![CDATA[<h1 id="检查内存泄漏"><a href="#检查内存泄漏" class="headerlink" title="检查内存泄漏"></a>检查内存泄漏</h1><p>Linux 下使用 Valgrind；Windows 下使用 Visual Leak Detector。前者没接触过，后者的确不错。</p>
<p>虽然在 Windows 下可以使用 CRT：<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2017">Find memory leaks with the CRT library</a>，但因为其也会报全局变量以及 <code>static</code> 变量（报告早于这两者的析构），当项目体量较大，全局变量或 <code>static</code> 变量较多时，没有有效的区分，查找真实的内存泄漏就会比较棘手。</p>
<ol>
<li><p>Enable memory leak detection，如何启用</p>
<p> 只在启用 <code>_DEBUG</code> 时有效；若程序存在多个退出点，可以使用 <code>_CrtSetDbgFlag</code> 函数；报告默认在“输出”窗口打印，但可以自定义。</p>
</li>
<li><p>Interpret the memory-leak report，报告怎么看</p>
<p> 重点强调了检测只针对 <code>malloc</code> 函数，无法检测 <code>new</code> 操作符。但其提供了使用 <code>_malloc_dbg</code> 实现的 <code>operator new</code> 重载版本：</p>
</li>
<li><p>Set breakpoints on a memory allocation number，如何打断点</p>
</li>
<li><p>Compare memory states，对比不同时刻的快照</p>
</li>
<li><p>False positives，误报现象</p>
</li>
</ol>
<a id="more"></a>

<p>虽然文章中特别提到：</p>
<blockquote>
<p>We don’t recommend you create a preprocessor macro named <code>new</code>, or any other language keyword.</p>
</blockquote>
<p>但是在好多中文博客中都是通过直接定义 <code>new</code> 的同名宏来避免对代码主体的修改（文件头和 main 的修改无可避免）：比如 <a href="https://www.zhihu.com/question/63946754/answer/215606096">vczh</a></p>
<p>在网络上找到一篇 <a href="https://blog.csdn.net/crybird/article/details/80907192">关于全局变量内存泄漏的误报和解决方案</a>，但并未验证。</p>
<h2 id="crt"><a href="#crt" class="headerlink" title="crt"></a>crt</h2><p>待补充</p>
<h2 id="vld"><a href="#vld" class="headerlink" title="vld"></a>vld</h2><p><a href="https://github.com/KindDragon/vld/wiki/Using-Visual-Leak-Detector">Using Visual Leak Detector</a>，其使用是非常简单的。建议在每个程序中都默认启用。</p>
<p><a href="https://blog.csdn.net/chaipp0607/article/details/79182471">VS内存泄漏工具Visual Leak Detector2.5.1安装与使用</a></p>
<h2 id="linux-平台内存泄漏"><a href="#linux-平台内存泄漏" class="headerlink" title="linux 平台内存泄漏"></a>linux 平台内存泄漏</h2><p><a href="https://blog.csdn.net/gatieme/article/details/51959654">Linux下几款C++程序中的内存泄露检查工具</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>从 static 到对象的内存布局</title>
    <url>/2016/11/03/memoryLayout/</url>
    <content><![CDATA[<p>2016/9/8 17:07:08</p>
<p>最近对于在类中使用的 <code>static</code> 有几个疑问，逐一列举并给出解惑。</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p>问题一：我们都知道 C++ 类的静态成员变量在<strong>使用前</strong>必须要初始化。可是为什么一定要初始化呢？如果不初始化，为什么报 ld 链接错误？</p>
<p>先强调一点，其中的使用包括在类的成员函数中对静态成员变量的访问。</p>
<p>如果对于类的内存模型稍微理解那么一点点，这个问题其实很简单。</p>
<ol>
<li><p>类的定义是在 POD 结构体的基础上进行了的升级，定义类本质上是对其普通成员变量（不包括静态成员变量）的封装，就是 C 中普通的结构体。</p>
</li>
<li><p>对于其静态成员变量，可以理解为在此结构体外<strong>声明</strong>的 C 语言<del>静态</del>变量，并且在结构体与<del>静态</del>此变量之间建立了某种映射关系（绑定）。</p>
</li>
</ol>
<a id="more"></a>

<ol start="3">
<li><p>对于其普通成员函数（非静态成员函数），可以理解为此结构体外声明的 C 语言普通函数，并且在结构体和此函数之间建立了某种映射关系（绑定），此函数只能通过此结构体（指此结构体类型的变量）访问（见补充1），且其访问结构体成员（及与之绑定的结构体外成员）时不用显式地指明结构体变量。</p>
<p> 补充1：为了表示其映射关系（从属关系），代码书写方式由 <code>func(structVar, para1, para2)</code> 的形式改进为 <code>structVar.func(para1, para2)</code> 的形式。</p>
<p> 我们会发现，上述普通函数必须传一个结构体类型的变量进去，这就是一个局限点。我们还需要一种没有此限制的函数，这就是静态成员函数的生态位了。</p>
</li>
<li><p>而中的静态成员函数，可以理解为结构体外的 C 语言普通函数，并且在函数和与结构体对应的变量之间建立了映射（绑定）关系，使得函数只能通过此结构体（包括结构体类型及此类型的变量）访问，通过变量访问其实还是转换成通过类型访问。因为通过类型访问所以并不需要变量，<code>func(para1, para2)</code> ，同时也因为并无实例化的变量，所以限制此种函数只能访问与结构体类型绑定的变量，而不能访问结构体成员。</p>
</li>
</ol>
<p>备注：以上理解并未考虑 virtual 动态绑定等复杂概念。</p>
<p>所以 C++ <strong>类中</strong>的 <code>static</code> 关键字与 C 中其原本的意义大相径庭；但 C++ <strong>类外</strong>的 <code>static</code> 和 C 语言中 <code>static</code> 意义相同。 </p>
<p>由此，我们就能理解类里面的静态成员变量只是个声明，并没有定义，没有分配内存，等同于 C 语言中只声明未定义的变量 <code>extern int value</code>，所以其使用方法也就与后者完全相同：</p>
<ol>
<li>使用前必须先定义，分配内存。否则，</li>
<li>编译时不会报错，编译器发现有声明，假设其定义在了别处，但链接时如果还找不到就会报错；</li>
</ol>
<h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>问题二：既然静态成员变量在使用前都需要初始化，那 <code>private</code> 修饰的私有静态成员变量怎么初始化呢？</p>
<p>先说结果：同 <code>public</code>，两者的初始化方式完全一致。见 <a href="http://stackoverflow.com/questions/185844/initializing-private-static-members">Initializing private static members</a></p>
<p>虽然我们可能困惑于其明明 <code>private</code>，可是为什么依然能够在类外<del>访问</del>定义？</p>
<blockquote>
<p>When we declare a static member variable inside a class, we’re simply telling the class that a static member variable exists (much like a forward declaration). Because static member variables are not part of the individual class objects (they get initialized when the program starts), you must explicitly define the static member outside of the class, in the global scope.</p>
<p>In the example above, we do so via this line:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Something::s_value = <span class="number">1</span>; <span class="comment">// defines the static member variable</span></span><br></pre></td></tr></table></figure>
<p>This line serves two purposes: it instantiates the static member variable (just like a global variable), and optionally initializes it. In this case, we’re providing the initialization value 1. If no initializer is provided, C++ initializes the value to 0.</p>
<p>Note that this static member definition is not subject（征服，控制） to access controls: you can define and initialize the value even if it’s declared as private (or protected) in the class. <a href="http://www.learncpp.com/cpp-tutorial/811-static-member-variables/">引用来源</a></p>
</blockquote>
<p>define/initialization 是允许的，但普通访问（modify/access）的确是不可以的。</p>
<blockquote>
<p>Private members of a class can only be accessed inside the class member functions, the same rule applies even to static members. To be able to modify/access your static members you will have to add a member function to your class and then modify/access the static member inside it. <a href="http://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private">引用来源</a></p>
</blockquote>
<h1 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h1><p>问题三：静态类是不是不会执行初始化函数？</p>
<p>我知道这个问题很蠢，问题本身也有错（C++ 没有静态类的概念）。但还是放在了这里，毕竟问题不是重点，重点是由此引出来的理解以及探索过程中掌握的知识。</p>
<p>C# 中有静态类的概念；但 C++ 中没有。再具体说，就是 C++ 中不存在使用 static 修饰类的情况。C++ 中倒是可以将类的所有成员（变量和函数）全部用 static 修饰，但这种情况把类设计成 singleton（单例）模式更好一点。另外，也可以考虑使用 namespace，虽然在隐藏成员变量上有那么一点点区别。</p>
<p>C# 提供了静态构造函数，但 C++ 中没有这个概念。所以，在 C++ 中如果 static 成员的初始化比较复杂，步骤很多，甚至需要调用某个函数来完成，难么我们如何初始化它呢？</p>
<blockquote>
<p>其实很多问题，前人都已经做了<strong>优美</strong>的解决方法，主动学习要好于闭门造车。所以Google一下，在stackoverflow高手们就给了一个更加接近于静态构造函数的方法：<a href="http://www.cnblogs.com/ider/archive/2012/04/10/cpp_static_constructor.html">引用来源</a></p>
<blockquote>
<p>To get the equivalent of a static constructor, you need to write a separate ordinary class to hold the static data and then make a static instance of that ordinary class.</p>
<p>（将需要使用static的数据用一个普通类来进行封装， 在该类的构造函数中进行所需的初始化步骤。然后在原来的类中定义一个该类的静态对象。)</p>
</blockquote>
</blockquote>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>上文中的对 C++ 对象的内存模型，是一种朴素的理解。</p>
<p>详细见 <a href="http://blog.csdn.net/ljianhui/article/details/45903939">C++对象模型之简述C++对象的内存布局</a> 及作者后续笔记 <a href="http://blog.csdn.net/ljianhui/article/details/46408645">C++对象模型之详述C++对象的内存布局</a></p>
<p>另有 <a href="http://www.cnblogs.com/kekec/archive/2013/01/27/2822872.html">c++对象内存模型【内存布局】</a></p>
<p>当对于继承、virtual 虚函数有运用的基础之后，回头重新学习。</p>
<p>[图说C++对象模型：对象内存布局详解][cnblog]</p>
<p>陈皓专栏：<a href="http://blog.csdn.net/haoel/article/details/3081328">C++ 对象的内存布局（上）</a>、<a href="http://blog.csdn.net/haoel/article/details/3081385">C++ 对象的内存布局（下）</a></p>
<h2 id="异议"><a href="#异议" class="headerlink" title="异议"></a>异议</h2><p>一方面在互联网上我们可以找到大量的关于“对象在 C++ 中如何布局”的帖子，系统性的，可验证的。另一方面《EC++》 条款27：尽量少做转型动作（P119） 中写到“应该避免做出‘对象在 c++ 中如何布局’的假设”。摘抄如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>...&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;...&#125;; </span><br><span class="line">Derived d; </span><br><span class="line">Base* pb = &amp;d;<span class="comment">//隐喻的将derived*转换成Base*</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们只是建立一个 base class 指针指向一个 derived class 对象，但有时候上述的两个指针值并不相同。这种情况下会有个偏移量在运行期被施行于 <code>Derived*</code> 指针身上，用于取得正确的 <code>Base*</code> 指针值。</p>
<p>上述例子表明，单一对象（例如一个类型为 Derived 的对象）可能拥有一个以上的地址（例如“以 <code>Base*</code> 指向它”时的地址和“以 <code>Derived*</code> 指向它”时的地址）。c，java，c# 不可能发生这种事，但 c++ 可能！实际上一旦使用多重继承，这事几乎一直发生着。即使是在单一继承中也可能发生。虽然这还有其他意涵，但至少意味着你通常应该避免做出“对象在 c++ 中如何布局”的假设，更不应该以此假设为基础执行任何转型动作。例如将对象地址转型成 <code>char*</code> 指针，然后在他们身上进行指针运算，几乎总是导致无意义（不明确）行为。</p>
</blockquote>
<blockquote>
<p>但请注意，我说的是有时候需要一个偏移量。对象的布局方式和他们的地址计算方式随编译器的不同而不同，那意味着“由于知道对象如何布局”而设计的转型，在某一平台行的通，在其他平台并不一定行得通。这个世界上有许多悲惨的程序员，他们历经千辛万苦才学到这堂课。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 标准及其语法</title>
    <url>/2016/12/15/messOfMarkdown/</url>
    <content><![CDATA[<p>Markdown 简洁好用是毋庸置疑的。但是在使用中碰到过以下几个困惑：</p>
<ol>
<li><p>第一次想在 wiz 中使用 Markdown 笔记时，查阅 <a href="http://www.wiz.cn/feature-markdown.html">为知笔记 Markdown 新手指南</a> 发现代码的渲染效果挺好，挺喜欢的。可实际上把我在 MarkdownPad2 中写好的笔记拷贝过去时，发现代码的渲染效果和 MarkdownPad2 中一样素净，并没有语法高亮。进而发现两者关于代码的语法定义是有区别的。</p>
</li>
<li><p>不单单代码，在 <a href="http://www.wiz.cn/feature-markdown.html">为知笔记 Markdown 新手指南</a> 中提到的好些特性我在 MarkdownPad2 中并不能使用：</p>
<blockquote>
<p>如果你是名程序员，那么可以用 ``` 把代码块包起来，渲染后可以关键字高亮</p>
<p>删除线：在文字前后添加 ~~</p>
<p>目录</p>
</blockquote>
</li>
<li><p>在手机上购买 <a href="http://2appstudio.com/jotterpad/">jotterpad</a> 之后，发现代码部分的渲染效果和 MarkdownPad2 也不一样，更加的不起眼，导致最开始时我还以为 jotterpad 不识别代码语法呢。</p>
</li>
</ol>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>直到今天（2016年6月1号）才发现，Markdown 是存在标准之乱的。从最早的 <a href="http://daringfireball.net/projects/markdown/">Markdown诞生</a>（称为传统 Markdown，Markdown Basics等），流行起来之后各种扩展，在 GitHub 上最盛行的 <a href="https://help.github.com/enterprise/11.10.340/user/articles/github-flavored-markdown/">GitHub Flavored Markdown (GFM)</a>， 做标准的 <a href="http://commonmark.org/">CommonMark</a>。</p>
<p>其中，做标准让大家欣喜，<a href="https://ruby-china.org/topics/21391">Markdown 发布标准了</a>（借此理解行末两空格的意义），但也遇到了 <a href="https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">极大的困难</a>，理解英文有困难的话可以看 <a href="http://www.infoq.com/cn/news/2014/09/markdown-commonmark">Markdown的标准化之路</a>。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>关于三款应用：</p>
<ol>
<li><p>为知笔记使用哪种标准？在其官网未找到相关说明。猜测至少是以GFM为蓝本的，甚至就是用的GFM。</p>
</li>
<li><p>MarkdownPad2 可以更改“Markdown 处理器”。默认使用第一个</p>
<p> <img src="https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/MarkdownPad2_choices.png" alt="Markdown 处理器"></p>
</li>
<li><p>在 <a href="http://2appstudio.com/jotterpad/">jotterpad</a> 的官网提示如下：</p>
<blockquote>
<p>JotterPad renders Markdown (CommonMark) syntax. </p>
</blockquote>
</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>关于语法（中文）：</p>
<ol>
<li><a href="https://github.com/younghz/Markdown">传统 Markdown</a></li>
<li><a href="https://www.zybuluo.com/techird/note/46064">GFM 格式说明</a></li>
<li><a href="http://yanxyz.github.io/commonmark-spec/">CommonMark Spec</a></li>
<li><a href="http://einverne.github.io/markdown-style-guide/zh.html">* Markdown 书写风格指南</a></li>
<li><a href="http://www.debug4.me/%E5%B7%A5%E5%85%B7/markdown-learning/">Markdown标准语法与GitHub Flavored Markdown语法大全</a></li>
</ol>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关于 CommonMark：虽然不读英文，想来是撕逼过的。</p>
<blockquote>
<p>CommonMark，最早的名字叫 Standard Markdown，后来迫于 Markdown 原作者 John Gruber 的压力而改名。</p>
</blockquote>
<p>有人觉得“无规矩不成方圆”，没有标准的话未来发展空间有限；也有同志认为正是因为没有标准，才会出现各种扩展，百花齐放。</p>
<p>扩展阅读：</p>
<ol>
<li><a href="http://blog.chrisyip.im/markdown-and-commonmark">Markdown and CommonMark</a></li>
<li><a href="http://ju.outofmemory.cn/entry/141265">互联网中的左派与右派</a></li>
</ol>
<p>其实，操那么多心做什么，作为程序员，哪块用得着拿哪块，用不着的少参与。</p>
<p>争论并不重要，重要的是 <a href="https://github.com/xitu/gold-miner/blob/master/TODO/choosing-right-markdown-parser.md">选择使用正确的 Markdown Parser</a></p>
<p>ps 这篇备忘录整理完之后命名为《Markdown 标准之乱》，在半年以后（2016/12/15 16:40:38 ）发布时改为现在的名字。内容未做任何修改，我觉得原先的标题是整理的初衷与当时的感慨，但并不切合整理后成稿的内容。况且我现在用 Markdown 基本就是在用 GFM 了，半年前的困扰和选择已然过去了。</p>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>MindManager</title>
    <url>/2017/04/17/mindmanager/</url>
    <content><![CDATA[<p>2016年1月5日 14:43:50</p>
<p>思维导图的重要性不言而喻。</p>
<p>最近两年主要使用思维导图来做知识整理（634所期间），但是在换工作之后最近的这两个月内，因为做笔记的需求大增，所以大多直接整理知识到wiz，而不再使用思维导图做中间过渡。以前知识流线为：</p>
<ol>
<li>在 chrome 浏览器中创建分级目录，保存有关网页为书签。同时善用 chrome 同一账号不同设备的同步功能；第一次过滤知识</li>
<li>不定期的整理书签到思维导图。一般当 chrome 中的书签目录饱和，分级超 3 层时，进行迁移。这个过程对之前保存的书签进行二次的过滤</li>
<li>进一步在 wiz 中总结，整理出学习笔记；</li>
</ol>
<a id="more"></a>

<p>目前略过了第 2 步，直接使用 chrome 中的书签，整理写学习笔记。偶尔写半天笔记，会发现这个笔记真心没必要花费功夫，过滤不够。</p>
<p>目前制作思维导图使用的工具是 Mindjet MindManager：</p>
<ul>
<li><a href="http://www.mindmanager.cc/zhucema-jihuoma-xuliehao.html">各版本MindManager注册码-激活码-序列号地址</a></li>
<li><a href="http://www.weiyu.la/2013/2332.html">Mindjet MindManager 14.0.334 正式发布（最后更新：2013-11-11）</a></li>
</ul>
<p>ps：目前在用的版本和中文汉化包，都在百度云盘中上传了备份。<a href="mailto:&#x6e;&#105;&#x65;&#x6c;&#x6f;&#110;&#x67;&#x32;&#x30;&#x31;&#52;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x6e;&#105;&#x65;&#x6c;&#x6f;&#110;&#x67;&#x32;&#x30;&#x31;&#52;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/mindmanager/117c25cd-6171-4608-b210-336c5df6f9cc.jpg" alt="启动时弹出对话框"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>在C++类中创建线程函数</title>
    <url>/2016/11/03/multiThread/</url>
    <content><![CDATA[<p>在这篇学习总结中，我们先给出在C++类中定义线程函数的方法，然后讲述在多线程下很容易发生的资源竞争的特例——析构竞态。</p>
<h1 id="在C-类中定义线程函数"><a href="#在C-类中定义线程函数" class="headerlink" title="在C++类中定义线程函数"></a>在C++类中定义线程函数</h1><p>参考：<a href="http://rangercyh.blog.51cto.com/1444712/795759">在C++类中定义线程函数的方法</a></p>
<p>在多线程的开发中，一般都是把线程函数写成全局函数来使用。但是如果要把线程操作写成类，线程函数放在类里面呢？</p>
<p>下意识地会把线程函数写作普通的类函数，但这样子是有问题的。因为在创建线程的 api 中传入的线程函数需要在编译时确定地址，如果是普通的类函数，编译时不能确定地址，需要创建类的对象才能获取。我们可以把线程的执行函数写成 static 函数，或者是全局函数，因为这两者的函数地址在编译时是确定的。</p>
<p>两者的区别：static 在形式上能够体现“包装”性，能够保全类的封装性；全局函数貌似通过命名空间也能提供“包装性”呢，破坏类的封装性。实际业务中，我个人更倾向于前者——使用类的静态函数作为线程入口函数。</p>
<a id="more"></a>

<h2 id="static-函数"><a href="#static-函数" class="headerlink" title="static 函数"></a>static 函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CThread.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> m_tid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>;      <span class="comment">//线程启动</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;  <span class="comment">//静态函数。使用类中的成员</span></span><br><span class="line">    <span class="comment">// static void* threadFunc2();       //静态函数。用不到类中的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CThread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&quot;CThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CThread::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaaaa-----\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CThread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_create(&amp;m_tid, <span class="literal">NULL</span>, threadFunc, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// pthread_create(&amp;m_tid, NULL, threadFunc2, NULL);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CThread::threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CThread *obj = <span class="keyword">static_cast</span>&lt;CThread*&gt;(arg);</span><br><span class="line">    obj-&gt;Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CThread obj;</span><br><span class="line">    obj.start();</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><p>对 CThread 类做出修改，放弃静态函数，使用全局函数作为线程入口函数。并且需要“暴露”类中有关成员，以便线程入口函数使用。（例子中直接将有关成员的访问属性改为了 <code>public</code>，其它方案比如，可以将全局函数声明为 CThread 的友元函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CThread.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_t</span> m_tid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>;      <span class="comment">//线程启动</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CThread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&quot;CThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>; <span class="comment">//全局函数。使用类中的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc2</span><span class="params">()</span></span>;         <span class="comment">//全局函数。用不到类中的成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CThread::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaaaa-----\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CThread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_create(&amp;m_tid, <span class="literal">NULL</span>, threadFunc, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// pthread_create(&amp;m_tid, NULL, threadFunc2, NULL);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CThread *obj = (CThread*)arg;</span><br><span class="line">    obj-&gt;Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;say hello.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将-join-放入析构函数"><a href="#将-join-放入析构函数" class="headerlink" title="将 join() 放入析构函数"></a>将 join() 放入析构函数</h2><p><a href="https://tnie.github.io/2016/11/03/RAII/">RAII</a>，一般译为“资源获取即初始化”，虽然此中文表达理解起来很不直观，但无奈其广泛使用。我更喜欢《EC++》中侯捷老师的翻译“资源取得时机便是初始化时机”（P63）。</p>
<p>因为在 <code>main()</code> 中进行 <code>sleep()</code> 操作以等待线程很丑陋，我们使用 <code>join()</code> 做出修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CThread.cpp  类新增 wait() 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CThread::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_tid)</span><br><span class="line">        pthread_join(m_tid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp  使用 obj.wait() 替换 sleep()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CThread obj;</span><br><span class="line">    obj.start();</span><br><span class="line">    <span class="comment">//sleep(20);</span></span><br><span class="line">    obj.wait();    <span class="comment">// 根据业务，一般多放在进程最后，结束的前一刻</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">上述代码存在一个小瑕疵，在进程结束时（`main()` 函数结尾）要求用户记得调用 `CThread::wait()` 函数。当存在多个线程时，即便用户没有忘记或者落下 `objXXX.wait()`，在 `main()` 末尾“缀着”好几行 `wait()` 仍然是**不**优雅的。</span><br><span class="line"></span><br><span class="line">在上述基础上，我们更进一步，将 `wait()` 函数放入到 CThread 类的析构函数中，以期达到“自动释放”（即在 `main` 函数结束，超出 obj 作用域时自动调用析构函数）时“自动调用 join”的目的。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">CThread::~CThread()</span><br><span class="line">&#123;</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止还是正确的。</p>
<h1 id="析构竞态"><a href="#析构竞态" class="headerlink" title="析构竞态"></a>析构竞态</h1><p>在这里我们不对“析构竞态”进行详细的分析、讲解，只需要先了解其概念就可以。简单来说，析构竞态就是一个线程在析构某对象时 &amp; 另一线程在访问此对象，此时发生的不良现象。</p>
<p>关于析构竞态的延伸阅读：</p>
<ul>
<li>先看析构竞态的现象：<a href="http://blog.csdn.net/liuxuejiang158blog/article/details/12882555">C++析构竞态</a></li>
<li>深入分析析构竞态的问题，推荐 <a href="http://www.cnblogs.com/Solstice/archive/2010/02/10/dtor_meets_threads.html">当析构函数遇到多线程 - 陈硕的 Blog</a>。作者在文中给出了线程安全的解决方案</li>
</ul>
<h2 id="线程基类"><a href="#线程基类" class="headerlink" title="线程基类"></a>线程基类</h2><p>为了避免重复造轮子，我们将 CThread 作为线程基类，将 <code>Print()</code> 设为虚函数。这样子只要在派生类中实现（override）不同的操作就可以获得一个新的线程类。very nice 的想法！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;                                    </span></span></span><br><span class="line">                                                           </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span>                                              </span></span><br><span class="line"><span class="class">&#123;</span>                                                          </span><br><span class="line"><span class="keyword">private</span>:                                                   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// virtual int Print() = 0;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> m_tid;                                       </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wait</span><span class="params">()</span></span>;                                            </span><br><span class="line"><span class="keyword">public</span>:                                                    </span><br><span class="line">    <span class="keyword">virtual</span> ~CThread() &#123; wait(); &#125;                                 </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>;      <span class="comment">//线程启动                           </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;  <span class="comment">//使用类中的成员  </span></span><br><span class="line">    <span class="comment">// static void* threadFunc2();       //用不到类中的成员</span></span><br><span class="line">&#125;;                                                         </span><br><span class="line">                                                           </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrintB</span> :</span> <span class="keyword">public</span> CThread                             </span><br><span class="line">&#123;                                                        </span><br><span class="line"><span class="keyword">public</span>:                                                    </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span>                                      </span></span><br><span class="line"><span class="function">  </span>&#123;                                                        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bbbbbbbbb-----\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                            </span><br><span class="line">  &#125;                                                        </span><br><span class="line">                                                           </span><br><span class="line">&#125;;                                                         </span><br></pre></td></tr></table></figure>
<p>但这样子就会有问题了！</p>
<ul>
<li><p>如果我们如下使用我们新定义的派生类 CPrintB，会发现输出很奇怪——一直在打印 a，而非预期的 b。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    CPrintB obj;</span><br><span class="line">	    obj.start();</span><br><span class="line">	    <span class="comment">//sleep(5);</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">- 如果我们之前将 `Print()` 声明为纯虚函数，那么运行上述代码会直接崩溃报错：</span><br><span class="line"></span><br><span class="line">	```console</span><br><span class="line">	cts@babj-srv01:~/niel/git_test/test&gt; ./a.out &gt; output.txt</span><br><span class="line">	pure <span class="keyword">virtual</span> method called</span><br><span class="line">	<span class="built_in">terminate</span> called without an active exception</span><br><span class="line">	Aborted</span><br><span class="line">	cts@babj-srv01:~/niel/git_test/test&gt; </span><br></pre></td></tr></table></figure>
<p>  相同情况见：<a href="http://airekans.github.io/cpp/2012/04/12/pthread-c-wrapper">由pthread C++ wrapper引发的血案</a></p>
</li>
<li><p>而如果我们取消 <code>main()</code> 中对 <code>sleep()</code> 的注释，就会打印 b，而非 a。</p>
</li>
</ul>
<h2 id="析构竞态-1"><a href="#析构竞态-1" class="headerlink" title="析构竞态"></a>析构竞态</h2><p>存在资源竞争的代码，永远意味着输出的不确定性。</p>
<p>上述继承体系 + main 函数就是滋生“析构竞态”的温床，只是 <code>sleep()</code> 人为地让主线程等待避免了竞争。但主线程 <code>sleep()</code> 结束之后，子线程如果未执行完毕……虽然此场景隐藏得比较深，但其的确是“析构竞态”的例子。</p>
<p>将类定义和 main 函数中的 <code>sleep()</code> 全部注释掉（这样子更容易发生竞争），并且循环创建 &amp; 销毁 CPrintB 对象（通过多次执行保证小概率结果能够出现），就会看到打印输出的内容，实际上是不确定的。</p>
<p>其中的原因在于，如果将 <code>pthread_join()</code> 放在（基类）析构函数中，那么执行 <code>pthread_join()</code> 的时机（子类）对象【很可能】已经不完整了，具体取决于（子类）对象析构的时机（也就是 <code>sleep()</code> 带来的影响）。</p>
<p>C++ 的析构流程和构造流程完全相逆：</p>
<ul>
<li>构造流程：基类构造 - 列表初始化（与初始化顺序无关，只与数据成员定义的顺序有关）（即便无显式初始化列表，也会发生成员变量的初始化） - 调用构造函数</li>
<li>析构流程：调用派生类析构函数 - 成员变量析构 - 基类析构</li>
<li>延伸阅读： <a href="http://blog.csdn.net/gaoyingju/article/details/8790233">理解构造函数、析构函数执行顺序</a>、<a href="http://gaocegege.com/Blog/cpp/cppclass">构造析构顺序</a></li>
</ul>
<p>子类对象的析构是在主线程中发生的，在另一线程中执行 <code>threadFunc()</code> 发生动态绑定，执行子类的成员函数。如果析构先发生，那么派生类对象的派生类部分已经释放掉了，（然后基类析构的时候才会调用 <code>pthread_join()</code>，阻塞主线程以等待子线程）此后的行为是未定义的，发生什么都可能。<strong>需要强调的是</strong>，如果此时访问派生类对象的成员变量（我们的例子中没有访问类成员变量），程序是非常容易崩溃的：成员函数可能脱离对象存在，但成员变量声明周期肯定同对象。</p>
<p>ps：如果真的碰到这么写的代码，可以考虑在派生类析构函数中调用 <code>wait()</code>，但需要作出修改保证不会对线程重复 join。</p>
<p>在 stackoverflow 上针对同样问题的问答：<a href="http://stackoverflow.com/questions/1802418/race-between-virtual-function-and-pthread-create">Race between virtual function and pthread_create</a></p>
<h1 id="多线程是不好的？"><a href="#多线程是不好的？" class="headerlink" title="多线程是不好的？"></a>多线程是不好的？</h1><p>线程同步、线程竞争造成的应用程序错误往往难以调试：不易复现，可能在某台机器频繁出现，在另外的机器就不会出现；而且即便应用程序不出错，在同步方面也是隐含着问题的，只是其出错条件苛刻，但其线程上下文的错误路径是存在的。</p>
<p>接触多线程后，容易滥用，造成过多地创建线程，在 cpu 切换线程时浪费资源。</p>
<p>我们认为必须引入多线程，单线程解决不了的场景，多是因为同步 IO 造成的效率瓶颈，结合异步 IO 能够带来很好的提升。但异步 IO 掌握起来更难，调试也并不容易。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>微软和 Visual C++</title>
    <url>/2016/11/02/netAndvs-setup/</url>
    <content><![CDATA[<p>微软、Visual Studio 和 Visual C++ 那些事……</p>
<h1 id="NET-框架"><a href="#NET-框架" class="headerlink" title=".NET 框架"></a>.NET 框架</h1><p>.NET 框架（.NET Framework）的 <a href="https://zh.wikipedia.org/wiki/.NET%E6%A1%86%E6%9E%B6">维基百科</a> 中有很详细的阐述，其中的 <a href="https://zh.wikipedia.org/wiki/File:DotNet.svg">组件堆栈图</a> 一目了然，对于 <a href="https://zh.wikipedia.org/wiki/.NET%E6%A1%86%E6%9E%B6#.NET_vs._Java_EE">.NET vs. Java EE</a> 和 <a href="https://zh.wikipedia.org/wiki/.NET%E6%A1%86%E6%9E%B6#.NET_vs._COM">.NET vs. COM</a> 的介绍也言简意赅。以下摘取几句，做笔记。</p>
<blockquote>
<p>.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、F#、VB.NET、C++、Python等）的开发。</p>
<p>通用中间语言被设计来<strong>即时编译（JIT）</strong>，而Java的字节码在最初的时候则是设计成用于<strong>解释运行</strong>，而非即时编译。</p>
<p>前一版软件组件技术由Microsoft所提出的COM，该技术被用来创建大型（large-scale）的软件系统上，使用COM+ 或MTS对于传统分布式组件有强化的作用。很明显的，Microsoft最终将以.NET全面替换COM成为软件组件的架构。</p>
</blockquote>
<h2 id="NET-的语言"><a href="#NET-的语言" class="headerlink" title=".NET 的语言"></a>.NET 的语言</h2><blockquote>
<p>CLI是一套运作环境规范，包括一般系统、基础类库和与机器无关的中间代码，全称为Common Language Infrastructure。如果一种语言实现生成了CLI，它也可以通过使用CLR被调用，这样它就可以与任何其他.NET语言生成的数据相交互。CLR也被设计为操作系统无关性。</p>
<p>CLI被设计成支持任何面向对象的编程语言，分享共同对象模型与大型共同类库。</p>
</blockquote>
<blockquote>
<p>大部分的语言都做了重大改变以搭配.NET框架。厂商通常利用这个机会来同时改变语言的其他特性。</p>
</blockquote>
<ol>
<li><p>C#，一个以C++和Java语法为基础开发的一个全新的面向对象语言，是.NET开发的首选语言。</p>
<p> 我们圈外人以为做 C# 的就是 .NET，其实前者只是后者的官方开发语言。</p>
</li>
<li><p>Visual Basic .NET，一个加强了面向对象支持的，支持多线程的Visual Basic版本。</p>
<p> VB .NET 和 VB 不同。</p>
</li>
<li><p>C++/CLI，一个C++的.NET平台版本变种。</p>
<p> 接下来我们就说说这个。</p>
</li>
</ol>
<h1 id="托管-C-和-C-CLI"><a href="#托管-C-和-C-CLI" class="headerlink" title="托管 C++ 和 C++/CLI"></a>托管 C++ 和 C++/CLI</h1><blockquote>
<p>托管C++并非独立存在的编程语言，而仅仅是微软对C++的一个<strong>语法扩展</strong>，允许C++程序员在.NET框架和CLR的基础上进行托管编程。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%89%98%E7%AE%A1%E6%89%A9%E5%B1%95">C++ 托管扩展</a>（Managed Extensions for C++，也经常被称为“托管 C++”）自Visual C++ 2005起被正在标准化的C++/CLI所替换。</p>
</blockquote>
<blockquote>
<p>目前只有托管C++及其后继者C++/CLI可以做到无缝集成托管和非托管代码，在托管代码中调用COM的速度又相当慢（所以用非托管代码调用咯），所以经常被用于其他语言和非托管代码之间的桥梁。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/C%2B%2B/CLI">C++/CLI</a>（CLI: Common Language Infrastructure）在计算机语言中是一门由微软设计，用来代替C++托管扩展（Managed C++，下文使用MC++指代）的语言。这门语言在兼容原有的C++标准的同时，重新简化了托管代码扩展的语法，提供了更好的代码可读性。</p>
</blockquote>
<h1 id="托管代码和本地代码"><a href="#托管代码和本地代码" class="headerlink" title="托管代码和本地代码"></a>托管代码和本地代码</h1><p>在维基百科 <a href="https://zh.wikipedia.org/wiki/%E5%8F%97%E6%8E%A7%E4%BB%A3%E7%A2%BC">托管代码</a> 的词条中提及托管代码的运行：</p>
<blockquote>
<p>运行代码时，运行库编译器（runtime-aware compiler）在受控运行环境下，将中间语言（Intermediate Language）编译成本机的机器码。<strong>受控运行环境</strong>可为代码插入垃圾回收、异常处理、类型安全、数组边界和索引检查等，以保证代码安全的运行。</p>
</blockquote>
<p>另有 <a href="http://blog.csdn.net/suhuaiqiang_janlay/article/details/6004909">博客</a> 介绍的很好。</p>
<blockquote>
<p>Visual Basic .NET和C#只能产生托管代码。如果你用这类语言写程序，那么所产生的代码就是托管代码。如果你愿意，Visual C++ .NET可以生成托管代码。当你创建一个项目的时候，选择名字是以.Managed开头的项目类型。例如.Managed C++ application。</p>
<p>跟Visual Studio平台的其他编程语言不一样，Visual C++可以创建非托管程序。当你创建一个项目，并且选择名字以M FC，ATL或者Win32开头的项目类型，那么这个项目所产生的就是非托管程序。</p>
</blockquote>
<p>托管代码和非托管代码性能的比较：理解这个问题的关键在于对“即时编译器”和“解释器”是否有正确的认识。</p>
<blockquote>
<p>.Net程序被加载入内存以后，当某段IL代码被第一次运行的时候，JIT编译器就会将这段IL代码，全部编译成本地代码，然后再执行。这也就是为什么.NET程序第一次运行都启动很慢的原因！ 随.NET库，微软还附带了一个工具，可以事先将.NET程序所有的IL代码都编译成本地代码并保存在缓存区中，这样一来，这个程序就跟c++编译的一模一样了，没有任何区别，运行时也可以脱离JIT了（这里不要混淆了，这里不是说可以脱离.NET库，而是说不需要在进行即时编译这个过程了）。</p>
<p>所以，请不要将.NET和Java混为一谈，两个的运行效率根本不是一个等级的！</p>
</blockquote>
<h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><p>我们在 VS2010 中更习惯使用 Visual Studio Installer 打包项目，进行安装和部署。但不知什么原因（目前我还不知道，也没有在网上认真找过 <a href="https://blogs.msdn.microsoft.com/buckh/2011/03/17/visual-studio-setup-projects-vdproj-will-not-ship-with-future-versions-of-vs/">资料</a>），微软放弃了自家的这款工具，在 VS2012 中不再有，而只能用 InstallShield Limited Edition，同时更新过 VS2010 的朋友也会发现在“安装和部署”下除了原有的 Visual Studio Installer，也增加了 InstallShield LE 项目，看来微软是铁了心放弃 VS Installer 了，那我们也没有坚守的必要了。除非公司跟不上时代，否则还是早放弃的好。</p>
<p>在 stackoverflow 上 <a href="http://stackoverflow.com/questions/12378125/create-msi-or-setup-project-with-visual-studio-2012">Create MSI or setup project with Visual Studio 2012</a> 说了同一件事情。好在 InstallShield LE 太难用，最关键的是在对 ActiveX 控件、Windows services的支持上有 <a href="http://www.cnblogs.com/asxinyu/p/3306992.html">硬伤</a>，事情出现 <a href="https://blogs.msdn.microsoft.com/bharry/2014/04/18/creating-installers-with-visual-studio/">转机</a>，Visual Studio Installer 通过扩展的形式重新回到 VS 中，不过貌似只有 VS2013 和 2015 版本，但也足够了，你说呢？你要是死磕 VS2012，何必呢</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=UnniRavindranathan-MSFT.MicrosoftVisualStudio2013InstallerProjects">Microsoft Visual Studio 2013 Installer Projects </a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.MicrosoftVisualStudio2015InstallerProjects">Microsoft Visual Studio 2015 Installer Projects </a></li>
</ul>
<h1 id="预编译头"><a href="#预编译头" class="headerlink" title="预编译头"></a>预编译头</h1><ul>
<li><a href="http://blog.csdn.net/luoweifu/article/details/49010627">理解微软的预编译头技术 - csdn</a></li>
<li><a href="http://521-lion.blog.163.com/blog/static/6662942920117236949606/">stdafx.h - 163</a></li>
<li><a href="http://blog.csdn.net/Nhsoft/article/details/11558">预编译头文件的使用 - csdn</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4">预编译头 - wikipidea</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>双网卡、内外网</title>
    <url>/2017/04/19/network/</url>
    <content><![CDATA[<p>2015年11月2日 16:21:18</p>
<p>参考：<a href="http://www.cnblogs.com/lightnear/archive/2013/02/03/2890835.html">Windows路由表配置：双网卡同时上公司内外网</a></p>
<p>我的网络环境：外网 &amp; 内网</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/1.png" alt="外网环境"></p>
<a id="more"></a>

<p>外网：通过网线，配置固定 IP 等信息连接 internet</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/2.png" alt="内网环境"></p>
<p>内网：连接无线路由器，ip 和 dns 地址全部自动获取。路由指定固定 ip-192.168.1.105</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>根据以上内容在 命令行窗口中以管理员权限操作，中间遇到以下问题（加粗部分）。</p>
<ol>
<li><p>起始时，连接网线，配置好 ip 等，正常上网；</p>
</li>
<li><p>连接无线路由器；此时上网出现异常，不能连接 internet</p>
</li>
<li><p>使用 <code>route print</code> 命令，可以看到有 2 条 0.0.0.0 的活动路由，造成上网冲突；</p>
</li>
<li><p><code>&gt;route delete 0.0.0.0</code> 操作完毕后，使用 <code>&gt;route print</code> 查看路由表。此时<strong>可能只删除了其中1条</strong>，再执行一次，将 0.0.0.0 的路由全部删除。</p>
</li>
<li><p>此时有线网络 IPv4 属性会失去“默认网关属性”，因为在 <code>delete</code> 操作中删除了</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/3.png" alt="失去默认网关"></p>
</li>
<li><p><code>&gt;route add 0.0.0.0 mask 0.0.0.0 10.10.44.1 -p</code> 执行完毕，重新能够上网。此条路由和之前 delete 的一条很相似，区别只有 2 点：此时添加的是永久路由，且 Metric 属性变动；（ps 查了查资料，没有完全弄清楚 Metric 的意义）</p>
</li>
<li><p><code>&gt;route add 0.0.0.0 mask 0.0.0.0 10.10.44.1 -p</code> 执行完毕，<strong>访问内网失败</strong>，查看路由表，发现问题</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/4.png" alt="路由表"></p>
</li>
<li><p><code>delete</code> 此条路由，执行 <code>&gt;route add 0.0.0.0 mask 0.0.0.0 10.10.44.1 IF 4 -p</code> 指定网卡，此时能够访问内网设备，<code>ping 192.168.1.108</code> 成功；</p>
</li>
<li><p>此时满足使用预期。</p>
</li>
<li><p>在电脑重启，或待机重启，或断开无线连接重连之后，<strong>路由表中会自动添加</strong></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/5.png" alt="自动添加"></p>
<p>造成上网失败，再手动删除此条路由（注意不能删除上面一条 0.0.0.0 的路由）正常。</p>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>IF 4</code> 是怎么来的？</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/network/6.png" alt="路由表"></p>
<p>延伸阅读：子网掩码是做什么用的？——<a href="http://baike.baidu.com/link?url=fZMn7_SHPhS5GAfzcqmJmUnFzuIM_G6AbZNRhI-Ok9A_GfXpr_VHs-6onC-Wu3NNVHYeQHK78cQOwFV9eWxid_">子网掩码百度百科</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>传值、传指针和传引用</title>
    <url>/2016/12/05/pass-parameters/</url>
    <content><![CDATA[<p>我们先从最简单的内置类型说起，结合汇编代码说说三者之间的联系和区别；然后我们再讲用户自定义类类型的三种传参方式的优劣。</p>
<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>内置类型的传值是最简单的，也是其他传参形式的基础。此处的“其它传参形式”指所有传参方式，包括内置类型的传指针、传引用，也包括自定义类类型的传值、传指针和传引用。</p>
<h2 id="传指针也是传值"><a href="#传指针也是传值" class="headerlink" title="传指针也是传值"></a>传指针也是传值</h2><p>内存地址（指针）也是一个数值，所以从汇编代码的层次看，传值和传指针其实是一样的（《Head First C》中也提到 C 语言所有的传参都是传值）。传值之后的操作更大程度上依赖于业务：</p>
<a id="more"></a>

<ol>
<li><p>传值（不包括传指针的情形），被调用函数声明为 <code>func(const int i)</code> 或 <code>func(int i)</code> 的形式，但后者在其多数的使用场景中其实并不规范，往往应该用 <code>const</code> 修饰。在 <code>func()</code> 的定义中一般不会对 i 进行取地址操作。这是最基础的使用情形。</p>
</li>
<li><p>传值（特指传指针），被调用函数多声明为 <code>func(int *pi)</code> 的形式，也有变种 <code>func(int * const pi)</code> 和 <code>func(const int *pi)</code>。传指针的应用场景又可以分为两种：</p>
<ul>
<li>需要解引用。一般使用场景为修改指针指向的值的内容，此时不可以声明为 <code>func(const int *pi)</code></li>
<li>不需要解引用。只是单纯的对指针做一些操作，比如重新指向，或者加减指针操作，此时不可以声明为 <code>func(int * const pi)</code></li>
</ul>
</li>
</ol>
<h2 id="引用的实现往往基于指针"><a href="#引用的实现往往基于指针" class="headerlink" title="引用的实现往往基于指针"></a>引用的实现往往基于指针</h2><p>广义的传值是包括传指针的。传引用，个人认为是对传指针的一种包装，更易于使用，更少的出错可能性。实际上引用的实现往往基于指针，我们可以粗略的认为“传引用 = 传指针 + 解引用”。传引用也可以分为两种使用场景：</p>
<ol>
<li>不会对引用进行取地址操作。这是最常用的情形。</li>
<li>会对引用进行取地址操作。这其实是存在性能浪费的，为什么不直接传指针呢？如果说你是回避指针，减少出错的可能性，但既然还是要取地址，那不如从一开始就面对；另一种可能性是函数定义中多数操作是非指针操作，取地址只是个小比例。</li>
</ol>
<h2 id="代码怎么写更好"><a href="#代码怎么写更好" class="headerlink" title="代码怎么写更好"></a>代码怎么写更好</h2><p>上述列举了 5 种代码场景，我们通过业务场景再进行一次分类：</p>
<h3 id="不改实参"><a href="#不改实参" class="headerlink" title="不改实参"></a>不改实参</h3><p>我们不需要在被调用函数中修改实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func(<span class="keyword">const</span> <span class="keyword">int</span> i);</span><br><span class="line">func(<span class="keyword">const</span> <span class="keyword">int</span>* pi);</span><br><span class="line">func(<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref);</span><br></pre></td></tr></table></figure>

<p>虽然上述 3 种都可以实现目的，但哪一种更好呢？先说结论，在《Effective C++》里提到</p>
<blockquote>
<p>对内置(C-like)类型在函数传参时pass by value比pass by reference更高效，当用OO的c++自定义类型(存在构造/析构等)pass by reference to const 更好，STL里的迭代器和函数对象是用C指针实现的，因此pass by value更好。</p>
</blockquote>
<p>我们先不讨论自定义类类型。如果有特殊的业务要求，比如要根据指针获得下一个内存块，那么使用指针更合适，但最普通的使用场景下，传指针（包括传引用）比传值多一个解引用步骤（传指针需要显示解引用，传引用是隐式解引用），除此之外两者的开销其实是一样的，就像前面提到的，在汇编代码层次，传递指针和传递数值指令是一样的。</p>
<h3 id="要改实参"><a href="#要改实参" class="headerlink" title="要改实参"></a>要改实参</h3><p>我们有修改实参的需求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func(<span class="keyword">int</span> * <span class="keyword">const</span> pi);</span><br><span class="line">func(<span class="keyword">int</span>&amp; ref);</span><br></pre></td></tr></table></figure>
<p>哪一种更好呢？如果没有必须使用指针的理由，为了减少出现错误的可能性，个人认为还是选择引用更好一些。貌似 Google 的编码规范中统一接口形式，要求使用指针。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>对于内置类型，传值比传引用更高效。虽然我无法确定内置类型没有构造函数（我个人倾向于没有构造的观点），参考 <a href="http://stackoverflow.com/questions/5113365/do-built-in-types-have-default-constructors">Do built-in types have default constructors?</a></li>
<li>内置类型的初始化和赋值成本一样（参考《Effective C++》 第28页）</li>
<li>来看 《Effective Modern C++》第 50 页的一句话，重点看我加粗的这一句。可以看出大师对“内置类型初始化和赋值区别”的态度——对于使用者来说，两者的区别不值一提。由此推断，对使用者来说可以认为两者的成本是一样的。同大师在上一版本的作品中给出的结论一致。</li>
</ol>
<blockquote>
<p>The “confusing mess” lobby points out that the use of an equals sign for initialization（使用 <code>=</code> 的初始化） often misleads C++ newbies into thinking that an assignment is taking place（误认为是赋值操作）, even though it’s not. <strong>For built-in types like int, the difference is academic</strong>（学术的，理论的）, but for userdefined types, it’s important to distinguish initialization from assignment</p>
</blockquote>
<h1 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h1><p>我们之前讨论内置类型时，提到一点“内置类型的传值和传引用（传指针），在撇开解引用步骤之外开销是一样的”。因为内置类型传值是传递一个数值，传指针也是传递一个数值。</p>
<p>我们都知道类类型是对数据的封装——对内置类型或类类型的封装，继承体系中派生类对基类的封装。只关注首尾，类其实是对很多个内置类型的数据成员的封装。从自然语义上说，类类型的传值得包括其所有数据成员的传值，如此就意味着得传递很多个（内置类型）数值了。从严格的语法定义上，类类型传值需要付出类对象初始化（拷贝构造）和销毁（析构）成本，而传引用（指针）可以通过“传地址 + 解引用”来避免这些成本，这基本上是稳赚的——类封装起来的内置类型成员越多，代价越大；而传地址只是传递一个数值，解引用只是一步寻址操作，成本是固定的。只封装一个内置类型成员的类多见于测试代码，实际应用中基本不会出现。</p>
<p>用户自定义的类类型，函数调用时传常量引用比传值更高效，因为前者不会有类对象初始化（拷贝构造）和销毁（析构）成本。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有的汇编指令都是对内存块的操作，其参数都是内存标记（寄存器或内存地址）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = i;</span><br><span class="line"><span class="comment">//008A181E  mov         eax,dword ptr [i]  </span></span><br><span class="line"><span class="comment">//008A1821  mov         dword ptr [j],eax</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = i;</span><br><span class="line">  <span class="comment">// 引用多用指针实现</span></span><br><span class="line"><span class="comment">//00DB179E  mov         eax,dword ptr [i]     // 跟传指针一样。直接将 [] 中的 i 臆想为 pi</span></span><br><span class="line"><span class="comment">//00DB17A1  mov         ecx,dword ptr [eax]   // </span></span><br><span class="line"><span class="comment">//00DB17A3  mov         dword ptr [j],ecx</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = *pi;</span><br><span class="line"><span class="comment">//009C181E  mov         eax,dword ptr [pi]    // 将内存地址 pi 中的数据（pi 的值，即 i 的地址）赋给eax</span></span><br><span class="line"><span class="comment">//009C1821  mov         ecx,dword ptr [eax]   // 将内存地址 eax 中的数据赋给 ecx，ecx 得到 i 的值</span></span><br><span class="line"><span class="comment">//009C1823  mov         dword ptr [j],ecx</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//008A1908  mov         dword ptr [value],0Ah  // 将 0Ah 赋给内存地址 value 中的数据</span></span><br><span class="line">  Print(value);</span><br><span class="line"><span class="comment">//008A190F  mov         eax,dword ptr [value]  // 将内存地址 value 中的数据赋给 eax</span></span><br><span class="line"><span class="comment">//008A1912  push        eax</span></span><br><span class="line"><span class="comment">//008A1913  call        Print (08A111Dh)  </span></span><br><span class="line"><span class="comment">//008A1918  add         esp,4  </span></span><br><span class="line">  Print2(value);</span><br><span class="line"><span class="comment">//00DB191B  lea         eax,[value]            // 将 value 存储单元的有效地址（偏移地址）传送到 eax。</span></span><br><span class="line"><span class="comment">//00DB191E  push        eax  </span></span><br><span class="line"><span class="comment">//00DB191F  call        Print2 (0DB1082h)  </span></span><br><span class="line"><span class="comment">//00DB1924  add         esp,4 </span></span><br><span class="line">  Print3(&amp;value);</span><br><span class="line"><span class="comment">//009C4317  lea         eax,[value]  </span></span><br><span class="line"><span class="comment">//009C431A  push        eax  </span></span><br><span class="line"><span class="comment">//009C431B  call        Print3 (09C1370h)  </span></span><br><span class="line"><span class="comment">//009C4320  add         esp,4  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
  </entry>
  <entry>
    <title>PKM 整理记录</title>
    <url>/2017/04/19/pkm/</url>
    <content><![CDATA[<h1 id="2016年3月20日-16-57-20"><a href="#2016年3月20日-16-57-20" class="headerlink" title="2016年3月20日 16:57:20"></a>2016年3月20日 16:57:20</h1><p>不能西瓜芝麻一起捡！筛选信息关键在于过滤，过滤掉那些价值低、随时间贬值快、内容表述糟糕的博客、文章和笔记等，值得在 wiz 和大象中花费时间整理总结的是那些半衰期长、价值高的内容。个人偶尔的牢骚也是不值得记录的，只有那些经过反复思考、辩证过的蜕变成长才值得记录。</p>
<p>如果泥沙俱下，都往 wiz 和大象里誊抄，一方面放弃了信息过滤这一层保障，另一方面也会浪费自己大量的时间，累死人。</p>
<p>即便是以前付出过心血的东西，该放弃时也要丢弃。懂得取<strong>舍</strong>，也要知行合一。</p>
<a id="more"></a>

<p>该走的不走，誊抄整理浪费当下的精力不说，将来仍要付出时间成本的。ps：很尴尬一件事是，从互联网直接搜索某知识花费的时间成本基本忽略不计，可我会保存到 chrome 浏览器，然后整理到 wiz 中，所花费的时间成本很大。这里面就存一个值不值得的问题！</p>
<p>整理到 wiz 的目的是什么？是为了将来搜索时从一个更小的范围中搜索吗，即便搜索用的时间一样？如果是这个目的，那么 Delicious 其实更适合。</p>
<p>那么 wiz 的价值是什么？</p>
<h1 id="2016-3-17-9-39-40"><a href="#2016-3-17-9-39-40" class="headerlink" title="2016/3/17 9:39:40"></a>2016/3/17 9:39:40</h1><p><del>任务一：清理版本控制文档包，太大了。控制在 50M 以内，以文档为准！不能当作同步盘使用</del><br><del>（目前偏离版本控制本意，往同步盘方向偏得太多）</del><br><del>任务二：参考月光博客，pkm 个人知识管理，用的哪些工具？有什么技巧？</del><br><del>任务三：以过滤信息为准则，清理 chrome 书签</del></p>
<p>执行过程中……</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/knowledge&info.png" alt="知识和信息"></p>
<ol>
<li><p>发现自己的一个问题：保存链接和保存文章混淆在了一起。</p>
<p> ——链接介于信息和知识之间，是有转化为知识潜在价值、潜在必要的信息，是信息过滤的第一站。既然如此，那么链接更接近于信息。链接分两类：一类只存储书签直到其信息价值随时间而丧失；一类存储书签以备二次过滤，誊抄/写文章，整理完毕之后删除。</p>
<p> 而文章，是查阅相关资料、经过反复理解甚至实践试验的知识的总结。它是从某一知识点的书签中反复阅读、过滤整理而来。</p>
<p> （以前是 chrome 书签&gt;&gt;&gt;思维导图&gt;&gt;&gt;&gt;笔记，后来发现思维导图并不适用在这里，抽掉中间环节后缺少了一层过滤，导致笔记中内容良莠不齐，泥沙俱下，也累坏了我）</p>
<p> 目前打算使用 Delicious</p>
</li>
<li><p>思维导图是脑中知识等内容的快照，更棒的是这个快照能够修正更新。所有的思维导图应该从版本库中移除，用到大象或者 wiz 中，它是用来呈现思维扩散、知识结构的，而不是以升级更新为目的。思维导图从最初创建时就不应该放在版本库中。即便有后续的调整，那么在 wiz 中做一次替换也就足够了。</p>
<p> ——思维导图只是写学习笔记、个人日记中的素材而已，类似于图片。</p>
<p> 同理，版本控制中的其他内容，如果已经稳定，不再有计划内的内容修改。就该从版本库中移除了。该去云存储之类的地方了。</p>
<p> 目前打算使用 Dropbox，之前试用为什么放弃了？好像是因为墙。</p>
<p> ——更倾向于使用 Dropbox 而非 Onedrive 的原因，除了排斥微软之外，我需要在两台笔记本之间同步（个人笔记本和工作笔记本绑定了不同的微软账户），所以……</p>
</li>
<li><p>Dropbox 被墙，使用 xx-net 解决不了问题。另外 xx-net 的模式切换也出现问题，一怒之下购买了 Bandwagon，一键安装 Shadowsocks 之后，开始了付费翻墙的日子。Chrome 插件里的 SwitchOmega 陪伴了我两年，是到了应该放弃的时候了。xx-net 的位置腾出来，让给 SS。</p>
</li>
</ol>
<h1 id="2016-3-19"><a href="#2016-3-19" class="headerlink" title="2016/3/19"></a>2016/3/19</h1><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/2fbad643-d449-4001-87d8-c801e38bf856.png" alt="来源：PKM流程图.vsdx"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/f50b8b64-3889-4b43-abbe-c5b165670b93.png" alt="图片"></p>
<p>Chrome 书签每周六清理之后，只保留一两周之内会重复用到的内容。<strong>及时清理！要保存更要删除</strong>。清理时，价值低的信息及时删除。对于专业技术成长核心的内容整理笔记到Wiz，（因为时间有限）其余的迁至 Delicious 保存。一定要<strong>过滤删除</strong>后再往 Delicious 上存储。<br>过滤之后剩余的 bookmarks，如果近期不会用到（半个月？），而且没有计划向 wiz 中整理，则统统迁到 Delicious 上存储。</p>
<h1 id="2016-3-26-19-22-51"><a href="#2016-3-26-19-22-51" class="headerlink" title="2016/3/26 19:22:51"></a>2016/3/26 19:22:51</h1><p>补充 Chrome 书签目录：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/e8145bdb-185a-4ff1-8f64-abd29f2bfd31.png" alt="来源：Chrome书签目录.mmap"></p>
<ul>
<li><a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/PKM%E6%B5%81%E7%A8%8B%E5%9B%BE.vsdx">附件一：PKM流程图.vsdx</a></li>
<li><a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/pkm/Chrome%E4%B9%A6%E7%AD%BE%E7%9B%AE%E5%BD%95.mmap">附件二：Chrome书签目录.mmap</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>复合类型（指针、引用）</title>
    <url>/2016/05/31/pointer&amp;reference/</url>
    <content><![CDATA[<p>当一条声明语句中包含多个指针，或者混用数组的时候，每每傻傻分不清。</p>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><p>在《C++ Primer》P38页，2.2节中描述到</p>
<blockquote>
<p>变量定义的基本形式是：首先是<strong>类型说明符</strong>（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p>
<p>列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值：<code>int a=0, b, c=3;</code></p>
</blockquote>
<p>ps：稍后再对变量的定义和声明做区分，对于初始化和赋值做区分。</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>P45页，2.3节描述如下</p>
<blockquote>
<p>一个简单的声明语句由……。更通用的描述是，一条声明语句由一个<strong>基本数据类型</strong>（base-type）和紧随其后的一个<strong>声明符</strong>（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
</blockquote>
<p>P51页</p>
<blockquote>
<p>在同一条定义语句中个，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量。</p>
<pre><code>// i是一个int型的数，p是一个int型指针，r是一个int型引用。
int i = 1024, *p = &amp;i, &amp;r =i;</code></pre>
</blockquote>
<p>P53页</p>
<blockquote>
<p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</p>
</blockquote>
<pre><code>int *p, *&amp;r = p;  // r是一个对指针p的引用</code></pre>
<h2 id="数组是一种复合类型-（P101页）"><a href="#数组是一种复合类型-（P101页）" class="headerlink" title="数组是一种复合类型 （P101页）"></a>数组是一种复合类型 （P101页）</h2><p>数组中元素的个数也属于数组类型的一部分。</p>
<p>P102页</p>
<blockquote>
<p>默认情况下，类型修饰符从右向左依次绑定。理解复杂的数组声明，由内向外，从右向左。</p>
</blockquote>
<pre><code>int *ptrs[10];  // ptrs是含有10个元素的数组，数组元素是int型指针
int *(&amp;array)[10] = ptr;  // array是数组的引用，该数组含有10个指针
//
int (*Parray)[10];  // Parray是一个指针，指向一个含有10个整数的数组</code></pre>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>reference to const，对常量的引用；不存在const reference，以为引用不是对象。</p>
<blockquote>
<pre><code>const int ci = 1.24;
const int &amp;r1 = ci;</code></pre>
</blockquote>
<p>pointer to const，指向常量的指针；const pointer，指针本身是常量。</p>
<blockquote>
<p>把<code>*</code>放在<code>const</code>关键字之前用以说明指针是一个常量。</p>
</blockquote>
<pre><code>const double pi = 3.1415;
const double *const pip = &amp;pi;</code></pre>
<blockquote>
<p>要想弄清楚这些生命的含义最行之有效的方法是从右向左阅读。</p>
</blockquote>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 C 函数，痛苦的移植性</title>
    <url>/2017/03/07/portability-about-C-functions/</url>
    <content><![CDATA[<p>2015年11月17日 17:09:46</p>
<p>有一个很好的链接：<a href="http://ganquan.info/standard-c/">Standard C 语言标准函数库速查</a>。不在其中的自然就不是 C 标准库中的函数，不过有一点点瑕疵，这个速查的搜索功能不好用。</p>
<ol>
<li>即便是标准库中的函数，在不同平台也是会有差异的（但标准规定的部分应该是相同的）。比如：<code>fflush</code>、<code>fopen</code>；</li>
<li>不在标准库中的函数：不同的平台使用了相似（甚至相同）的名字实现了相似的功能，所谓“相似”则必然有不同，其中的区别就是我们编码过程中的<strong>陷阱</strong>！（极端一点）可以认为只是不同平台不同实现选择了相同的名字而已。比如：<code>snprintf</code>、<code>access</code> 并不是标准 c 标准或者 c++ 标准中规定的函数。</li>
</ol>
<a id="more"></a>

<h1 id="snprintf-在-VC-和-GCC-上的不同"><a href="#snprintf-在-VC-和-GCC-上的不同" class="headerlink" title="snprintf 在 VC 和 GCC 上的不同"></a><a href="http://blog.csdn.net/bweaglegao/article/details/8539754"><code>snprintf</code> 在 VC 和 GCC 上的不同</a></h1><p><code>printf</code>、<code>sprintf</code> 属于 I/O库 函数，<code>snprintf</code> 函数并不是标准 c/c++ 中规定的函数，但是在许多编译器中，厂商提供了其实现的版本。其声明同样放在了声明 “standard input &amp; output”（标准输入输出）的 <code>&lt;stdio.h&gt;</code> 中。 <strong>在 gcc 中，该函数名称就 <code>snprintf</code>；而在 VC 中称为 <code>_snprintf</code>。</strong></p>
<h2 id="在windows下："><a href="#在windows下：" class="headerlink" title="在windows下："></a>在windows下：</h2><ol>
<li>VC 中的 <code>_snprintf</code> 的 count 参数（第二个参数）表示，会向 buff 中写入 count 个字符，不包括 <code>&#39;\0&#39;</code> 字符；</li>
<li>并且不会在字符串末尾添加 <code>&#39;\0&#39;</code> 符；</li>
<li>并且，如果字符串（第三个参数）超过 count，函数返回 <code>-1</code> 以标志可能导致的错误；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/snprintf-in-vc.png" alt="windows-snprintf"></p>
<h2 id="在linux下："><a href="#在linux下：" class="headerlink" title="在linux下："></a>在linux下：</h2><p>参考 <a href="http://blog.csdn.net/crfoxzl/article/details/2062139"><code>snprintf</code> 函数用法</a></p>
<ol>
<li>gcc 中的 <code>snprintf</code> 函数的 count 参数（第二个参数）表示，向 buff 中写入 count 个字符，包括 <code>&#39;\0&#39;</code> 字符；</li>
<li>并且，若成功则返回欲写入的字符串长度，若出错则返回负值；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/snprintf-in-gcc.png" alt="linux-snprintf"></p>
<h1 id="access-函数，注意参数含义"><a href="#access-函数，注意参数含义" class="headerlink" title="access 函数，注意参数含义"></a><code>access</code> 函数，注意参数含义</h1><ul>
<li>在windows下：<a href="http://blog.sina.com.cn/s/blog_69ebf25c0100m57t.html">Access函数判断文件是否存在</a></li>
<li>在linxu下：<a href="http://blog.sina.com.cn/s/blog_6a1837e90100uh5d.html">linux C之access函数</a></li>
</ul>
<p>两者的<strong>头文件自然不同</strong>。而且两者的参数列表和类型虽然相同，但是<strong>第2个参数取值具体的含义却不同</strong>。</p>
<h1 id="慎用-fflush-stdin-清空输入缓存流"><a href="#慎用-fflush-stdin-清空输入缓存流" class="headerlink" title="慎用 fflush(stdin) 清空输入缓存流"></a><a href="http://my.oschina.net/deanzhao/blog/79790">慎用 <code>fflush</code>(<code>stdin</code>) 清空输入缓存流</a></h1><p>怎么说这个函数呢，如果大家在C标准函数库里查找会发现这个是其中之一，但为什么还要把它放在这呢？来看一下 <strong>C99 对 <code>fflush</code> 函数的定义：</strong></p>
<blockquote>
<p><code>int fflush(FILE *stream);</code></p>
<p>如果 stream 指向输出流或者更新流（update stream），并且这个更新流最近执行的操作不是输入，那么 <code>fflush</code> 函数将把这个流中任何待写数据传送至宿主环境（host environment）写入文件。否则，它的行为是未定义的。</p>
</blockquote>
<p>原文如下：</p>
<blockquote>
<p><code>int fflush(FILE *stream);</code></p>
<p>If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.</p>
</blockquote>
<p>其中，宿主环境可以理解为操作系统或内核等。 由此可知，如果 stream 指向输入流（如 <code>stdin</code>），那么 <code>fflush</code> 函数的行为是不确定的。</p>
<ul>
<li><p>gcc 严格执行了标准，所以在 linux 下使用 <code>flush</code>(<code>stdin</code>) 是没有任何效果的，是不确定的，是不安全的；</p>
</li>
<li><p>但是在 VC 中使用 <code>flush</code>(<code>stdin</code>) 却可以清空输入缓冲。    看一下MSDN 文档，其中清楚地写着：</p>
<blockquote>
<p>fflush on input stream is an extension to the C standard（**<code>fflush</code> 操作输入流是对 C 标准的扩充**）。</p>
</blockquote>
</li>
</ul>
<p>故 <a href="http://blog.csdn.net/stpeace/article/details/9063293">fflush函数有什么作用？</a> 这篇帖子里的用法只能在 windows 下有效；在 linux 下是什么样子的并不能保证。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/the-output-of-fflush-in-windows.png" alt="windows 下使用 fflush"></p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/the-output-of-fflush-in-linux.png" alt="linux 下使用 fflush"></p>
<p>上图和windows下 注释掉fflush() 效果一致。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/the-output-without-fflush-in-windows.png" alt="windows 下注释掉 fflush"></p>
<h2 id="普遍用法"><a href="#普遍用法" class="headerlink" title="普遍用法"></a>普遍用法</h2><p><code>fflush(stdout)：</code></p>
<ul>
<li>头文件  ：#include &lt;stdio.h&gt;</li>
<li>函数定义：int fflush(FILE *stream)</li>
<li>函数说明：fflush()会强迫将缓冲区内的数据写回参数stream指定的文件中。如果参数stream为NULL， fflush()会将所有打开的文件数据更新。</li>
<li>返回值  ：成功则返回0,  失败返回EOF, 错误代码存于errno中</li>
</ul>
<p>用途：在使用多个输出函数连续进行多次输出时，有可能发现输出错误。因为下一个数据在上一个数据还没输出完毕，还在输出缓冲区中时，下一个 <code>printf</code> 就把另一个数据加入输出缓冲区，结果冲掉了原来的数据，出现输出错误。 在 <code>printf()</code> 后加上 <code>fflush(stdout);</code> 强制马上输出，例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;//unix环境</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fork();<span class="comment">//fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程,也就是两个进程可以做完全相同的事</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样输出一个hello</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//      fflush(stdout);</span></span><br><span class="line">        fork();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会输出两个hello</p>
<h1 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen() 函数"></a><code>fopen()</code> 函数</h1><p>函数用法 <a href="http://www.cnblogs.com/emanlee/p/4418163.html">C语言的fopen函数（文件操作/读写）</a>：</p>
<p>在 POSIX 系统，包含 Linux 下都会忽略 b 字符。由 <code>fopen()</code> 所建立的新文件会具有 <code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)</code> 权限，此文件权限也会参考 umask 值。 </p>
<p>二进制和文本模式的区别：</p>
<ul>
<li>在 windows系统中，文本模式下，文件以 <code>\r\n</code> 代表换行。若以文本模式打开文件，并用 <code>fputs</code> 等函数写入换行符 <code>\n</code> 时，函数会自动在 <code>\n</code> 前面加上 <code>\r</code>。即实际写入文件的是 <code>\r\n</code> 。</li>
<li>在类 Unix/Linux 系统中文本模式下，文件以 <code>\n</code> 代表换行。所以 Linux 系统中在文本模式和二进制模式下并无区别。</li>
</ul>
<p>文件操作类型：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据。</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则长度清为0，即该文件内容消失，若不存在则创建该文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF符保留)。</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会建立该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的EOF符 不保留)。</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或建立一个二进制文件，允许读和写。</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或建立一个文本文件，允许读写。</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>
</tr>
</tbody></table>
<h1 id="atoi-C标准库函数、itoa-非C标准库函数"><a href="#atoi-C标准库函数、itoa-非C标准库函数" class="headerlink" title="atoi() C标准库函数、itoa() 非C标准库函数"></a><code>atoi()</code> C标准库函数、<code>itoa()</code> 非C标准库函数</h1><p>如果是在 windows 平台下开发，上面两个 <code>int</code> 和 <code>char*</code> 字符串相互转化的函数应该都用过。想当然的也会认为这是一对函数，“夫妻双双……”。其实他俩的出身完全不同。</p>
<p>在笔记开篇给出了一个查询 C 标准库的链接，在 &lt;stdlib.h&gt; 常用系统函数中列出了以下：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/func-about-cstr.png" alt="字符串函数"></p>
<p>是不是觉得自己可以举一反三，猜到将浮点型转为字符串可以用函数 <code>ftoa()</code>，将整型数转为字符串可以用 <code>itoa()</code>……但你查遍 C 的标准库是不是也没找到你以为的 <code>itoa()</code> 函数。事实也正是如此！<strong>itoa并不是一个标准的C函数，它是Windows特有的。</strong></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>《ppp》读书笔记</title>
    <url>/2021/02/02/ppp-notes/</url>
    <content><![CDATA[<h1 id="类接口：保持接口的最小化"><a href="#类接口：保持接口的最小化" class="headerlink" title="类接口：保持接口的最小化"></a>类接口：保持接口的最小化</h1><p>p207</p>
<blockquote>
<p>当我们试图最小化类接口时（在保证完整性的前提下），不得不忽略大量有用的操作。如果一个函数可以简单、优美、高效地实现为一个独立函数时（即实现为非成员函数），就应该将它的实现放在类外。<strong>采用这种方式，函数中的错误就不会直接破坏类对象中的数据</strong>。p213</p>
</blockquote>
<h1 id="如何创建自己的-vector"><a href="#如何创建自己的-vector" class="headerlink" title="如何创建自己的 vector"></a>如何创建自己的 <code>vector</code></h1><p>预留空间 和 <code>std::allocator</code> 类</p>
<blockquote>
<p>注意，我们并不对预留空间中的元素进行初始化。 p329</p>
</blockquote>
<blockquote>
<p>我们需要处理非常尴尬的情况：数据结构同时包含已初始化数据和未初始化数据。p341</p>
</blockquote>
<p>因为内置的数值类型都是小对象，所以可以一律初始化，无需在意开销。但对于自定义类型，初始化要有的放矢。</p>
<p>TODO 还是要自己手动写出 <code>tnie::vector</code> 才行</p>
<p><code>std::allocator</code> 主要涉及 <a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html">new/delete 函数和操作符</a></p>
<blockquote>
<p>new operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>p337</p>
<blockquote>
<p>Binary_predicate&lt;P,T,U&gt;()：我们可以用两个类型分别为 T 和 U 的实参调用 P，得到一个布尔结果。<br>Binary_predicate&lt;B,T,T&gt;(): 我们可以用 B 对一个 T 和一个 U 执行一个操作。</p>
</blockquote>
<p>这两者的区别在哪？</p>
<h1 id="理解-std-function"><a href="#理解-std-function" class="headerlink" title="理解 std::function"></a>理解 <code>std::function</code></h1><p>传参时使用传值方式。原因是什么？</p>
<h1 id="用户界面的选择"><a href="#用户界面的选择" class="headerlink" title="用户界面的选择"></a>用户界面的选择</h1><p>p161</p>
<ul>
<li>使用控制台输入/输出：如果需要图形<strong>输出</strong>，我们可以使用一个<strong>图形显示库</strong>，不需要对我们的程序设计风格进行明显的修改。</li>
<li>使用图形用户界面（GUI）库：与图形显示库（只输出）是不同的</li>
</ul>
<h2 id="widget-概念"><a href="#widget-概念" class="headerlink" title="widget 概念"></a>widget 概念</h2><p>构件？</p>
<h1 id="未读章节"><a href="#未读章节" class="headerlink" title="未读章节"></a>未读章节</h1><p>1-4 前四章<br>15 容器和迭代器<br>16 算法和映射<br>20 绘制函数图和数据图<br>23 文本处理<br>24 数值计算<br>25 嵌入式系统程序设计<br>27 C 语言<br>附录</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>protobuf 压缩</title>
    <url>/2019/01/05/protobuf/</url>
    <content><![CDATA[<p>在 github 上我们能找到 protobuf 的 <a href="https://github.com/protocolbuffers/protobuf/releases">最新发布版本</a></p>
<p>在发布的压缩包中，我们只需要关注 protobuf-cpp-version.zip/tar.gz。有时 protobuf-version-win32.zip 也会让人疑惑，我们到底需不需要这个文件呢？让我们看一下其中的 readme.txt </p>
<blockquote>
<p>This package contains a precompiled binary version of the protocol buffer compiler (<code>protoc</code>). This binary is intended for users who want to use Protocol Buffers in <strong>languages other than C++</strong> but <strong>do NOT want to compile protoc</strong> themselves. </p>
</blockquote>
<p>简单说，是给 C++ 开发者之外的码农用的。</p>
<p>但是，If you intend to use the included well known types，我们还是需要下载后者的。毕竟前者中 <code>.proto</code> 原型混杂在了大量的头文件中，而这里的原型文件一目了然。</p>
<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>在解析文件服务器上的历史 k 线时，碰到了比较特殊的问题：</p>
<a id="more"></a>

<p><strong>通过 asio 网络通信 streambuf 解析正常</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_k::parsebody</span><span class="params">(asio::streambuf&amp; buf, yuanda::GluedK&amp; calstick)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//解析k线文件</span></span><br><span class="line">        yuanda::GluedCandleStickCombo combo;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::istream <span class="title">response_stre</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> success = combo.ParseFromIstream(&amp;response_stre))</span><br><span class="line">        <span class="comment">// ... true/success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是将文件下载下来，通过 fstream 解析时，个别文件正常，<strong>大多数文件在 ParaseFromIstream() 总是解释失败</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::fstream ff;</span><br><span class="line">ff.open(<span class="string">u8R&quot;(F:\_DayK\SH600000\glued_candlestick_SH600000_5_0_2000.data)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ff.is_open())</span><br><span class="line">&#123;</span><br><span class="line">    yuanda::GluedCandleStickCombo combo;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream <span class="title">is</span><span class="params">(ff.rdbuf())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> success = combo.ParseFromIstream(&amp;is))</span><br><span class="line">    <span class="comment">// ... false/fail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步调试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::fstream ff;</span><br><span class="line">ff.open(<span class="string">u8R&quot;(F:\_DayK\SH600000\candlestick_SH600000_5_0_2000.data)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ff.is_open())</span><br><span class="line">&#123;</span><br><span class="line">    yuanda::CandleStick calstick;</span><br><span class="line">    <span class="keyword">int</span> headsize = <span class="number">0</span>, bodysize = <span class="number">0</span>;</span><br><span class="line">    ff.read((<span class="keyword">char</span>*)&amp;headsize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ff.read((<span class="keyword">char</span>*)&amp;bodysize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">auto</span> kheader = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">char</span>&gt;(<span class="keyword">new</span> <span class="keyword">char</span>[headsize], [](<span class="keyword">char</span>* ptr) &#123; <span class="keyword">delete</span>[] ptr; &#125;);</span><br><span class="line">    <span class="keyword">auto</span> kbody = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">char</span>&gt;(<span class="keyword">new</span> <span class="keyword">char</span>[bodysize], [](<span class="keyword">char</span>* ptr) &#123; <span class="keyword">delete</span>[] ptr; &#125;);</span><br><span class="line">    ff.read(kheader.get(), headsize);</span><br><span class="line">    assert(ff.gcount() == headsize);</span><br><span class="line">    ff.read(kbody.get(), bodysize);</span><br><span class="line">    <span class="keyword">auto</span> s2 = ff.gcount();</span><br><span class="line">    assert(s2 == bodysize);  <span class="comment">// false 断言在此处失败</span></span><br></pre></td></tr></table></figure>
<p>查看 <code>std::basic_istream::read()</code> 的说明</p>
<blockquote>
<p>释出并存储字符，直至出现任何下列条件：</p>
<p>释出并存储了 count 个字符<br>输入序列上的文件尾条件（该情况下调用 <code>setstate(failbit|eofbit)</code> ）。成功释出的字符数能用 <code>gcount()</code> 查询。</p>
</blockquote>
<h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h2><p>文件尾 EOF 到底是什么呢？<a href="https://zh.wikipedia.org/wiki/%E6%9B%BF%E4%BB%A3%E5%AD%97%E7%AC%A6">替代字符 \0x1A</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/io/c#.E4.BA.8C.E8.BF.9B.E5.88.B6.E4.B8.8E.E6.96.87.E6.9C.AC.E6.A8.A1.E5.BC.8F">二进制与文本模式</a></p>
<p>默认以文本流打开文件，但文本流如果要保证与先前写入“一致”（与先前写到该文本流者比较相等）是有好多限制的，其中一条就是</p>
<blockquote>
<p>数据只由打印字符和控制字符 <code>\t</code> 及 <code>\n</code> 组成（尤其是 Windows OS 上，字符 ‘\0x1A’ 终止输入）</p>
</blockquote>
<p>二进制流，从二进制流读取的数据始终与先前写出到该流者比较相等。</p>
<blockquote>
<p>POSIX implementations do not distinguish between text and binary streams (there is no special mapping for <code>\n </code>or any other characters)</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2016/05/31/regex/</url>
    <content><![CDATA[<p>这两天工作上用到了 grep、sed、awk 文本处理命令。有心在业余时间花心思多掌握一些，在此前提下，发现熟悉正则表达式是很重要的。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>查阅维基百科，发现其中文词条 <a href="">正则表达式</a> 没有价值，个别的知识点即便有效也充斥在大量的垃圾信息里，此词条好似百度百科的众多词条，灌水横拉硬拽拼凑而成，或源于翻译英文词条时偷懒挑肥拣瘦，只翻译了一部分内容，却篡改章节目录造成“不成文”的感受。</p>
<p>其英文词条 [Regular expression][] 相对“丰满”一些，看目录至少提到了不同标准、不同流派，比中文词条要好。</p>
<p>参考 <a href="http://liujiacai.net/blog/2014/12/07/regexp-favors/">正则表达式“派别”简述</a>、<a href="http://blog.csdn.net/dreamerway/article/details/20700421">正则表达式 流派（flavor）及差异简介</a>，都明确指出了三种：</p>
<ul>
<li>BRE: Basic Regular Expression</li>
<li>ERE: Extended Regular Express</li>
<li>PCRE: Perl Compatible Regular Expression</li>
</ul>
<p>其中，前两者都是 POSIX: Portable Operating System Interface 的规范。</p>
<p>常见的编程语言中使用正则表达式的记法，其实都源于 Perl。</p>
<pre><code>&gt; 现在的编程语言中的正则表达式，大部分都属于 PCRE 这个分支。

&gt; 常见的正则表达式记法，其实都源于 Perl</code></pre>
<p>但在 POSIX 的系统上，有关的工具使用正则表达式，其记法与上述不同，大都要落于 BRE、ERE 这两者之中：</p>
<pre><code>&gt; － 使用BRE语法的命令有：grep、ed、sed、vim
&gt; 
&gt; － 使用ERE语法的命令有：egrep、awk、emacs</code></pre>
<p>需要补充的一点是，在 linux 上其有关工具对 BRE、ERE 语法是进行过扩充的，好比对 C 语言标准、C++ 语言标准进行的诸多 GNU 扩展。在 <a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux/Unix工具与正则表达式的POSIX规范</a> 中有提到 GNU 扩展的相关内容，在 <a href="http://liujiacai.net/blog/2014/12/07/regexp-favors/">正则表达式“派别”简述</a> 讲述 POSIX 标准时也提到了 GNU 扩展。</p>
<pre><code>&gt; GNU 在实现了 POXIS 标准的同时，做了一定的扩展</code></pre>
<h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expression)：<del>可以说是正则表达式的老前辈</del>（niel 注：需考证），它是从Perl衍生出来的一个显赫流派，<code>\d</code> <code>\w</code> <code>\s</code> 等表示法就是它的特征；</p>
<h2 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h2><p>BRE(Basic Regular Expression)：POSIX 规范的正则表达式之一，grep、vi、sed 都属于这一派，它显著的特征就是 <code>(</code> <code>)</code> <code>&#123;</code> <code>&#125;</code> 这几个括号元字符必须经过转义才具有特殊含义，不支持 <code>+</code> <code>?</code> <code>|</code> 等元字符，随着时间发展，后来又出现了 GNU BRE，GNU BRE 支持上边这些字符，但是也必须都经过转义才能有特殊含义；</p>
<h2 id="ERE"><a href="#ERE" class="headerlink" title="ERE"></a>ERE</h2><p>ERE(Extended Regular Express)：也是 POSIX 规范的正则表达式之一，egrep awk 都属于这一派，<code>(</code> <code>)</code> <code>&#123;</code> <code>&#125;</code> <code>+</code> <code>?</code> <code>|</code> 等元字符可以直接使用不需要转义，这个流派后来也出现了 GNU ERE，在之前的基础上添加了支持 <code>\1</code> <code>\2</code> 等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>不明觉厉的 <a href="http://www.greenend.org.uk/rjk/tech/regexp.html">各种语言或工具软件的不同风格的正则表达式文法规定</a>。</p>
<p>如果更关注使用有关工具时的细节，可以参考 <a href="http://www.cnblogs.com/finallyliuyu/archive/2013/05/27/3101220.html">Linux 中常用文本工具与正则表达式的关系 </a>。更多的语法细节还是要在用到的时候仔细查阅。</p>
<p>引擎 <a href="https://kb.cnblogs.com/page/86751/">正则表达式引擎及其分类</a></p>
<h1 id="55分钟学会正则表达式学习笔记"><a href="#55分钟学会正则表达式学习笔记" class="headerlink" title="55分钟学会正则表达式学习笔记"></a><a href="http://blog.jobbole.com/63398/">55分钟学会正则表达式</a>学习笔记</h1><p>建议看<a href="http://qntm.org/files/re/re.html">原文（英文）</a>比较好，译者也给出了原文的链接。翻译时译者不够细心，和原文相比有好几处错误，有的是很明显的上下文冲突，所以觉得译者根本就不用心。</p>
<p>前言部分，简单描述正则表达式是什么；之后讲解正则表达式的基础语法。</p>
<ul>
<li>正则表达式有可能出现语法错误——不是所有的字符串都是正则表达式<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2>理解“元字符”概念。</li>
</ul>
<p>普通字符只能匹配它们本身；元字符可以匹配一些特殊规则。使用反斜杠“\”可以忽略元字符，使得元字符的功能与普通字符一样。</p>
<h2 id="点“-”"><a href="#点“-”" class="headerlink" title="点“.”"></a>点“.”</h2><p>匹配任意一个字符</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>字符类是一组在方括号内的字符，表示可以匹配其中的任何一个字符。</p>
<blockquote>
<p>重要提示：字符类中和字符类外的规则有时不同，一些字符在字符类中是元字符，在字符类外是普通字符。一些字符正好相反。还有一些字符在字符类中和字符类外都是元字符，这要视情况而定！</p>
</blockquote>
<h3 id="字符类的范围"><a href="#字符类的范围" class="headerlink" title="字符类的范围"></a>字符类的范围</h3><p>在字符类中，你可以通过使用短横线来表示匹配字母或数字的范围。</p>
<h3 id="字符类的反义"><a href="#字符类的反义" class="headerlink" title="字符类的反义"></a>字符类的反义</h3><p>你可以在字符类的起始位放一个反义符^。</p>
<h3 id="Freebie-character-classes"><a href="#Freebie-character-classes" class="headerlink" title="Freebie character classes"></a>Freebie character classes</h3><blockquote>
<p>译者翻译为“转义字符类”，个人觉得不能够表达原作的味道。参考上下文及“freebie”单词原意，应该是要表达，和某些字符类表示相同意义的转义字符。</p>
<p>下文中Freebie multipliers 译为“关于重复的转义字符”。类比，此处译为“关于字符类的转义字符”就会好很多。</p>
</blockquote>
<ul>
<li>\d：[0-9]</li>
<li>\w：[0-9A-Za-z_]</li>
<li>\s：匹配一个空字符（空格，制表符，回车或者换行）</li>
<li>\D：[^0-9]</li>
<li>\W：[^0-9A-Za-z]</li>
<li>\S：匹配一个非空字符<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2>在字符或字符集之后，你可以使用{ }大括号来表示重复<h3 id="指定重复次数范围"><a href="#指定重复次数范围" class="headerlink" title="指定重复次数范围"></a>指定重复次数范围</h3><h3 id="Freebie-multipliers"><a href="#Freebie-multipliers" class="headerlink" title="Freebie multipliers"></a>Freebie multipliers</h3></li>
<li>?：{0，1}，重复0次或1次</li>
<li>*：{0，}，重复任意次（0次、1次或多次）</li>
<li>+：{1，}，重复1次以上（包括1次）</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 编程初步</title>
    <url>/2017/03/17/shell-programming/</url>
    <content><![CDATA[<p>写于2016/4/19 17:23:47</p>
<p>简单记录些小技巧，因为在阅读《嗨翻C语言》时发现在代码中使用Linux的系统工具会让编程方便很多。某个功能可能需要写好多行C代码，可如果在代码中调用系统命令，不单单节省工作量，代码的可读性也会提高。</p>
<a id="more"></a>

<blockquote>
<p>Unix界有一句名言：“一行shell脚本胜过万行C程序”，虽然这句话有些夸张，但不可否认的是，借助脚本确实能够极大的简化一些编程工作。比如实现一个ping程序来测试网络的连通性，实现ping函数需要写上200~300行代码，为什么不能直接调用系统的ping命令呢？</p>
</blockquote>
<ol>
<li>首先是在C程序中调用shell的调用方式：通常在程序中通过 system函数来调用shell命令。但是，system函数仅返回命令是否执行成功，而我们可能需要获得shell命令在控制台上输出的结果。例如，执行外部命令ping后，如果执行失败，我们希望得到ping的返回信息。参考<a href="http://www.cnblogs.com/hoys/archive/2011/05/11/2043027.html">从Linux程序中执行shell（程序、脚本）并获得输出结果（转）</a></li>
<li>其次，如果要使用shell完成稍微复杂的操作：那么shell程序、shell脚本怎么写呢？参考<a href="http://blog.csdn.net/compiler_hdz/article/details/575113">linux脚本编程(shell)浅介</a></li>
</ol>
<ul>
<li>扩展阅读：<a href="http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html">linux shell数据重定向（输入重定向与输出重定向）详细分析</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell 及环境变量 -1.4 其他</title>
    <url>/2017/04/25/shell-sub1/</url>
    <content><![CDATA[<p>2016年1月4日 10:05:04</p>
<h1 id="shell-及环境变量-1-4-其他"><a href="#shell-及环境变量-1-4-其他" class="headerlink" title="shell 及环境变量 -1.4 其他"></a><a href="/2017/04/24/shell/">shell 及环境变量</a> -1.4 其他</h1><h2 id="参数置换"><a href="#参数置换" class="headerlink" title="参数置换"></a>参数置换</h2><p>shell提供了参数置换能力以便用户可以根据不同的条件来给变量赋不同的值。参数置换的变量有四种，这些变量通常与某一个位置参数相联系，根据指定的位置参数是否已经设置类决定变量的取值，它们的语法和功能分别如下。</p>
<ul>
<li><code>变量=$&#123;参数-word&#125;</code>：如果设置了参数，则用参数的值置换变量的值，否则用 word 置换。即这种变量的值等于某一个参数的值，如果该参数没有设置，则变量就等于 word 的值。</li>
<li><code>变量=$&#123;参数=word&#125;</code>：如果设置了参数，则用参数的值置换变量的值，否则把变量设置成 word 然后再用 word 替换参数的值。注意，位置参数不能用于这种方式，因为在 shell 程序中不能为位置参数赋值。</li>
<li><code>变量=$&#123;参数?word&#125;</code>：如果设置了参数，则用参数的值置换变量的值，否则就显示 word 并从 shell 中退出，如果省略了 word，则显示标准信息。这种变量要求一定等于某一个参数的值，如果该参数没有设置，就显示一个信息，然后退出，因此这种方式常用于出错指示。</li>
<li><code>变量=$&#123;参数+word&#125;</code>：如果设置了参数，则用 word 置换变量，否则不进行置换。</li>
</ul>
<a id="more"></a>

<p>所有这四种形式中的“参数”既可以是位置参数，也可以是另一个变量，只是用位置参数的情况比较多。</p>
<h2 id="测试变量是否已经设置"><a href="#测试变量是否已经设置" class="headerlink" title="测试变量是否已经设置"></a>测试变量是否已经设置</h2><p>有时要测试是否已设置或初始化变量。如果未设置或初始化，就可以使用另一值。此命令格式为：<code>$ &#123;variable:-value&#125;</code>。意即如果设置了变量值，则使用它，如果未设置，则取新值。例如：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shellsub1/9f442c7b-c1ef-425a-a247-bd9145ef44c0.png" alt="例子"></p>
<p>上面的例子并没有将实际值传给变量，需使用下述命令完成此功能：<code>$ &#123;variable:=value&#125;</code></p>
<h2 id="设置只读变量"><a href="#设置只读变量" class="headerlink" title="设置只读变量"></a>设置只读变量</h2><p>如果设置变量时，不想再改变其值，可以将之设置为只读方式。如果有人包括用户本人想要改变它，则返回错误信息。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable-name&#x3D;value</span><br><span class="line">readonly variable-name</span><br></pre></td></tr></table></figure>
<p>设为只读后,任何改变其值的操作将返回错误信息。要查看所有只读变量，使用命令readonly即可。</p>
<p>以下两小节中提到的位置变量、预定义变量是系统保留的只读变量。</p>
<h2 id="位置变量"><a href="#位置变量" class="headerlink" title="*位置变量"></a>*位置变量</h2><p>如果要向一个shell脚本传递信息，可以使用位置参数完成此功能。参数相关数目传入脚本，此数目可以任意多，但只有前9个可以被访问，使用shift命令可以改变这个限制（以后将讲到shift命令）。参数从第一个开始，在第9个结束；每个访问参数前要加$符号。第一个参数为0，表示预留保存实际脚本名字。无论脚本是否有参数，此值均可用。</p>
<p>如果向脚本传送 “Did You See Th e Full Moon” 信息，下面的表格讲解了如何访问每一个参数。</p>
<table>
<thead>
<tr>
<th>$0</th>
<th>$1</th>
<th>$2</th>
<th>$3</th>
<th>$4</th>
<th>$5</th>
<th>$6</th>
<th>$7</th>
<th>$8</th>
<th>$9</th>
</tr>
</thead>
<tbody><tr>
<td>脚本名称</td>
<td>Did</td>
<td>You</td>
<td>See</td>
<td>The</td>
<td>Full</td>
<td>Moon</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="*预定义变量"></a>*预定义变量</h2><ul>
<li><code>$#</code> 传递到脚本的参数个数</li>
<li><code>$*</code> 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过 9 个</li>
<li><code>$$</code> 脚本运行的当前进程 ID 号</li>
<li><code>$!</code> 后台运行的最后一个进程的进程 ID 号</li>
<li><code>$@</code> <del>与 <code>$#</code> 相同，但是使用时加引号，并在引号中返回每个参数</del></li>
<li><code>$-</code> 显示 shell 使用的当前选项，与 set 命令功能相同</li>
<li><code>$?</code> 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</li>
</ul>
<h1 id="shell-的简单语法"><a href="#shell-的简单语法" class="headerlink" title="shell 的简单语法"></a>shell 的简单语法</h1><p>这个暂时还用不到，所以简单罗列以下资源：</p>
<ul>
<li><a href="http://c.biancheng.net/cpp/view/6999.html">Shell教程</a></li>
<li><a href="http://blog.csdn.net/zhuying_linux/article/details/6633022">shell变量</a></li>
<li><a href="http://blog.csdn.net/zhuying_linux/article/details/6633022">shell变量详解</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell 及 环境变量</title>
    <url>/2017/04/24/shell/</url>
    <content><![CDATA[<p>2016/3/16 12:17:18</p>
<p>汇总 3 篇。此处 shell 指工具，不涉及 shell 编程、脚本等知识。</p>
<h1 id="shell-和简单操作"><a href="#shell-和简单操作" class="headerlink" title="shell 和简单操作"></a>shell 和简单操作</h1><h2 id="shell-简介"><a href="#shell-简介" class="headerlink" title="shell 简介"></a>shell 简介</h2><p><a href="http://book.51cto.com/art/201107/277600.htm">Shell 是什么呢？</a> 确切地说，Shell 就是一个命令行解释器，它的作用就是遵循一定的语法将输入的命令加以解释并传给操作系统内核，它为用户提供了一个向 Linux 发送请求以便运行程序的接口，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</p>
<p><a href="http://book.51cto.com/art/201107/277601.htm">Linux Shell的种类</a> 很多，目前流行的 Shell 包括 ash、bash、ksh、csh、zsh 等，用户可以通过查看 /etc/shells 文件中的内容来查看自己主机中当前有哪些种类的 Shell。</p>
<a id="more"></a>

<h2 id="定义-shell-变量"><a href="#定义-shell-变量" class="headerlink" title="定义 shell 变量"></a>定义 shell 变量</h2><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/1.png" alt="定义变量"></p>
<ul>
<li>“取值包含空格，必须用双引号括起来”√，</li>
<li>“shell变量可以用大小写字母”，但是环境变量一般大写，个人声明变量一般小写，以作区分。</li>
</ul>
<h2 id="echo-显示变量"><a href="#echo-显示变量" class="headerlink" title="echo 显示变量"></a>echo 显示变量</h2><p>使用 <code>echo</code> 命令可以显示单个变量取值，并在变量名前加 <code>$</code>，例如：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/2.png" alt="13"></p>
<p>备注：红色矩形框标注部分，为正确方式。</p>
<p>其中 ，<code>echo “$LOGNAME”</code> 并不是合理书写方式，只是效果相同而已。取 <code>$LOGNAME</code> 值 rmq ，然后 <code>echo “rmq”</code>，所以也是输出 rmq。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/3.png" alt="131"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下内容在 shell 脚本中使用得更多一些。对于不接触 shell 编程，只关心怎么设置环境变量的人来说并不需要了解。放在这里也只是当初花费了时间和精力，不忍当 <a href="/2017/04/25/shell-sub1/">垃圾</a> 一样丢掉。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="角度A-由简入繁"><a href="#角度A-由简入繁" class="headerlink" title="角度A:由简入繁"></a>角度A:由简入繁</h2><ol>
<li><p>我们启动一个 shell 实例（通常是 bash），在其中以 <code>var=value</code> 的形式定义变量，那么这个变量 <code>var</code> 的作用域只限于当前 shell，既不能在另一实例（同类型 shell、不同类型 shell）中使用，<strong>也不能传递给当前实例的子进程（由当前 shell 实例启动的进程）</strong>；生存周期和当前实例的生存周期相同（如果不使用 <code>unset</code> 命令清除此变量的话），即随着实例的关闭而消失。</p>
</li>
<li><p><code>export var</code> 之后呢？Exporting a variable causes the variable to be inherited，This is the most common way of setting variables for use of subsequently started processes in a shell。但是其他特性不变。</p>
<hr>
<p> 以上都是临时的；<br> 每种 shell 都有自己特有的变量，比如 bash shell 中的 BASH，这些变量处于“shell类型”这个层次。<br> 以下都是永久的。</p>
<hr>
</li>
</ol>
<ol start="3">
<li><p>那么如何让一个变量在两个 shell中（同类型）同时起作用呢？或者在关闭并重新打开一个shell时，如何使之前定义的变量依旧有效呢？</p>
<p> ——持久化的话可以落盘成文件。针对 bash shell，我们可以将变量定义在 <code>~/.bashrc</code> 文件中，每一个 non-login interactive shell 在启动时都会首先读入这个配置文件，而 login shell 在登录时会读入 <code>~/.profile</code>（一般在此文件中包含 <code>.bashrc</code> 文件）。因为只有在 shell 启动 <code>/login</code> 时才会读入，所以在 shell 中更改配置文件后并不会立即生效，我们可以 <code>exit</code> 重启（针对 non-login shell）或者 logout 重新 login（针对 login shell），或者使用 <code>source filename</code> 命令重新执行刚修改的初始化文件，使之立即生效。</p>
<p> 理解到这，<strong>已经足够我们日常使用 linux了</strong>。因为一方面我们只使用系统默认的 shell（linux 下基本都是 bash），另一方面我们也不是系统管理员，没有 root 权限做系统层面的维护。</p>
</li>
<li><p>那么如何让变量在不同类型 shell 中都有效？如何让变量在不同用户中都有效？不能同步修改所有类型 shell 的配置文件，同步修改所有用户的配置文件吧</p>
<p> ——针对不同类型 shell，可以修改 <code>~/.profile</code> 文件或者 <code>/etc/profile</code> 文件；针对所有用户，可以修改 <code>/etc/profile</code> 文件。ps：针对多用户的 bash shell，可以修改 <code>/etc/bashrc</code> 文件。</p>
</li>
</ol>
<h2 id="角度B-整体回顾"><a href="#角度B-整体回顾" class="headerlink" title="角度B:整体回顾"></a>角度B:整体回顾</h2><p>经常见到“环境变量”一词，那么这种变量究竟有什么特殊之处？它的定义又是怎样的呢？</p>
<ol>
<li>环境变量是操作系统环境设置的变量，适用于整个系统的用户进程； </li>
<li>环境变量可以在命令中设置，但是用户注销的时候将会丢失这些设置值； </li>
<li>若要重复适用，则最好在 <code>.profile</code> 中定义；环境变量的使用与本地变量的使用方法相同， </li>
<li>但是在使用之前，必须用 <code>export</code> 命令导出。</li>
</ol>
<hr>
<p>核心在于弄清楚<strong>局部变量和全局变量的作用范围、生存周期</strong>，以及局部变量可以导出为全局变量，进一步可持久化存储到配置文件中。</p>
<p>按变量的生存周期来划分，Linux 变量可分为两类：</p>
<ul>
<li>永久的：需要修改配置文件，变量永久生效。</li>
<li>临时的：使用 <code>export</code> 命令声明即可，变量在关闭 shell 时失效。</li>
</ul>
<p>故此，可分出：</p>
<ol>
<li>永久全局变量：永久代表持久化为文件，全局代表在各种 shell、跨应用使用，（文件名中无“bash”）</li>
<li>永久局部变量：一般指各种 shell（例如 bash）在自身配置文件中储存了的变量，只能在 bash 中使用，不能再 csh 等其他 shell 中使用，（文件名中包含“bash”）；</li>
<li>临时局部变量：在 shell 中通过 <code>key=value</code> 定义的变量；</li>
<li>临时全局变量：将临时局部变量通过 <code>export</code> 命令导出，即可全局使用，但因为未存储到文件中，所以在用户注销，下次登录之后就会失效；</li>
</ol>
<p>所以，环境变量其实没有什么特殊之处。不过我们说环境变量一般还是指全局的：</p>
<p><strong>全局变量，即环境变量（临时的&amp;永久的）</strong>。局部变量又称 shell 私有变量。所谓永久其实就是开机/登录/打开shell时把文件中诸多 <code>export key=value</code> 命令先执行。</p>
<hr>
<p>知道以上区别，就知其所以然，不必只知其然而较真死记硬背了。也不必较真在某一句话里环境变量用的不恰当啊什么的了，不必较真变量分类。难得糊涂！</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>先声明一点，在下文中不再叙述：系统目录（/etc）中的配置文件信息对所有用户有效；用户主目录下的配置文件信息只对当前用户有效。</p>
<h2 id="Debian环境变量文件描述"><a href="#Debian环境变量文件描述" class="headerlink" title="Debian环境变量文件描述"></a>Debian环境变量文件描述</h2><p>以Debian8.1 Jessie为例，截图如下：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/4.png" alt="debian 8.1"></p>
<p>来源：/etc/profile</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/5.png" alt="debian 8.1"></p>
<p>来源：~/.profile</p>
<p>可以从中看到“登录 shell”的概念，与之对应的就是“非登录 shell”。</p>
<p>很明确的指出了这两个配置文件，是用于“登录 shell”的。在“非登录 shell”中是不会读取/执行这两个文件的，也就是说在这两个文件中配置的环境变量等信息在“非登录 shell”中是不奏效的。</p>
<p>另外，这两文件都是针对系统中所有 shell 的，包括但不限于常用的 bash、sh、ksh 等。</p>
<p>但是<strong>针对 bash</strong>，有一点特殊的地方：如果在用户主目录下存在 <code>.bash_profile</code> 或者 <code>.bash_login</code> 文件，则 <code>.profile</code> 是不会被读取的。强调优先级，且只读取其中一个。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/6.png" alt="debian 8.1"></p>
<p>来源：/etc/bash.bashrc</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/7.png" alt="debian 8.1"></p>
<p>来源：~/.bashrc</p>
<p>可以从中看到“交互式 shell”的概念，与之对应的就是“非交互式 shell”。下图中也出现了“非登录 shell”字样。</p>
<p>首先明确，这两个文件值针对 bash 的，对其他 shell 无效。且这两个文件被用于“非登录交互式 shell”。</p>
<p>那么问题来了：（只针对 bash）</p>
<table>
<thead>
<tr>
<th></th>
<th>login shell</th>
<th>non-login shell</th>
</tr>
</thead>
<tbody><tr>
<td>interactive shell</td>
<td>.profile √ <code>&lt;&lt;</code> .bashrc ×</td>
<td>.profile × <code> </code> .bashrc √</td>
</tr>
<tr>
<td>non-interactive shell</td>
<td>.profile √ <code>&lt;&lt;</code> .bashrc ×</td>
<td>.profile × <code> </code> .bashrc ×</td>
</tr>
</tbody></table>
<p>可以看到：</p>
<ol>
<li>对于“非登录且非交互式的 shell”，是没有配置方法的。不过貌似我们也不需要。</li>
<li>/etc/bash.bashrc 和 ~/.bashrc 文件对于“登录 shell” 是无效的。</li>
<li>/etc/profile 和 ~/.profile 文件对于“非登录 shell” 是无效的。</li>
</ol>
<h2 id="non-login-interactive"><a href="#non-login-interactive" class="headerlink" title="(non-)login/interactive"></a>(non-)login/interactive</h2><p>第一章只是复述了系统文件自带的描述，并无意外的知识。但是什么样是“login shell”，什么又是“non-login shell”呢？什么是“interactive shell”，什么又是“non-interactive shell”呢？</p>
<ol>
<li><p>可以参考“<a href="http://smilejay.com/2012/10/interactive-shell-login-shell/">交互式SHELL和非交互式SHELL、登录SHELL和非登录SHELL的区别</a>”，这篇帖子讲的还是非常不错的。</p>
<p> 特别强调一点：“在 Gnome 或 KDE 中打开一个“终端”（terminal）窗口程序也是一个非登录 shell。”</p>
</li>
<li><p>我越来越感觉到“<a href="http://stackoverflow.com/questions/18186929/what-are-the-differences-between-a-login-shell-and-interactive-shell">stackoverflow-differences between login shell and interactive shell</a> ”网站对于 C++ 开发者的重要了。</p>
<p> 重点关注最后一段话，我想答主提到“shell scripts”时，等价表示“非登录且非交互式”。</p>
</li>
<li><p>也可以看看“<a href="http://www.cnblogs.com/qcly/p/3273373.html">login shell与non-login shell的区别</a>”，这篇帖子有几处表述不恰当的地方，记录如下：</p>
<ul>
<li><p>在提到login shell启动读取配置文件顺序时，没有区分bash shell 和shell 。两者的区别是需要强调的！</p>
</li>
<li><p>“如果使用命令”sh”调用bash……”，我想作者通过这一句是想表达调用bash脚本，表明“非交互式shell”</p>
<p>（依旧）转载这篇帖子最重要的原因是他告诉了我们<strong>以下知识</strong>：</p>
</li>
<li><p>“非交互式的non-login shell不读取上述所有配置文件，而是查找环境变量BASH_ENV，读取并执行 <a href="http://huangyandong.blog.51cto.com/1396940/662272">BASH_ENV</a> 指向的文件中的命令。”</p>
</li>
<li><p>“通常我们要定制一些配置时，将配置写在<del>/.bashrc中，然后在</del>/.bash_profile中读取~/.bashrc，这样可以保证login shell和交互式non-login shell得到相同的配置。”</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/8.png" alt="debian 8.1"></p>
<p>来源：~/.profile</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/9.png" alt="debian 8.1"></p>
<p>来源：/etc/profile</p>
</li>
</ul>
</li>
<li><p>懂得了以上，<a href="http://www.cnblogs.com/starspace/archive/2009/02/23/1396254.html">其中是非论断</a> 就很 easy 了。</p>
<p> <img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/a.png" alt="debian 8.1"></p>
</li>
</ol>
<h2 id="Ubuntu-环境变量文件介绍"><a href="#Ubuntu-环境变量文件介绍" class="headerlink" title="Ubuntu 环境变量文件介绍"></a><a href="http://blog.csdn.net/cscmaker/article/details/7261921">Ubuntu 环境变量文件介绍</a></h2><h3 id="系统级："><a href="#系统级：" class="headerlink" title="系统级："></a>系统级：</h3><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/b.png" alt="debian 8.1"></p>
<ul>
<li>/etc/profile：该文件是用户登录时，操作系统定制用户环境时使用的第一个文件，应用于登录到系统的每一个用户。该文件一般是调用/etc/bash.bashrc文件。</li>
<li>/etc/bash.bashrc：系统级的bashrc文件。</li>
<li><strong>/etc/environment</strong>：在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。（这个文件大师我还没有研究过）</li>
</ul>
<h3 id="用户级（这些文件处于-home-目录下）："><a href="#用户级（这些文件处于-home-目录下）：" class="headerlink" title="用户级（这些文件处于 home 目录下）："></a>用户级（这些文件处于 home 目录下）：</h3><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/shell/c.png" alt="debian 8.1"></p>
<ul>
<li>~/.profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。这里是推荐放置个人设置的地方</li>
<li>~/.bashrc：该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。不推荐放到这儿，因为每开一个shell，这个文件会读取一次，效率肯定有影响。</li>
<li>~/.bash_profile or ~./bash_login：这里没有引用作者的，下面会提到</li>
<li>~/.pam_environment：用户级的环境变量设置文件，没有做测试，不知道管不管用。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上面的文件介绍，就能明白我们需要设置环境变量的时候，需要修改什么文件，要想对所有的用户生效，那就需要设置系统级的环境变量。反之，需要修改用户级的文件（最好是修改.profile文件，理由上面已经讲了）。</p>
<p>另外，我使用的是 Ubuntu10.04，之前在查找资料设置用户级环境变量的时候，有资料说要修改 ~.bash_profile 文件，但是在 ubuntu10.04 系统中是没有该文件。经查找，在 <a href="https://help.ubuntu.com/community/EnvironmentVariables">ubuntu 官网</a> 上找到了这个文件的说明：</p>
<blockquote>
<p><del>/.bash_profile or ~./bash_login - If one of these file exist, bash executes it rather then “</del>/.profile” when it is started as a login shell. (Bash will prefer “<del>/.bash_profile” to “</del>/.bash_login”). However, these files won’t influence a graphical session by default.</p>
</blockquote>
<p>意思应该是说当这个文件存在时，在登录 shell 时会读取 ./bash_profile 文件，而不是 .profile 文件。我认为该文件实现的目的跟 .profile 文件是一样的，当查找的资料中需要你修改 .bash_profile 文件，但却你没有该文件的时候，也可以修改 .profile 来完成实现。</p>
<p>以上仅为个人观点，如有错误请批评指正！感激涕零……</p>
<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>以上你都看懂了，你还不会设置环境变量吗？</p>
<p>有一篇讲解还比较到位的帖子：<a href="http://www.51testing.com/html/76/227476-99672.html">Linux设置环境变量小结</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2016/10/17/singleton1/</url>
    <content><![CDATA[<p>我们从 GoF 说起，书中写到单例模式（Singleton）的意图是：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p>在什么时候会用到单例模式呢？开发过程中常见的应用举例：</p>
<ul>
<li>日志类，一个应用往往只对应一个日志实例：丑陋的写法是在每个场景都实例化一个日志对象使用。</li>
<li>配置类，应用的配置集中管理，并提供全局访问：丑陋的写法是在每次使用配置时都实例化一个配置对象，然后访问配置文件读取其中的配置项。</li>
<li>管理器，比如我们写了一个 windows 服务，然后我们要封装一个启停此服务的管理器。</li>
<li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。比如文件连接，数据库连接等</li>
</ul>
<a id="more"></a>

<p>下面来看具体的实现。在 C++ 中，虽然将一个对象定义成全局变量可以使其被全局访问，但它不能防止你实例化多个对象，即无法“保证一个类仅有一个实例”。如果你坚持如此使用也能实现功能，但并不优雅。</p>
<blockquote>
<p>更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的办法。</p>
</blockquote>
<p>以上描述中涉及 3 个功能点，我们来看看在 C++ 中具体是如何实现的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton* _instance;  <span class="comment">//类自身保存它的唯一实例</span></span><br><span class="line">	Singleton();  <span class="comment">// 截取创建新对象的请求</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">Instance</span><span class="params">()</span></span>;  <span class="comment">// 提供一个访问该实例的办法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述定义中未体现类的唯一实例怎么创建的。而恰恰是如何创建实例区分出了以下几种实现：</p>
<ol>
<li>Lazy Singleton，命名来源于其中使用了惰性（Lazy）初始化</li>
<li>双检测锁模式，在上述基础上为线程安全作出修改</li>
<li>Eager Singleton，不使用惰性初始化</li>
<li>Meyers Singleton，在新标准下支持多线程，最优雅的一种实现。</li>
</ol>
<p>需要强调的是，虽然上述几种实现都是由 Singleton 类创建实例，但这并不是必须的。GoF 书中描述 Singleton 类的职责时也只是“<strong>可能</strong>负责创建它自己的唯一实例”，事实上，在书中讲述单件注册表时就明确提到了：（详细内容请翻看原著）</p>
<blockquote>
<p>Singleton 类不再负责创建单件。</p>
</blockquote>
<p>为了保证唯一实例，还需要删除拷贝构造函数（和拷贝赋值操作符）。另外，用户获得指针之后可能会以为他负责释放，进而对 <code>Singleton::Instance()</code> 的结果执行 <code>delete</code> 操作，如果我们并不希望如此，可以将析构函数声明为私有的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Singleton* pSingleton = Singleton::Instance();</span><br><span class="line"><span class="comment">// 以下两个操作是违背单例模式特性的，必须禁止掉。</span></span><br><span class="line">Singleton singleton = *pSingleton;</span><br><span class="line"><span class="function">Singleton <span class="title">singleton2</span><span class="params">(*pSingleton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是这个样子可以</span></span><br><span class="line">Singleton&amp; refSingleton = *pSingleton;</span><br><span class="line"><span class="function">Singleton&amp; <span class="title">refSingleton2</span><span class="params">(*pSingleton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;singleton&#x27;addr is: &quot;</span> &lt;&lt; &amp;singleton &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pSingleton is: &quot;</span> &lt;&lt; pSingleton &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;singleton2&#x27;addr is: &quot;</span> &lt;&lt; &amp;singleton2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>作业一</strong>：移动构造函数、移动赋值操作符需不需要禁止？不禁止的话有什么影响？这些影响中有优点吗？</p>
<h1 id="单线程-Lazy-Singleton"><a href="#单线程-Lazy-Singleton" class="headerlink" title="单线程 Lazy Singleton"></a>单线程 Lazy Singleton</h1><p>在 GoF 书中给出的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Singleton* Singleton::_instance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Singleton::Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_instance == <span class="number">0</span>) &#123;</span><br><span class="line">		_instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现被称为“Lazy Singleton”，它使用了惰性初始化：它的返回值直到被第一次访问时才创建和保存。</p>
<p>惰性初始化：实例直到用到的时候（用户通过 <code>Singleton::Instance()</code> 要获取实例时）才创建，在此之前实例对象是不存在的，避免了潜在浪费资源的可能。对比非惰性初始化的 Eager Singleton 理解，提前把对象初始化，但应用的执行逻辑可能就没有用到此实例。</p>
<p>但正如 GoF 在第一章引言中指出的一样，上述实现也存在局限。</p>
<blockquote>
<p>书中没有讨论与并发或分布式或实时程序设计有关的模式，也没有收录面向特定应用领域的模式。</p>
</blockquote>
<p>最突出的就是非线程安全。另外在部分使用场景中，我们还需要考虑 Singleton 的释放问题。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>Lazy Singleton不是线程安全的，比如现在有线程 A 和线程 B，都通过 <code>_instance == 0</code> 的判断，那么线程 A 和 B 都会创建新实例。单例模式保证生成唯一实例的规则被打破了。</p>
<h2 id="双检测锁模式（Double-Checked-Locking-Pattern）"><a href="#双检测锁模式（Double-Checked-Locking-Pattern）" class="headerlink" title="双检测锁模式（Double-Checked Locking Pattern）"></a>双检测锁模式（Double-Checked Locking Pattern）</h2><p>Lazy Singleton的一种线程安全改造是在 <code>Instance()</code> 中每次判断是否为 <code>NULL</code>(<code>0</code>) 前加锁，但是加锁是很慢的。而实际上只有第一次实例创建时的 <code>_instance==NULL</code> 判断才需要加锁，创建之后 <code>_instance==NULL</code> 判断不再需要加锁。，所以多在加锁之前多加一层判断，需要判断两次所有叫 Double-Checked。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Singleton *<span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_instance == <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		Lock(); <span class="comment">// C++没有直接的Lock操作，请使用其它库的Lock，比如Boost，此处仅为了说明</span></span><br><span class="line">		<span class="keyword">if</span> (_instance == <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			_instance = <span class="keyword">new</span> Singleton ();</span><br><span class="line">		&#125;</span><br><span class="line">		UnLock(); <span class="comment">// C++没有直接的Lock操作，请使用其它库的Lock，比如Boost，此处仅为了说明</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上问题解决了，但是在实践中有很多坑，如指令重排、多核处理器等问题让 DCLP 实现起来比较复杂，比如需要使用内存屏障，详细的分析可以阅读：</p>
<ul>
<li><a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++ and the Perils of Double-Checked Locking</a>，如果阅读英文吃力，在 </li>
<li><a href="http://blog.csdn.net/10km/article/details/49777749">c++11单实例(singleton)初始化的几种方法(memory fence,atomic,call_once)</a> 博客中也有详细分析。</li>
</ul>
<p><strong>扩展</strong>：在C++11中有全新的内存模型和原子库，可以很方便的用来实现 DCLP。这里不展开。有兴趣可以阅读：</p>
<ul>
<li>这篇文章<a href="http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/">《Double-Checked Locking is Fixed In C++11》</a>。另外，</li>
<li>在 <a href="https://www.manning.com/books/c-plus-plus-concurrency-in-action">C++ Concurrency in Action</a> 一书中也有系统的讲解。</li>
</ul>
<p>C++11 的并发特性提供了很多语法来实现线程安全的单例模式，其中值得推荐的有两种（在 <a href="http://www.cnblogs.com/zxh1210603696/p/4157294.html">最简洁的单例模式</a> 有整理）：</p>
<ul>
<li>使用 <code>call_once</code></li>
<li>使用 static local variable，即下文提到 Meyers Singleton</li>
</ul>
<h2 id="Eager-Singleton"><a href="#Eager-Singleton" class="headerlink" title="Eager Singleton"></a>Eager Singleton</h2><p>摘自 <a href="http://www.zkt.name/dan-li-mo-shi-singleton-ji-c-shi-xian/">单例模式(Singleton)及其C++实现</a></p>
<p>这种实现在程序开始的时候（静态属性 <code>instance</code> 初始化)就完成了实例的创建。这正好和上述的 Lazy Singleton 相反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton();</span><br><span class="line">        ~Singleton();</span><br><span class="line">        Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现文件中</span></span><br><span class="line">Singleton Singleton::instance;  </span><br></pre></td></tr></table></figure>
<p>由于在 main 函数之前初始化，所以没有线程安全的问题，但是潜在问题在于 <strong>no-local</strong> static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 <code>Instance()</code> 方法会返回一个未定义的实例，比如一个全局变量的构造函数中调用了此方法。关于此问题在 <a href="http://blog.yangyubo.com/2009/06/04/best-cpp-singleton-pattern/">C++ Singleton (单例) 模式最优实现</a> 中有较为详细的分析。</p>
<p><strong>作业二</strong>：对比下一节 Meyers Singleton，函数外的 static 对象和函数内的 static 对象有哪些区别？</p>
<h2 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h2><p>Scott Meyers 在《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用 local static 对象（函数内的 static 对象）。当第一次访问 <code>Instance()</code> 方法时才创建实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">        	<span class="keyword">static</span> Singleton instance;</span><br><span class="line">        	<span class="keyword">return</span> instance;</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Singleton();</span><br><span class="line">        ~Singleton();</span><br><span class="line">        Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++0X 以后，要求编译器保证内部静态变量 <strong>初始化</strong> 的线程安全，所以<strong>C++0x之后该实现是线程安全的</strong>，<a href="https://stackoverflow.com/questions/1661529/is-meyers-implementation-of-the-singleton-pattern-thread-safe">is-meyers-implementation-of-the-singleton-pattern-thread-safe</a>。</p>
<p><strong>作业三</strong>：返回单件指针和返回引用的区别？</p>
<h1 id="实例销毁"><a href="#实例销毁" class="headerlink" title="实例销毁"></a>实例销毁</h1><p>在上述几种实现中，大多使用了 <code>new</code> 操作符实例化对象。我们一般的编程观念是，<code>new</code> 操作符是需要和 <code>delete</code> 操作进行匹配的——这种观念是正确的。接下来我们说一个例外。</p>
<p>针对单例模式中的唯一实例，在实际项目中，特别是客户端开发，其实是不在乎这个实例的销毁的。因为，全局就这么一个变量，全局都要用，它的生命周期伴随着软件的生命周期，软件结束了，它也就自然而然的结束了，因为一个程序关闭之后，它会释放它占用的内存资源的，所以，也就没有所谓的内存泄漏了。但针对这种特殊性也有例外的地方：</p>
<ol>
<li>在类中，有一些文件锁，文件句柄，数据库连接等等。相对应的，在类的析构行为中有必须的操作，比如关闭文件，关闭数据库连接等。如果 <code>new</code> 之后不进行显式的 <code>delete</code>（执行析构），就会造成潜在威胁，比如数据库连接数持续增加。</li>
</ol>
<p>最直接的方法就是在程序结束时调用 <code>Instance()</code>，并对返回的指针调用 <code>delete</code> 操作。或者将 <code>delete</code> 的操作封装在 Singleton 类中，然后在程序结束时调用这个类方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestoryInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_instance != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _instance;</span><br><span class="line">		_instance = <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可以实现功能，但也很丑陋，而且容易出错。因为<strong>这样的附加代码很容易被忘记</strong>，而且也很难保证在 <code>delete</code> 之后，没有代码再调用 <code>Instance()</code> 函数。</p>
<h2 id="垃圾工人-RAII"><a href="#垃圾工人-RAII" class="headerlink" title="垃圾工人 RAII"></a>垃圾工人 RAII</h2><p>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。</p>
<p>程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样（静态变量和全局变量在内存中，都是存储在静态存储区的，所以在析构时，是同等对待的）。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。</p>
<p>如下面的代码中的 CGarbo 类（Garbo 意为垃圾工人）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    Singleton()  </span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> Singleton *_instance;  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span>   //它的唯一工作就是在析构函数中删除<span class="title">CSingleton</span>的实例  </span></span><br><span class="line"><span class="class">    &#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        ~Garbo()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(Singleton::_instance)  </span><br><span class="line">                <span class="keyword">delete</span> Singleton::_instance;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">static</span> Garbo _garbo;  <span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">Instance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(_instance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用  </span></span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        <span class="keyword">return</span> _instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//实现文件中</span></span><br><span class="line">Singleton::Garbo Singleton::_garbo;    <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<p>此时我们不再需要用户销毁实例（避免用户 <code>delete</code> 实例带来的不确定性），应该将析构函数声明为私有的。</p>
<h2 id="Meyers-Singleton-1"><a href="#Meyers-Singleton-1" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h2><p>如果没有 <code>new</code>，当然也就不需要 <code>delete</code>。</p>
<p>对于 2.3 节 Meyers Singleton 实现，其 <code>Singleton::Instance()</code> 函数中的局部静态变量会自动析构，所以 Singleton 类的析构函数会顺利执行。</p>
<h1 id="boost-中的单例模式"><a href="#boost-中的单例模式" class="headerlink" title="boost 中的单例模式"></a>boost 中的单例模式</h1><p><a href="https://www.jianshu.com/p/333d4b37db56">boost 中的单例模式</a></p>
<p><a href="https://www.chenxuefei.com/2016/boost-singleton-do_nothing/">关于Boost Singleton <code>do_nothing()</code> 的那点事</a></p>
<h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p>第二章多线程安全部分主要参考自 <a href="http://www.zkt.name/dan-li-mo-shi-singleton-ji-c-shi-xian/">单例模式(Singleton)及其C++实现</a>；第三章实例销毁参考自 <a href="http://www.jellythink.com/archives/82">C++设计模式——单例模式</a>。当然，最主要的参考还是 GoF 的经典著作《设计模式：可复用面向对象软件的基础》。</p>
<p>这里再重复一次，在书中提到了“单件注册表方法”，此方法与上述所有实现最大的一个区别在于：Singleton 类不再负责创建单件实例，而上述实现无论返回单件指针还是引用都是在 Singleton 类中创建。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-idioms</category>
      </categories>
      <tags>
        <tag>GoF</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式-作业</title>
    <url>/2016/10/17/singleton2/</url>
    <content><![CDATA[<p>单例模式</p>
<h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><p>实现一（指针）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton m_Instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_Instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Singleton();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回最好是返回引用，要不然用户会不小心删除掉指针的（如果非要返回指针，最好将析构函数声明为私有的）。</p>
<p>例外：在 DLL 中使用单例模式时，因为主函数结束后执行全局变量（或 <code>static</code> 变量）的析构会出现问题（比如线程无法退出）。此时提供 <code>shutdown()</code> 供用户显式调用，并不比直接暴露指针让用户 <code>delete sington_ptr</code> 高明。</p>
</blockquote>
<a id="more"></a>

<p>实现二（引用）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Singleton();</span><br><span class="line">  ~Singleton();</span><br><span class="line">  Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="拷贝控制函数"><a href="#拷贝控制函数" class="headerlink" title="拷贝控制函数"></a>拷贝控制函数</h1><p>拷贝构造函数（和拷贝赋值操作符）必须禁止（设置为 <code>private</code> 属性或者 <code>= delete</code>），否则</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MeyersSingleton meyers = MeyersSingleton::Instance();</span><br><span class="line">MeyersSingleton meyers2 = meyers;</span><br><span class="line"><span class="function">MeyersSingleton <span class="title">meyers3</span><span class="params">(meyers)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;meyers is: &quot;</span> &lt;&lt; &amp;meyers &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;meyers2 is: &quot;</span> &lt;&lt; &amp;meyers2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;meyers3 is: &quot;</span> &lt;&lt; &amp;meyers3 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>禁止掉拷贝构造函数（和拷贝赋值操作符）后，返回值可以赋值给引用，方便使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MeyersSingleton&amp; refMeyers = MeyersSingleton::Instance();</span><br><span class="line"><span class="function">MeyersSingleton&amp; <span class="title">refMeyers2</span><span class="params">(refMeyers)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;refMeyers is: &quot;</span> &lt;&lt; &amp;refMeyers2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;refMeyers2 is: &quot;</span> &lt;&lt; &amp;refMeyers2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>其实还可以有更直接的用法，下文详细描述。    </p>
<p>移动构造函数（和移动赋值操作符）是否应该禁止？禁不禁各有优缺点，都行。禁止的话快刀斩乱麻，我们不用担心有什么隐患，使用第 2 步的代码，也挺方便；不禁止的话就更爽啦，我们可以直接赋值（貌似是我一厢情愿，代码实际测试是不行的）：</p>
<p><strong>移动语义</strong>保证等号右侧的对象会销毁，所以如果使用移动赋值（或移动构造）和单例模式的特性并不冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即便支持移动语义，下列语句编译也无法通过。</span></span><br><span class="line">MeyersSingleton meyers = MeyersSingleton::Instance();</span><br><span class="line"><span class="function">MeyersSingleton <span class="title">meyers2</span><span class="params">(MeyersSingleton::Instance())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;refMeyers is: &quot;</span> &lt;&lt; &amp;meyers2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;refMeyers2 is: &quot;</span> &lt;&lt; &amp;meyers2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>看来我对移动语义的理解还是不够充分。移动语义其实是提倡性质的，很多时候使用默认的移动构造会退化成拷贝构造。抽空好好研究一下。</p>
<p>在调试过程中碰到以下提示信息：</p>
<blockquote>
<p>note: ‘constexpr MeyersSingleton::MeyersSingleton(const MeyersSingleton&amp;)’ is implicitly declared as deleted because ‘MeyersSingleton’ declares a move constructor or move assignment operator</p>
</blockquote>
<p>可此时我的代码……对此也很困惑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeyersSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    MeyersSingleton();</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MeyersSingleton&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//MeyersSingleton(const MeyersSingleton&amp;) = delete;</span></span><br><span class="line">    <span class="comment">//MeyersSingleton&amp; operator=(const MeyersSingleton&amp;) = delete;</span></span><br><span class="line">    </span><br><span class="line">    MeyersSingleton(MeyersSingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MeyersSingleton&amp; <span class="keyword">operator</span>=(MeyersSingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>似乎在 C++11 新标准使用静态局部变量的实现中以使用引用为主。但返回引用的话，在子类继承方面肯定是不如指针的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此问题和第一章相关。</p>
<ol start="0">
<li>默认构造函数 <code>private</code></li>
<li>拷贝构造函数 <code>= delete</code>； 拷贝赋值操作符 <code>= delete</code></li>
<li>移动构造函数 <code>= delete</code>； 移动赋值操作符 <code>= delete</code></li>
</ol>
<p>不禁止移动构造函数（和移动赋值操作符）对于返回引用、返回指针有什么影响都是个烧脑的问题，懒得分析就直接禁止掉就是了。</p>
<h1 id="no-local-static-对象的初始化顺序问题"><a href="#no-local-static-对象的初始化顺序问题" class="headerlink" title="no-local static 对象的初始化顺序问题"></a>no-local static 对象的初始化顺序问题</h1><p>参见 <a href="http://blog.yangyubo.com/2009/06/04/best-cpp-singleton-pattern/">C++ Singleton (单例) 模式最优实现</a></p>
<h1 id="不同类型的单例-vs-多个单例"><a href="#不同类型的单例-vs-多个单例" class="headerlink" title="不同类型的单例 vs. 多个单例"></a>不同类型的单例 vs. 多个单例</h1><p>实现方法：继承，和模板</p>
<p>构造函数私有就无法继承了。如果有继承的需求，还是改为 <code>protected</code> 修饰。</p>
<p>如果是相关的单例类，比如 GoF 原著中的正常迷宫工厂、魔法迷宫工厂、炸弹迷宫工厂，可以通过继承父类的方式创建单例。因为从业务逻辑上讲，这三种工厂是“互斥”的，并不会同时存在，而单例类（父类及其延伸出来的子类）保证唯一实例，无法在一个系统中创建一个正常工厂实例和一个魔法工厂实例。</p>
<p>如果是不相关的单例类，比如系统中存在数据库连接类、配置管理类，此时是要求有各自的唯一的实例的，通过继承实现显然是不合适的（甚至是不可能的）。而这种场景恰恰是经常碰到的，如果每次都要重新写一次单例类的逻辑是很麻烦的。</p>
<p>参考 <a href="3">可以继承的 Singleton</a>，如何使用模板实现一个通用的基类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> S&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> S instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; )&#123;&#125;;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = ( <span class="keyword">const</span> Singleton &amp; rhs )&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBOper</span> :</span> <span class="keyword">public</span> Sington&lt;DBOper&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Sington</span>&lt;</span>DBOper&gt;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-idioms</category>
      </categories>
      <tags>
        <tag>GoF</tag>
      </tags>
  </entry>
  <entry>
    <title>单例很糟糕？</title>
    <url>/2018/09/06/singleton3/</url>
    <content><![CDATA[<p>之前专门整理过 C++ 怎么写单例类，平日项目中涉及的场景大多简单，使用最基本的实现就完全能够应付过来。但是，还是有些复杂的场景需要考虑。</p>
<h1 id="相互引用的单例们"><a href="#相互引用的单例们" class="headerlink" title="相互引用的单例们"></a>相互引用的单例们</h1><p>也就是 singletonA、singletonB 两者的构造相互调用。</p>
<ul>
<li><p>使用常用的局部静态变量方式（<a href="https://github.com/tnie/MarkdownPhotos/blob/master/gof/lazy_result_loop.cpp">lazy_result_loop.cpp</a>），也是懒汉模式一种：相互依赖初始化，<strong>死循环</strong>，阻塞</p>
  <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Object_2B_1::Object_2B_1() this:[00BFC14C] data_2b_1_ [1].</span><br><span class="line">Object_2B_2::Object_2B_2() this:[00BFC154] data_2b_2_ [2].</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用全局静态变量方式（<a href="https://github.com/tnie/MarkdownPhotos/blob/master/gof/hungry_result_different.cpp">hungry_result_different.cpp</a>），饿汗模式：不会死循环，但奇葩在 Debug、Release 模式执行<strong>结果不一致</strong></p>
</li>
</ul>
<p>代码摘抄自 <a href="http://www.cnblogs.com/fullsail/archive/2013/01/03/2842618.html">BOOST 的 Singleton 模版详解</a>，以上就是“2B 实现有问题”。虽然作者自述“BOOST 的实现如何规避问题”，但在 msvc2015 中实测其代码<strong>并未解决问题</strong>，依旧是<strong>阻塞</strong>结果。</p>
<a id="more"></a>

<p>参考 <a href="https://blog.csdn.net/taurance/article/details/42389193">boost 中的单例模式</a>，boost 的实现解决的只是多线程问题（新标准才保证创建局部静态变量时的线程安全）：</p>
<blockquote>
<p>这个单例是利用 main 调用之前，程序只有一个线程，来保证单例在多线程下的唯一性。</p>
</blockquote>
<p>但为什么要多此一举引入局部类呢？直接用全局静态变量不行吗？</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>使用静态变量方式实现（无论是局部的还是全局的）都能够避免：</p>
<blockquote>
<p>多线程调用 Singleton 导致多次初始化的问题</p>
</blockquote>
<p>在 <a href="https://blog.csdn.net/taurance/article/details/42389193">boost 中的单例模式</a> 中给出的四种实现，因为要兼容旧标准，所以有三种都是饿汗模式。</p>
<blockquote>
<p>boost 没有一个通用的单例类的原因，已提供的单例类，都是在某个具体的模块中。</p>
</blockquote>
<h1 id="单例很糟糕？"><a href="#单例很糟糕？" class="headerlink" title="单例很糟糕？"></a>单例很糟糕？</h1><p><a href="https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons" title="https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons">https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons</a></p>
<p><a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i3-avoid-singletons">C++ 他爹都说要避免使用单例</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-idioms</category>
      </categories>
      <tags>
        <tag>GoF</tag>
      </tags>
  </entry>
  <entry>
    <title>内存和长度</title>
    <url>/2016/11/03/sizeof-strlen-length-size/</url>
    <content><![CDATA[<p>笔记针对以下问题：</p>
<ol>
<li>在c语言中，<code>sizeof</code>运算符和<code>strlen()</code>函数有什么区别的？</li>
<li>如果/字符串/字符指针/用来存储汉字，对于这两者的计算结果有影响吗？</li>
<li>在C++中，<code>sizeof</code>运算符和<code>strlen()</code>函数的定位？</li>
<li>在C++中，string的<code>lengt()</code>和<code>size()</code></li>
<li>在C++中，string用来存储汉字时，……</li>
</ol>
<a id="more"></a>

<h1 id="有关-sizeof和strlen的总结"><a href="#有关-sizeof和strlen的总结" class="headerlink" title="有关 sizeof和strlen的总结"></a><a href="http://blog.csdn.net/cxyol/article/details/573524">有关 sizeof和strlen的总结</a></h1><p><code>sizeof</code>是计算括号中变量的类型所占的储存空间(不考虑内容)；</p>
<p><code>strlen</code>是计算变量值为起点的内存地址到第一个<code>&#39;/0&#39;</code>的距离，以<strong>字节</strong>为单位。</p>
<ul>
<li><p>参数区别</p>
<p>  先明确，<code>strlen()</code>用来计算字符串的长度，所以其参数只能是字符数组或字符指针（其实字符数组退化，也就是字符指针），而且，<strong>字符串必须以<code>&#39;/0&#39;</code>结尾</strong>，对任何不以<code>&#39;/0&#39;</code>结尾的字符数组或字符指针使用<code>strlen()</code>函数都是未定义的；而<code>sizeof</code>用来计算内存占用，其参数可以是类型名或者数据变量。</p>
<p>  所以，对于两者的对比主要放在字符串（字符数组或字符指针）这一块。需要强调的是，<code>strlen(字符数组)</code>，函数传参时字符数组会退化为指针；<code>sizeof(字符数组)</code>，字符数组不会发生退化。</p>
</li>
<li><p>使用方法</p>
<p>  强调运算符和函数，那么两者的区别在哪？首先就在于使用方法上，<code>sizeof</code>后如果是类型必须加括弧，如果是变量名可以不加括弧。</p>
</li>
<li><p>sizeof</p>
<ul>
<li>当适用了于一个结构类型时或变量，<code>sizeof</code> 返回实际的大小；当适用一静态地空间数组，<code>sizeof</code> 归还全部数组的尺寸。<code>sizeof</code> 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 。</li>
<li>适用于函数时，<code>sizeof</code> 返回函数的返回类型所占的空间大小。函数的返回类型不能是<code>void</code>。</li>
</ul>
</li>
</ul>
<p>为了验证以上，看一段测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* ch = <span class="string">&quot;我喜欢你&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strlen is %d\n&quot;</span>, <span class="built_in">strlen</span>(ch));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof is %d\n&quot;</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">  <span class="keyword">char</span> str[] = <span class="string">&quot;我喜欢你&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strlen is %d\n&quot;</span>, <span class="built_in">strlen</span>(str));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof is %d\n&quot;</span>, <span class="keyword">sizeof</span> str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/sizeof-strlen.png" alt="测试代码的执行结果"></p>
<p>推荐：<a href="http://www.cnblogs.com/alex-tech/archive/2011/03/26/1996284.html">字符数组,字符指针,sizeof,strlen总结</a></p>
<h2 id="问题-3-的答案"><a href="#问题-3-的答案" class="headerlink" title="问题 3 的答案"></a>问题 3 的答案</h2><p>在stackoverflow的<a href="http://stackoverflow.com/questions/8590332/difference-between-sizeof-and-strlen-in-c">一篇问答</a>中提到：<code>sizeof</code>和<code>strlen()</code>区别很大，但是，在C++中 其实并不应该涉及这两者。C风格的字符串在C++中应该使用<code>std::string</code>类型替换；<code>sizeof</code>主要应用在内存分配、内存管理操作中，而这些在C++中有了新的函数，不再需要<code>sizeof</code>。原文如下：</p>
<blockquote>
<p>The two are almost different. In C++, you do not need either very much, <code>strlen()</code> is for C-style strings, which should be replaced by C++-style <code>std::strings</code>, whereas the primary application for <code>sizeof()</code> in C is as an argument to functions like <code>malloc()</code>, <code>memcpy()</code> or <code>memset()</code>, all of which you shouldn’t use in C++ (use <code>new</code>, <code>std::copy()</code>, and <code>std::fill()</code> or constructors).</p>
</blockquote>
<h1 id="std-string-类的长度"><a href="#std-string-类的长度" class="headerlink" title="std::string 类的长度"></a>std::string 类的长度</h1><p>先说结论：string类的size与length，二者在功能上没有区别。</p>
<blockquote>
<p>basic_string &lt;&gt; 有双重身份，一是代替传统的C字符串，所以应该针对C中的strlen，给出相应的函数length()。另一个身份是可以用作STL容器，所以要按照STL容器的惯例给出size()。basic_string就是一个能够根据需要自动调整内存分配的对象容器。可以说是一个动态数组。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++标准库中的string中两者的源代码如下：</span></span><br><span class="line"><span class="function">size_type __CLR_OR_THIS_CALL <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// return length of sequence</span></span><br><span class="line">    <span class="keyword">return</span> (_Mysize);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">size_type __CLR_OR_THIS_CALL <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// return length of sequence</span></span><br><span class="line">    <span class="keyword">return</span> (_Mysize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以两者没有区别。length是因为沿用C语言的习惯而保留下来的，string类最初只有length，引入STL之后，为了兼容又加入了size，它是作为STL容器的属性存在的，便于符合STL的接口规则，以便用于STL的算法。</p>
<p>string类的size()/length()方法<strong>返回的是字节数</strong>，不管是否有汉字。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>socket 编程</title>
    <url>/2017/07/04/socket/</url>
    <content><![CDATA[<p>C/C++ 的 socket 编程。开篇</p>
<ol>
<li>socket 编程貌似是从 *nix 到的 windows？</li>
<li>socket 编程源于 C，但 C++ 似乎并没有原生的支持，依旧是 C 语言下的 socket 编程？</li>
<li>C++ 的网络编程，包含哪些具体的内容？单单是 socket 吗？ socket 编程不应该是更接近 C 语言吗？</li>
<li></li>
</ol>
<p>socket 编程，入门学习非常推荐吴秦的 <a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket编程（不限Linux）</a>。当做学习 socket 编程的第一篇完全足够，甩开网上其他的帖子一万八千里，强烈推荐。本意是整理 socket 的学习笔记，但有上述帖子完全足够，在此只记录一些“边边角角”的零碎知识。</p>
<p>手册推荐：<a href="http://beej.us/guide/bgnet/output/html/multipage/index.html">Beej’s Guide to Network Programming</a></p>
<h1 id="htonl-函数、htons-函数"><a href="#htonl-函数、htons-函数" class="headerlink" title="htonl() 函数、htons() 函数"></a><code>htonl()</code> 函数、<code>htons()</code> 函数</h1><p>在吴秦的博客里重点强调了主机字节序（host byte order）与网络字节序（network byte order）的，上述两个函数就是用来实现两者之间的转换的。参考 <a href="http://beej.us/guide/bgnet/output/html/multipage/htonsman.html">Beej’s Guide to Network Programming</a> 我们能够找到以下函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不需要死记硬背，函数的命名通俗易懂。强调一下，转换 ip 地址使用长整型转换函数，转换 port 使用短整型转换函数。我在码代码学习时，误用 <code>htonl(6666)；</code> 转换端口编译通过，运行时也不报错，启动多个服务程序也不报错 ps 正常情况重复启动服务程序时会报错“端口已经占用”。</p>
<h2 id="INADDR-ANY-宏"><a href="#INADDR-ANY-宏" class="headerlink" title="INADDR_ANY 宏"></a><code>INADDR_ANY</code> 宏</h2><p>详细解释参考 <a href="https://stackoverflow.com/questions/16508685/understanding-inaddr-any-for-socket-programming-c">understanding INADDR_ANY for socket programming - c</a>。在此只强调一点，<code>INADDR_ANY</code> 表示的是一个服务器上所有的网卡。</p>
<h1 id="inet-pton-函数"><a href="#inet-pton-函数" class="headerlink" title="inet_pton() 函数"></a><code>inet_pton()</code> 函数</h1><p>IP地址转换函数，可以在将 IP 地址在“点分十进制”和“二进制整数”之间转换。在 <a href="http://beej.us/guide/bgnet/output/html/multipage/inet_ntopman.html">Beej’s Guide to Network Programming</a> 我们找到的描述以及函数原型：</p>
<blockquote>
<p>Convert IP addresses to human-readable form and back.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure>
<p>强调一点，<code>inet_pton()</code> 同样支持 “localhost”。</p>
<h1 id="inet-addr-函数"><a href="#inet-addr-函数" class="headerlink" title="inet_addr() 函数"></a><del><code>inet_addr()</code> 函数</del></h1><blockquote>
<p>Convert IP addresses from a dots-and-number string to a <code>struct in_addr</code> and back</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ALL THESE ARE DEPRECATED!  Use inet_pton()  or inet_ntop() instead!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看到其中的注释，这三个函数即将淘汰。</p>
<h1 id="学习-libevent"><a href="#学习-libevent" class="headerlink" title="学习 libevent"></a>学习 libevent</h1><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li><p><code>select()</code> 函数第一个参数为什么要 <code>maxfd+1</code>？不理解 <a href="http://www.wangafu.net/~nickm/libevent-book/01_intro.html">官方手册</a> 中讲述 <code>select()</code> 低效的这段话：</p>
<blockquote>
<p>On the userspace side, …But on the kernel side,…</p>
</blockquote>
</li>
<li><p>为什么在 Example: select()-based ROT13 server 中需要 <code>make_nonblocking()</code> ？为什么 Example: A low-level ROT13 server with Libevent 中需要 <code>evutil_make_socket_nonblocking()</code>？</p>
</li>
<li><p><code>setvbuf(stdout, NULL, _IONBF, 0);</code> 的意义？</p>
</li>
</ol>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>最初步的认识，最简单的例子：<a href="http://hahaya.github.io/hello-in-libevent/">使用libevent输出Hello</a></p>
<blockquote>
<p>（niel）这里只提到了 <code>strcut event_base</code>、<code>struct event</code>。给出的简单示例代码里，有一处瑕疵： <code>event_base_set()</code> 函数属于过时的函数，在 2.0 之前的版本中配合 <code>event_set()</code> 使用，在 2.0 及其之后的版本中这两者被  <code>event_new()</code> 替代，所以作者混用 <code>event_new()</code> + <code>event_base_set()</code> 表明了作者并未多花时间学习。</p>
</blockquote>
<p>接下来，我们可以学习一下：<a href="http://blog.sina.com.cn/s/blog_9db214690101cet0.html">libevent入门教程：Echo Server based on libevent </a></p>
<blockquote>
<p>（niel）这篇博客循序渐进，讲到了 <code>strcut buffevent</code> 及其相关操作。美中不足的是作者在介绍过程中穿插记录了自己的疑惑，新手读起来打破了学习的连贯性，本就在学习新知识，却也要困于作者的“泥潭”。只能说这真的只是作者的学习笔记，并未从读者的角度做考虑。总的来说，帖子很不错！初次学习时，这些问题的存在让人很难受，影响学习进度、学习动力；但熟悉作者讲的知识之后，这些问题反而才是“金子”，认真思考这些问题。</p>
</blockquote>
<p>接下来推荐的学习资源就是官方手册了：<a href="http://www.wangafu.net/~nickm/libevent-book/">Programming with Libevent</a></p>
<blockquote>
<p>（niel）虽然是用英文写的，但阅读起来毫无障碍，很容易理解。marks  C0、C1、R0 ~ R4、R8 认真阅读；R5、R6 重点关注了小部分函数，其余走马观花浏览了一下；R6a、R7、R9 三节没有看。开发过程中，查阅函数原型肯定是得翻这个手册的！</p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000005594871">Libevent 官方文档学习笔记</a>，这篇帖子可以看一看，和自己读英文手册理解的相互佐证。</p>
<p><a href="https://taozj.org/201605/learn-note-of-libevent-(1)-basic-usage.html">Libevent学习笔记（一）：基本使用</a>，检验自己的学习成果。</p>
<blockquote>
<p>总的来说，后面这两篇帖子并不适合用来学习。更多的定位于作者知识的整理，并不是面向新手的入门介绍。</p>
</blockquote>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>spdlog 日志库</title>
    <url>/2019/05/07/spdlog/</url>
    <content><![CDATA[<p>在项目中弃用 glog，改用 <a href="https://github.com/gabime/spdlog">spdlog</a>。花了三个小时，跟了一遍 example.cpp 中提到 <code>xxx_example()</code>，当底层跳转要进入 fmt 时就不再追踪。</p>
<h1 id="学习-spdlog-源码"><a href="#学习-spdlog-源码" class="headerlink" title="学习 spdlog 源码"></a>学习 spdlog 源码</h1><ol>
<li>在单参数构造函数中明确使用 <code>explicit</code> 关键词，避免隐式构造，避免隐式类型转换。</li>
<li>log.h 存放模板类声明，但在头文件末尾 <code>#include log_impl.h</code>，后者存放模板类的定义</li>
<li>颜色默认只针对 level 关键词，不同级别预设了不同的色彩。但也可以使用 <code>%^</code> <code>%$</code> 划定收尾。</li>
<li>线程安全，支持多线程</li>
<li>注册表工厂模式？</li>
<li>fmt/spdlog 如何输出和二进制的？<code>spdlog::to_hex</code> 与 fmt 自身的二进制格式化输出有什么不同？ <a href="http://fmtlib.net/latest/api.html#formatting-user-defined-types">fmt 对自定义类型的支持</a></li>
<li>spdlog 本身是线程安全的，async_ 定位？</li>
<li>spdlog 开启 <code>FMT_HEADER_ONLY</code> 预编译宏，使用 fmt</li>
<li>spdlog 以 head-only 方式使用</li>
</ol>
<a id="more"></a>

<p>spdlog 整体框架分为两层：logger /async_logger 和 sink。一个 logger 可以拥有多个 sink；一个 sink 可以同时被多个 logger 使用。</p>
<p>spdlog 用户传入的原始内容，在 logger 经过 <a href="http://fmtlib.net/latest/usage.html">fmt 格式化</a> 后赋值给 <code>raw_msg</code>，然后结合 time/threadid/level 等属性构造 <code>log_msg</code> 对象传递给底层的 sink 们，sink 负责打印到屏幕或输出到文件（循环写入或者每天生成新文件等多种方式）。</p>
<p>time/threadid/level 等属性和 raw_msg 的格式化<sup>1</sup>（以怎样的形式打印），是通过 sink 设置 <code>pattern_format</code>。</p>
<p>通过两层结构实现两次 level 过滤，实现内容和属性的两次格式化；通过 logger sink 多对多组合，支持不同模块不同级别的日志输出，极大地实现自由度，解耦合。</p>
<p><a href="https://github.com/gabime/spdlog/wiki/1.1.-Thread-Safety">线程安全</a> 特性：</p>
<ul>
<li>sink 区分 <code>_mt</code> 和 <code>_st</code> 两种：前者加锁，是线程安全的；后者没有使用锁，所以只能在单线程中使用。</li>
<li>logger 携带的状态除了错误处理句柄之外都是原子的（无锁结构？），所以如果不修改错误句柄，也是线程安全的。</li>
<li>async_logger 是把「递送 <code>log_msg</code> 给 sink，sink 输出」通过队列交给了其余线程来做，当业务线程对于日志模块「递送，输出」耗时敏感时才有必要使用 async_logger 类型。更多请移步到 <a href="https://github.com/gabime/spdlog/wiki/6.-Asynchronous-logging">手册</a></li>
</ul>
<p>sup1：此次格式化由 <a href="https://github.com/gabime/spdlog/wiki/3.-Custom-formatting">spdlog 约定</a>，和 fmt 无关。</p>
<p>flush 接口，根据底层 sink 类型，要么为空（eg. 控制台），要么调用 <a href="https://zh.cppreference.com/w/cpp/io/c/fflush"><code>std::fflush( std::FILE* stream )</code></a><sup>2</sup>。更多 Flush 策略请查看其 <a href="https://github.com/gabime/spdlog/wiki/7.-Flush-policy">手册</a></p>
<p>sup2：正如手册中描述的，<code>std::fflush()</code> 并不能用于输入流。<a href="https://segmentfault.com/a/1190000010256854">扩展阅读</a></p>
<h2 id="阅读-spdlog-手册"><a href="#阅读-spdlog-手册" class="headerlink" title="阅读 spdlog 手册"></a>阅读 spdlog 手册</h2><ol>
<li>How to use spdlog in DLLs</li>
<li><a href="https://github.com/gabime/spdlog/wiki/Default-logger">Default logger</a>，此特性在 v1.3.0 之后才添加</li>
</ol>
<h1 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h1><p>spdlog 在 windows 平台可以使用 vcpkg 部署。但是 vcpkg 部署其依赖的 fmt 时并未采用 head-only 方式，造成在我们自己的项目中需要依赖 fmt.dll 动态库（ vcpkg 会自动帮我们拷贝到 .exe 目标目录中）</p>
<h1 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h1><ol>
<li>fmt 是如何支撑 head-only ?</li>
<li>为什么同时提供 head-only 和 dll?</li>
<li><a href="http://fmtlib.net/latest/api.html#formatting-user-defined-types">Formatting user-defined types</a></li>
<li>其 <a href="http://fmtlib.net/latest/index.html#safety">类型安全</a> 方面的错误，是如何做到在<strong>编译期间</strong>抛出的？</li>
</ol>
<p>The <code>fmt::print</code> function performs formatting and writes the result to a stream:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::print(<span class="built_in">stderr</span>, <span class="string">&quot;System error code = &#123;&#125;\n&quot;</span>, errno);</span><br></pre></td></tr></table></figure>
<p>The file argument can be omitted in which case the function prints to <code>stdout</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::print(<span class="string">&quot;Don&#x27;t &#123;&#125;\n&quot;</span>, <span class="string">&quot;panic&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>The Format API also supports positional arguments useful for localization:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::print(<span class="string">&quot;I&#x27;d rather be &#123;1&#125; than &#123;0&#125;.&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;happy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Named arguments can be created with <code>fmt::arg</code>. This makes it easier to track what goes where when multiple values are being inserted:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::print(<span class="string">&quot;Hello, &#123;name&#125;! The answer is &#123;number&#125;. Goodbye, &#123;name&#125;.&quot;</span>,</span><br><span class="line">     fmt::arg(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;World&quot;</span>), fmt::arg(<span class="string">&quot;number&quot;</span>, <span class="number">42</span>));</span><br></pre></td></tr></table></figure>
<p>fmt 库较小，也可能和其较新有关，网上有关的中文描述很少：<a href="https://moevis.github.io/cheatsheet/2018/10/11/fmt-%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84-c++-format-%E5%BA%93.html">Fmt:更方便的 c++ format 库</a></p>
<p>引入 fmt 时引发的<strong>编译失败现象</strong>：<a href="https://github.com/tnie/TestSOCI/issues/3">引入 fmt，<code>#include</code> 需要带前置目录</a>，或者需要删除（或重命名）库中的 <code>time.h</code> 和 <code>locale.h</code> 头文件</p>
<h2 id="为什么放弃-glog"><a href="#为什么放弃-glog" class="headerlink" title="为什么放弃 glog"></a>为什么放弃 glog</h2><p>当初放弃 glog，改用 spdlog 的动机大概是以下三点：</p>
<ol>
<li>沿用了标准输出流的 &lt;&lt;，在格式化输出上短板；</li>
<li>head file + lib，无法做到 head-only</li>
<li>服务端在用 spdlog，作为菜鸟初上手 glog 不自信；</li>
</ol>
<p>现在回头看，似乎都站不住脚。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>-std= 语言标准</title>
    <url>/2017/03/10/standardOfLanguage/</url>
    <content><![CDATA[<p>2016/5/27 13:13:10</p>
<p>gcc 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cts@SuSe-CTS2:~&gt; gcc --version</span><br><span class="line">gcc (SUSE Linux) 4.3.4 [gcc-4_3-branch revision 152973]</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">cts@SuSe-CTS2:~&gt; man gcc</span><br><span class="line">...(略)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>-std=<br>Determine the language standard.   This option is currently only supported when compiling C or C++.</p>
<p>The compiler can accept several <strong>base standards</strong>, such as c89 or c++98, and <strong>GNU dialects（方言；同源语） of those standards</strong>, such as gnu89 or gnu++98.  By specifing a base standard, the compiler will accept all programs following that standard and those using GNU extensions that do not contradict it.  For example, -std=c89 turns off certain features of GCC that are incompatible with ISO C90, such as the “asm” and “typeof” keywords, <strong>but not other GNU extensions</strong> that do not have a meaning in ISO C90, such as omitting the middle term of a “?:” expression. On the other hand, by specifing a GNU dialect of a standard, all features the compiler support are enabled, even when those features change the meaning of the base standard and some strict-conforming programs may be rejected.  The particular standard is used by <strong>-pedantic（迂腐的；学究式的）</strong> to identify which features are GNU extensions given that version of the standard. For example -std=gnu89 -pedantic would warn about C++ style // comments, while -std=gnu99 -pedantic would not.</p>
<p>A value for this option must be provided; possible values are</p>
<p>c89<br>iso9899:1990<br>    Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as -ansi for C code.</p>
<p>iso9899:199409<br>    ISO C90 as modified in amendment 1.</p>
<p>c99<br>c9x<br>iso9899:1999<br>iso9899:199x<br>    ISO C99.  Note that this standard is not yet fully supported; see <a href="http://gcc.gnu.org/gcc-4.3/c99status.html">http://gcc.gnu.org/gcc-4.3/c99status.html</a> for more information.  The names c9x and  iso9899:199x are deprecated.</p>
<p>gnu89<br>    GNU dialect of ISO C90 (including some C99 features). This is <strong>the default for C code</strong>.</p>
<p>gnu99<br>gnu9x<br>    GNU dialect of ISO C99.  When ISO C99 is fully implemented in GCC, this will become the default.  The name gnu9x is deprecated.</p>
<p>c++98<br>    The 1998 ISO C++ standard plus amendments. Same as -ansi for C++ code.</p>
<p>gnu++98<br>    GNU dialect of -std=c++98.  This is <strong>the default for C++ code.</strong></p>
<p>c++0x<br>    The working draft of the upcoming ISO C++0x standard. This option enables experimental features that are likely to be included in C++0x. The working draft is constantly changing, and any feature that is enabled by this flag may be removed from future versions of GCC if it is not part of the C++0x standard.</p>
<p>gnu++0x<br>    GNU dialect of -std=c++0x. This option enables experimental features that may be removed in future versions of GCC.</p>
</blockquote>
<p>目前在 gcc 官方上最新版为 gcc 6.1 ，其中：</p>
<blockquote>
<p>‘gnu11’<br>‘gnu1x’<br>GNU dialect of ISO C11. This is <strong>the default</strong> for C code. The name ‘gnu1x’ is deprecated. </p>
<p>‘c++98’<br>‘c++03’<br>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as -ansi for C++ code. </p>
<p>‘gnu++98’<br>‘gnu++03’<br>GNU dialect of -std=c++98. </p>
<p>‘c++11’<br>‘c++0x’<br>The 2011 ISO C++ standard plus amendments. The name ‘c++0x’ is deprecated. </p>
<p>‘gnu++11’<br>‘gnu++0x’<br>GNU dialect of -std=c++11. The name ‘gnu++0x’ is deprecated. </p>
<p>‘c++14’<br>‘c++1y’<br>The 2014 ISO C++ standard plus amendments. The name ‘c++1y’ is deprecated. </p>
<p>‘gnu++14’<br>‘gnu++1y’<br>GNU dialect of -std=c++14. This is <strong>the default</strong> for C++ code. The name ‘gnu++1y’ is deprecated. </p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>sscanf 和正则表达式</title>
    <url>/2016/11/30/sscanf-regular/</url>
    <content><![CDATA[<p>有一篇很好的入门的帖子：<a href="http://blog.csdn.net/kenby/article/details/4051018">sscanf 函数和正则表达式</a> </p>
<p>“<code>%</code> 表示选择，<code>%*</code> 表示过滤”，这是一个很精辟的定义。建议先看上面的链接！当然如果要在项目中正确的使用 <code>sscanf</code> 做字符串的筛选、提取，单单看上面一篇帖子是远远不够的。以下：</p>
<p><code>sscanf()</code> - 从一个字符串中读进与指定格式相符的数据</p>
<a id="more"></a>

<h2 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">( <span class="built_in">string</span> str, <span class="built_in">string</span> fmt, mixed var1, mixed var2 ... )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format [,argument]... )</span></span>; </span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p><code>sscanf()</code> 与 <code>scanf()</code> 类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。</p>
<p>其中的 format 可以是一个或多个 {<code>%[*] [width] [&#123;h | l | I64 | L&#125;]type</code> | ‘ ‘ | ‘/t’ | ‘/n’ | 非%符号}。</p>
<ul>
<li>空白字符</li>
<li>非空白字符，且不是 <code>%</code></li>
<li>以 <code>%</code> 开始的 Format specifiers</li>
</ul>
<p>具体的描述<a href="http://www.cplusplus.com/reference/cstdio/scanf/">请移步</a></p>
<ol>
<li><code>*</code> 亦可用于格式中, (即 <code>%*d</code> 和 <code>%*s</code>) 加了星号 (<code>*</code>) 表示跳过此数据不读入. (也就是不把此数据读入参数中)</li>
<li><code>&#123;a|b|c&#125;</code> 表示a,b,c中选一，<code>[d]</code> 表示可以有d也可以没有d。</li>
<li><code>width</code> 表示读取宽度。</li>
<li><code>&#123;h | l | I64 | L&#125;</code>：参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。</li>
<li><code>type</code> :这就很多了，就是 <code>%s</code>,<code>%d</code> 之类。</li>
<li>特别的：<code>%*[width] [&#123;h | l | I64 | L&#125;]type</code> 表示满足该条件的被过滤掉，不会向目标参数中写入值</li>
</ol>
<p>支持集合操作：</p>
<ul>
<li><code>%[a-z]</code> 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)</li>
<li><code>%[aB&#39;]</code> 匹配a、B、’中一员，贪婪性</li>
<li><code>%[^a]</code> 匹配非a的任意字符，贪婪性</li>
</ul>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><ol>
<li><p>常见用法。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>] = ;</span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456 &quot;</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456 &quot;</span>, <span class="string">&quot;%4s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：1234</span></span><br></pre></td></tr></table></figure></li>
<li><p>取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456 abcdedf&quot;</span>, <span class="string">&quot;%[^ ]&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="string">&quot;%[1-9a-z]&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：123456abcdedf</span></span><br></pre></td></tr></table></figure></li>
<li><p>取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456abcdedfBCDEF&quot;</span>, <span class="string">&quot;%[^A-Z]&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：123456abcdedf</span></span><br></pre></td></tr></table></figure></li>
<li><p>给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将 “iios/“过滤掉，再将非‘@’的一串内容送到buf中</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;iios/12DDWDFF@122&quot;</span>, <span class="string">&quot;%*[^/]/%[^@]&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：12DDWDFF</span></span><br></pre></td></tr></table></figure></li>
<li><p>给定一个字符串““hello, world”，仅保留world。（注意：“，”之后有一空格）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(“hello, world”, <span class="string">&quot;%*s%s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, buf);</span><br><span class="line"><span class="comment">//结果为：world</span></span><br><span class="line"><span class="comment">//%*s表示第一个匹配到的%s被过滤掉，即hello被过滤了；如果没有空格则结果为NULL。</span></span><br></pre></td></tr></table></figure>
<p>　　<br><code>sscanf</code> 的功能很类似于正则表达式, 但却没有正则表达式强大,所以如果对于比较复杂的字符串处理,建议使用正则表达式.</p>
</li>
</ol>
<p>更多的使用时的细节可以在网上查找，资料还是很多的。</p>
<p>ps 解析url各个部分：<a href="http://blog.csdn.net/phil2036/article/details/4221704">本文的命题源自于这样的一个url，protocol://ip:port/chn/mode，比如说，dv://192.168.1.253:65001/1/1。如果我要解析出来各个部分……</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>streambuf</title>
    <url>/2018/12/03/streambuf/</url>
    <content><![CDATA[<h1 id="streambuf"><a href="#streambuf" class="headerlink" title="streambuf"></a>streambuf</h1><p>中文版 <a href="https://zh.cppreference.com/w/cpp/io/basic_streambuf">https://zh.cppreference.com/w/cpp/io/basic_streambuf</a>，偶有误差，可参考英文版本纠正。</p>
<p>英文版 <a href="https://en.cppreference.com/w/cpp/io/basic_streambuf">https://en.cppreference.com/w/cpp/io/basic_streambuf</a></p>
<p>类 basic_streambuf 控制字符序列的输入与输出。它包含下列内容并提供到它们的访问：</p>
<ol>
<li><p>受控字符序列（<em>The controlled character sequence</em>），也称作 <em>buffer</em>，可包括：<em>input sequence</em> (also called <em>get area</em>) 用于缓冲输入操作；以及 <em>output sequence</em> (also called <em>put area</em>) 用于缓冲输出操作。</p>
</li>
<li><p>关联字符序列，又称作源（对于输入）或池（对于输出）。它可以是通过 OS API 访问的实体（文件、 TCP 接头、串行端口、其他字符设备），或者可以是能转译成字符源或池的对象（ <code>std::vector</code> 、数组、字符串字面量）</p>
</li>
</ol>
<p>受控制序列中的字符表示和编码可以异于关联序列中的字符表示，该情况下典型地用 <code>std::codecvt</code> 本地环境进行转换。常见的例子是通过 <code>std::wfstream</code> 对象访问 UTF-8 （或其他多字节编码）文件：受控制字符序列由 <code>wchar_t</code> 字符组成，但关联序列由字节组成。</p>
<a id="more"></a>

<p>A <code>basic_streambuf</code> object may support <em>input</em> (in which case the buffer described by the beginning, next, and end pointers is called <em>get area</em>), output (<em>put area</em>), or input and output simultaneously.</p>
<blockquote>
<p><code>basic_streambuf</code> 对象可支持<em>输入</em>（该情况下起始、下一位置和终止指针所描述的区域被称为<em>获取区</em>）、输出（<em>放置区</em>），或同时输入与输出。</p>
</blockquote>
<p>If the next pointer is less than the end pointer in the <em>put area</em>, a <em>write position</em> is available. The next pointer can be dereferenced and assigned to.</p>
<blockquote>
<p>若 <del>获取区</del> <em>放置区</em>（output sequence） 中下一位置指针小于终止指针，则写位置可用。下一位置指针可被解引用和赋值。<strong>写入</strong>，参考 <code>cout</code> 用来输出。</p>
</blockquote>
<p>If the next pointer is less than the end pointer in the <em>get area</em>, a <em>read position</em> is available. The next pointer can be dereferenced and read from.</p>
<blockquote>
<p>若 <del>放置区</del> <em>获取区</em>（input sequence） 中下一位置指针小于终止指针，则读位置可用。下一位置指针可被解引用和读取。<strong>读出</strong>，参考 <code>cin</code> 用来写入。</p>
</blockquote>
<p>If the next pointer is greater than the beginning pointer in a <em>get area</em>, a <em>putback position</em> is available, and the next pointer may be decremented, dereferenced, and assigned to, in order to put a character back into the <em>get area</em>.</p>
<blockquote>
<p>若 <em>获取区</em>（input sequence） 中下一位置指针大于起始指针，则回放位置可用，而下一位置指针可以被自减并赋值，以将字符放回到获取区。</p>
</blockquote>
<p><a href="https://blog.csdn.net/man_sion/article/details/78110842" title="c++ 流对象之streambuf">c++ 流对象之 streambuf</a></p>
<h2 id="asio-streambuf"><a href="#asio-streambuf" class="headerlink" title="asio::streambuf"></a>asio::streambuf</h2><p><a href="https://www.jianshu.com/p/c33e7265acd8">发送接收缓存asio::buffer及asio::streambuf</a></p>
<p><a href="https://www.jianshu.com/p/1dd00d469ada">https://www.jianshu.com/p/1dd00d469ada</a></p>
<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><p>对于输入输出流，虽然频繁在用 <code>cout</code>/<code>cin</code>，但也只限于标准输入、输出，只限于正确流程。如果有任何的异常处理，认知为零。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; expected_int;</span><br><span class="line"><span class="comment">// 如果输入为字母等非数值，后续 cin 就不能用了</span></span><br><span class="line">assert(<span class="built_in">cin</span>.good()); <span class="comment">// false</span></span><br><span class="line">assert(<span class="built_in">cin</span>.bad());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">istream is;</span><br><span class="line"><span class="comment">// 从空的输入流中做格式化输入，会发生错误</span></span><br><span class="line">is &gt;&gt; something;</span><br><span class="line">assert(is.good());  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/zhangyifei216/article/details/50545572">深入理解C++输入输出流</a></p>
<blockquote>
<p>流的状态到底在什么情况下会发生改变呢，每一种状态会对io流操作产生什么影响呢？这或许是我对流的状态这个知识点的疑问。</p>
</blockquote>
<p>——不能同意更多</p>
<blockquote>
<p>因为 IO 流出现在 C++ 引入异常之前，所以错误处理方式仍是像 C 那样去检查错误码或者状态等来判断。</p>
<p>流发生错误，需要手动查看其状态才能知道，这是早起 c++ 不支持异常导致的。为了兼容，一致沿用。<br>为了统一使用异常来处理错误，可以使用流的 <a href="https://zh.cppreference.com/w/cpp/io/basic_ios/exceptions"><code>exception</code> 函数</a> 来设置当发生了指定流状态的时候触发异常。</p>
</blockquote>
<p>——似乎流的异常并不好用。抽空验证~</p>
<h1 id="asio-async-write-有坑"><a href="#asio-async-write-有坑" class="headerlink" title="asio::async_write 有坑"></a>asio::async_write 有坑</h1><p><a href="https://blog.csdn.net/cedricporter/article/details/6915775">https://blog.csdn.net/cedricporter/article/details/6915775</a></p>
<blockquote>
<p><code>async_write</code> 是通过一次或者多次调用 <code>async_write_some</code> 函数来实现的，那么如果在第一个 <code>async_write</code> 还没有完成就调用第二个 <code>async_write</code>，<code>async_write_some</code> 就有可能先将第二个 <code>buffer</code> 的数据先发送出去。</p>
<p>服务器可能会接收到完全错乱的数据。</p>
</blockquote>
<h1 id="asio-读写接口"><a href="#asio-读写接口" class="headerlink" title="asio 读写接口"></a>asio 读写接口</h1><p>异步接口形式比同步接口增加 <code>async_</code> 前缀。</p>
<h2 id="同步接口"><a href="#同步接口" class="headerlink" title="同步接口"></a>同步接口</h2><p>类成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">socket.send()</span><br><span class="line">socket.receive()</span><br><span class="line"></span><br><span class="line">socket.write_some()</span><br><span class="line">socket.read_some()</span><br></pre></td></tr></table></figure>
<p>自由函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">write(socket, ...)</span><br><span class="line">read (socket, ...)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/qicosmos/p/3487169.html">https://www.cnblogs.com/qicosmos/p/3487169.html</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>_stscanf_s 函数</title>
    <url>/2017/03/08/stscanf-s/</url>
    <content><![CDATA[<p>MSDN 对这个函数描述。Example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crt_sscanf_s.c</span></span><br><span class="line"><span class="comment">// This program uses sscanf_s to read data items</span></span><br><span class="line"><span class="comment">// from a string named tokenstring, then displays them.</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>  tokenstring[] = <span class="string">&quot;15 12 14...&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span>  s[<span class="number">81</span>];</span><br><span class="line">   <span class="keyword">char</span>  c;</span><br><span class="line">   <span class="keyword">int</span>   i;</span><br><span class="line">   <span class="keyword">float</span> fp;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Input various data from tokenstring:</span></span><br><span class="line">   <span class="comment">// max 80 character string plus NULL terminator</span></span><br><span class="line">   sscanf_s( tokenstring, <span class="string">&quot;%s&quot;</span>, s, _countof(s) );</span><br><span class="line">   sscanf_s( tokenstring, <span class="string">&quot;%c&quot;</span>, &amp;c, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   sscanf_s( tokenstring, <span class="string">&quot;%d&quot;</span>, &amp;i );</span><br><span class="line">   sscanf_s( tokenstring, <span class="string">&quot;%f&quot;</span>, &amp;fp );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Output the data read</span></span><br><span class="line">   printf_s( <span class="string">&quot;String    = %s\n&quot;</span>, s );</span><br><span class="line">   printf_s( <span class="string">&quot;Character = %c\n&quot;</span>, c );</span><br><span class="line">   printf_s( <span class="string">&quot;Integer:  = %d\n&quot;</span>, i );</span><br><span class="line">   printf_s( <span class="string">&quot;Real:     = %f\n&quot;</span>, fp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sscanf_s 取值的时候，<strong>需要在每个取值后面指定取值的最大大小。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain()</span><br><span class="line">&#123; </span><br><span class="line">    TCHAR str[] = _T(<span class="string">&quot;CSFS dfdfd&quot;</span>);</span><br><span class="line">    TCHAR szBuff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TCHAR szBuff2[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    _stscanf_s(str, _T(<span class="string">&quot;%s%s&quot;</span>), szBuff, _countof(szBuff), szBuff2, _countof(szBuff2));</span><br><span class="line">    _tprintf(_T(<span class="string">&quot;%s\n%s\n&quot;</span>), szBuff, szBuff2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与互斥</title>
    <url>/2016/11/03/synchronization-mutex/</url>
    <content><![CDATA[<p>由生产者-消费者模式展开，学习其编程的最佳实践，却发现自己不知“信号量”的概念，忘了PV操作，困惑于“使用数组做循环队列时，判断满、空的条件怎么写”，为什么不直接使用 STL 的容器做队列？进出队列是不是严格需要锁？获取队列大小时是不是严格需要锁？</p>
<h1 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h1><p>参考来源：<a href="http://c.biancheng.net/cpp/html/2589.html">C 语言中文网</a></p>
<p>进程控制块（PCB）</p>
<blockquote>
<p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。</p>
</blockquote>
<a id="more"></a>

<p>进程的状态：</p>
<ol>
<li>创建状态：</li>
<li>就绪状态：</li>
<li>运行状态：</li>
<li>阻塞状态：</li>
<li>终止状态：</li>
</ol>
<p>进程的通信：PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。</p>
<ol>
<li><p>共享存储</p>
<p> 在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。</p>
<p> 共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。</p>
</li>
<li><p>消息传递</p>
</li>
<li><p>管道通信</p>
<p> 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。</p>
<p> 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
</li>
</ol>
<h2 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h2><p>临界资源：虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。</p>
<p>临界区：对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p>
<ol>
<li>进入区-为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>临界区-进程中访问临界资源的那段代码，又称临界段。</li>
<li>退出区-将正在访问临界区的标志清除。</li>
<li>剩余区-代码中的其余部分。</li>
</ol>
<p>同步：同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>互斥：互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>原语</strong>：原语是指完成某种功能且不被分割不被中断执行的操作序列。</p>
<p>信号量：信号量机制是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”和“V操作”。</p>
<blockquote>
<p>P和V是来源于两个荷兰语词汇，P—— passeren，中文译为”通过”；V—— vrijgeven，中文译为”释放/发布”。</p>
</blockquote>
<ul>
<li>整型信号量</li>
<li>记录信号量</li>
</ul>
<p>利用信号量可以解决的问题：</p>
<ol>
<li>利用信号量实现同步</li>
<li>利用信号量实现互斥</li>
<li>利用信号量实现前驱关系</li>
</ol>
<p>分析进程同步和互斥问题的方法步骤：</p>
<ol>
<li>关系分析-找出问题中的进程数，并且分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。</li>
<li>整理思路-找出解决问题的关键点，并且根据做过的题目找出解决的思路。根据进程的操作流程确定P操作、V操作的大致顺序。</li>
<li>设置信号量-根据上面两步，设置需要的信号量，确定初值，完善整理。</li>
</ol>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程：系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p>
<p>管程的基本特征之一是：每次仅允许一个进程在管程内执行某个内部过程。</p>
<p>由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注，而且保证正确。</p>
<p>在 <a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">维基百科 - 生产者消费者问题</a> 中介绍“使用管程的算法”时特别强调了使用 <code>while</code> 的重要性和正确性。然后我并没有看懂啊，囧。</p>
<p>针对多消费者（或多生产者），有可能造成竞争条件：</p>
<blockquote>
<p>某一消费者在一项数据被放入缓冲区中时被唤醒，但是另一消费者已经在管程上等待了一段时间并移除了这项数据。</p>
</blockquote>
<p>但前文提到：</p>
<blockquote>
<p>管程的基本特征之一是：每次仅允许一个进程在管程内执行某个内部过程。</p>
</blockquote>
<p>这两点不冲突吗？所以，管程到底是什么？</p>
<h2 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h2><ol>
<li>生产者-消费者问题</li>
<li>读者-写者问题</li>
<li>哲学家进餐问题</li>
<li>吸烟者问题</li>
</ol>
<p>真心好玩！</p>
<h2 id="我的困惑"><a href="#我的困惑" class="headerlink" title="我的困惑"></a>我的困惑</h2><p>管程在 C++ 中有对应的实现吗？代码的实例。做出进一步地了解之后，复习“管程”章节。</p>
<p>在 <a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">维基百科 - 生产者消费者问题</a> 中也提到了不使用信号量和管程实现生产者消费者问题的方式。</p>
<blockquote>
<p>对于生产者消费者问题来说，特别是当只有一个生产者和一个消费者时，实现一个先进先出结构或者通信通道非常重要。这样，生产者-消费者模式就可以在不依赖信号灯、互斥变量或管程的的情况下高效地传输数据。</p>
<p>人们喜欢用先进先出结构或者通信通道，只是因为可以避免端与端之间的原子性同步。</p>
</blockquote>
<p>问题一：使用信号量解决生产者消费者问题时做同步能理解，但为什么要做互斥？是针对缓冲区的修改吗？插入和删除可能正好是同一块存储？</p>
<p>问题二：保证先进先出就能够保证互斥？同步由 <code>while</code> 实现？</p>
<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><p>参考来源：<a href="http://blog.csdn.net/yusiguyuan/article/details/14160081">线程间同步–互斥锁、条件变量、信号量</a></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><strong>互斥锁</strong>是最常用的。使用时包含 <code>#include &lt;pthread.h&gt;</code> 头文件即可。</p>
<p>对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><strong>条件变量</strong>：在pthread库中通过条件变量（Condition Variable）来阻塞等待一个条件，或者唤醒等待这个条件的线程。</p>
<p>——问题1：开发实践中应用得多吗？某些场景下感觉可以用 <code>while-sleep</code> 替换，使用条件变量有什么优点吗？</p>
<blockquote>
<p>其实想一想，pthread_cond_wait函数也可以用一个while死循环来等待条件的成立，但要注意的是，使用while死循环会严重消耗CPU，而pthread_cond_wait则是采用线程睡眠的方式，它是一种等待模式，而不是一直的检查模式。<a href="http://blog.csdn.net/yusiguyuan/article/details/14161225">引用来源</a></p>
</blockquote>
<p>——问题2：<a href="http://www.cnblogs.com/clover-toeic/p/4029269.html">Linux线程编程之生产者消费者问题</a> 中条件变量的代码使用了 <code>while</code>，和上一章节“管程”中的使用一致。和使用 <code>if</code> 有特别大的区别吗？我是指两者在多消费者（或多生产者）的情况下，无论是用 <code>while</code>，还是 <code>if</code> 都可能造成竞争吧？</p>
<blockquote>
<p><code>pthread_cond_wait()</code> 返回时，互斥量再次被锁定并被调用线程拥有。</p>
</blockquote>
<p>——问题3：针对上一问题中使用 <code>while</code> 的必要性</p>
<blockquote>
<p>虚假唤醒(spurious wakeup)指没有线程明确调用cond_signal/broadcast()时，cond_wait()偶尔也会返回；或者条件状态尚不满足时就调用cond_signal/broadcast()。此时，线程虽被唤醒但条件并不成立，若不再次检查条件而往下执行，很可能导致后续的处理出现错误。因此，当从cond_wait()返回时，线程应重新测试条件成立与否。该过程一般用while循环实现。</p>
<p>使用while循环不仅能避免虚假唤醒造成的错误，还能避免唤醒线程间竞争导致的“惊群效应”。</p>
<p>例如，ProducerThread()内，调用cond_wait()对互斥量自动解锁后，在允许消费者线程修改条件的同时，也允许其他生产者线程调用该函数依次阻塞。当这些线程被唤醒时(如队列由满变为非满)，会再次竞争相应的互斥量。获得互斥量的那个线程进入临界区处理，这可能改变测试条件(如产出一件使得队列再次变满)。该线程释放互斥量后，其他某个处于等待状态的线程获得该互斥量时，虽然cond_wait()成功返回但很可能条件已不成立。因此，调用cond_wait()成功返回时，线程需要重新测试条件是否满足。 <a href="http://www.cnblogs.com/clover-toeic/p/4029269.html">引用来源</a></p>
</blockquote>
<p><strong>强烈推荐</strong> <a href="http://www.cnblogs.com/clover-toeic/p/4029269.html">Linux线程编程之生产者消费者问题</a> 帖子中的 2.3注意事项 ☆☆☆☆☆，尤其是其中的第1项、第5项、第7项、第8项和第9项。</p>
<p>互斥锁和条件变量的区别：</p>
<ol>
<li>互斥锁和条件变量的初始化很一致；</li>
<li>使用上，互斥锁先是调用 <code>pthread_mutex_lock</code> 获得锁，获取到则向下执行，如果未获取到则阻塞，直到其被释放（<code>pthread_mutex_unlock</code>）；</li>
<li>而条件变量调用 <code>pthread_cond_wait</code> 之后直接阻塞，直到被唤醒（<code>pthread_cond_signal</code>）；</li>
</ol>
<p><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); </code> 函数做以下三步操作：</p>
<ol>
<li>释放 Mutex</li>
<li>阻塞等待</li>
<li>当被唤醒时，重新获得 Mutex并返回</li>
</ol>
<p>需要强调的是前两个操作是原子性的（不包括第3个）。</p>
<p>这些本质上都是条件判断，为什么不能用全局变量？参见 <a href="http://c.biancheng.net/cpp/html/2589.html">C 语言中文网 - 实现临界区互斥的基本方法</a></p>
<p>Mutex变量是非0即1的，可看作一种资源的可用数量，初始化时Mutex是1，表示有一个可用资源，加锁时获得该资源，将Mutex减到0，表示不再有可用资源，解锁时释放该资源，将Mutex重新加到1，表示又有了一个可用资源。</p>
<h2 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h2><p><strong>信号量</strong>（Semaphore）和Mutex类似，表示可用资源的数量，和Mutex不同的是这个数量可以大于1。如果使用 POSIX semaphore库，需要包含 <code>#include &lt;semaphore.h&gt;</code>，这种信号量不仅可用于同一进程的线程间同步，也可用于不同进程间的同步。</p>
<blockquote>
<p>使用Posix信号量可模拟互斥量和条件变量，而且通常更有优势。<a href="http://www.cnblogs.com/clover-toeic/p/4029269.html">引用来源</a></p>
</blockquote>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><p>接下来说说 C++11 中用并发怎么写生产者消费者问题。</p>
<p>参考来源：<a href="http://www.cnblogs.com/haippy/p/3252092.html">C++11 并发指南九</a>，正确与否暂且不论。作者可真够啰嗦的，又不是写论文，凑啥篇幅。推荐作者系列文章：<a href="http://www.cnblogs.com/haippy/p/3284540.html">C++11 并发指南系列</a></p>
<p>使用“c++ 生产者消费者”作为关键字 google，其结果前 2 页含有有效代码的网页中，基本以数组（做环形队列）做有限缓冲，有两个例子使用了 STL 的 vector，一个例子使用 queue</p>
<ol>
<li>使用 vector <a href="http://www.voidcn.com/blog/nyist327/article/p-5038823.html">例子一</a></li>
<li>使用 vector <a href="http://my.oschina.net/myspaceNUAA/blog/61239">例子二</a>，代码比较糟糕，不支持多生产者（或多消费者）</li>
<li>使用 queue <a href="http://www.lai18.com/content/5955636.html">例子</a></li>
</ol>
<p>具体业务场景具体分析，但更具通用性（同时适用于多生产者或多消费者的情况）的上锁方式，是将“获取缓冲区大小，进出缓冲区”都作为临界区，严格上锁。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>打包和压缩</title>
    <url>/2016/12/14/tar/</url>
    <content><![CDATA[<p> 其实很简单的：甭管是打包还是压缩，参数一般以 vf 结尾，后跟包名称；打包的情况就是从 c（打包） x（解包） t（查看） 中挑一个；有压缩的话再从 z（gzip） j（bzip2） 中挑一个。Ok， 打完收工。</p>
<ol>
<li>如果打包的文件很多很多，造成刷屏，就需要把 v 参数去掉；</li>
<li>包中追加（r）、更新（u）内容，使用率一般不是很高；</li>
</ol>
<hr>
<a id="more"></a>

<p>打包和压缩是两个概念。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>为什么要区分这两个概念呢？这源于 Linux 中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<p>linux下最常用的打包程序就是 tar 了，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩。</p>
<h1 id="打包命令-tar"><a href="#打包命令-tar" class="headerlink" title="打包命令 tar"></a>打包命令 tar</h1><p>首先就来讲讲 tar 命令的基本用法： </p>
<p>tar 命令的选项有很多(用 <code>man tar</code> 可以查看到)，但常用的就那么几个选项，下面来举例说明一下： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cf all.tar *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 </span></span><br><span class="line">tar -rf all.tar *.gif </span><br><span class="line"><span class="comment"># 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 </span></span><br><span class="line">tar -uf all.tar logo.gif </span><br><span class="line"><span class="comment"># 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 </span></span><br><span class="line">tar -tf all.tar </span><br><span class="line"><span class="comment"># 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 </span></span><br><span class="line">tar -xf all.tar </span><br><span class="line"><span class="comment"># 这条命令是解出all.tar包中所有文件，-x是解开的意思 </span></span><br></pre></td></tr></table></figure>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>语法：tar [主选项+辅选项] 文件或者目录</p>
<p>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p>
<p>主选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c: 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。</span><br><span class="line">-x：从档案文件中释放文件。相当于拆包。</span><br><span class="line">-t：列出档案文件的内容，查看已经备份了哪些文件。</span><br><span class="line">-r：向归档文件末尾追加文件</span><br><span class="line">-u：更新原打包文件中的文件</span><br></pre></td></tr></table></figure>
<p>这五个是独立的命令，打包拆包都要用到其中一个，可以和别的命令连用但只能用其中一个。</p>
<p>辅助选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v ：打包&#x2F;拆包的过程中显示文件，这个常用</span><br><span class="line">-f ：使用档名名字，请注意，在 f 之后要立即接档案名，不要再加其他参数</span><br><span class="line">-p ：使用原文件的原来属性（属性不会依据使用者而变）</span><br><span class="line">--exclude FILE：在压缩的过程中，不要将 FILE 打包</span><br><span class="line">-z ：</span><br><span class="line">-j ：</span><br><span class="line">-Z ：</span><br></pre></td></tr></table></figure>
<p>参数 <code>-f</code> 是必须的！</p>
<p>为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p>
<h1 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h1><p>有很多个……</p>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用 <code>-z</code> 这个参数来调用 gzip。下面来举例说明一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -czf all.tar.gz *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个 gzip压缩过的包，包名为all.tar.gz </span></span><br><span class="line">tar -xzf all.tar.gz </span><br><span class="line"><span class="comment"># 这条命令是将上面产生的包解开。</span></span><br></pre></td></tr></table></figure>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip2。tar 中使用 <code>-j</code> 这个参数来调用 gzip。下面来举例说明一下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cjf all.tar.bz2 *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个 bzip2压缩过的包，包名为all.tar.bz2 </span></span><br><span class="line">tar -xjf all.tar.bz2 </span><br><span class="line"><span class="comment"># 这条命令是将上面产生的包解开。</span></span><br></pre></td></tr></table></figure>
<h2 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h2><p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 compress 压缩的结果。与 compress 相对的解压程序是 uncompress 。tar 中使用 <code>-Z</code> 这个参数来调用 compress。下面来举例说明一下： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cZf all.tar.Z *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z </span></span><br><span class="line">tar -xZf all.tar.Z </span><br><span class="line"><span class="comment"># 这条命令是将上面产生的包解开</span></span><br></pre></td></tr></table></figure>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-z：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz</span><br><span class="line">-j：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2</span><br><span class="line">-Z：有compress属性的</span><br></pre></td></tr></table></figure>
<h1 id="拆包-解压缩"><a href="#拆包-解压缩" class="headerlink" title="拆包/解压缩"></a>拆包/解压缩</h1><p>下面对于 拆包/解压缩 做一个小结：</p>
<ul>
<li><p>对于 .tar 结尾的文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure></li>
<li><p>对于 .gz 结尾的文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure></li>
<li><p>对于 .tgz 或 .tar.gz 结尾的文件 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzf all.tar.gz </span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure></li>
<li><p>对于 .bz2 结尾的文件 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 -d all.bz2 </span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure></li>
<li><p>对于 tar.bz2 结尾的文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure></li>
<li><p>对于 .Z 结尾的文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure></li>
<li><p>对于 .tar.Z 结尾的文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>
<h1 id="特殊范例"><a href="#特殊范例" class="headerlink" title="特殊范例"></a>特殊范例</h1></li>
</ul>
<p>此章节中不在严格区分打包/压缩，拆包/解压 字面，不再咬文嚼字。</p>
<ol>
<li>将某一目录下的压缩文件解压到另一目录；将某一目录下的打包文件解包到另一目录；</li>
<li>只解压压缩包中的个别文件，而非全部；</li>
<li>要压缩某一目录，但个别文件除外；</li>
<li>改变工作目录，神奇的 C 参数（大写，不是 c）；</li>
</ol>
<p>以上情况，因为在实际使用中涉及过少，不在此详述。参考 <a href="http://www.cnblogs.com/li-hao/archive/2011/10/03/2198480.html">linux下使用tar命令</a> 范例三、四、五 及其后续</p>
<h1 id="Windows-下的压缩文件"><a href="#Windows-下的压缩文件" class="headerlink" title="Windows 下的压缩文件"></a>Windows 下的压缩文件</h1><p>对于Window下的常见压缩文件 .zip 和 .rar，Linux 也有相应的方法来解压它们： </p>
<h2 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h2><p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zip all.zip *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件压缩成一个zip包 </span></span><br><span class="line">unzip all.zip </span><br><span class="line"><span class="comment"># 这条命令是将all.zip中的所有文件解压出来 </span></span><br></pre></td></tr></table></figure>
<h2 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h2><p>要在 linux 下处理 .rar 文件，需要安装 <a href="http://www.rarlab.com/download.htm">RAR for Linux</a>，RAR for Linux 不是免费的；</p>
<p>下载之后解压直接 make 就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rar a all *.jpg </span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar扩展名将自动附加到包名后。 </span></span><br><span class="line">unrar e all.rar </span><br><span class="line"><span class="comment"># 这条命令是将all.rar中的所有文件解压出来</span></span><br></pre></td></tr></table></figure>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到此为至，我们已经介绍过 linux 下的 tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar 等程式，你应该已经能够使用它们对 .tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar 这10种压缩文件进行解压了，以后应该不需要为下载了一个软件而不知道如何在 Linux 下解开而烦恼了。而且以上方法对于 Unix 也基本有效。</p>
<p>以上主要参考自：</p>
<ul>
<li><p><a href="http://www.jb51.net/LINUXjishu/43356.html">linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结</a></p>
<p>  前半部分介绍思路清晰，奉行“拿来主义”只对排版略作调整。后部分所谓“以下补充”太过滥竽充数，估计这篇文章不是原帖。</p>
</li>
<li><p>The End</p>
</li>
</ul>
<p>其实很简单的：甭管是打包还是压缩，参数一般以 vf 结尾，后跟包名称；打包的情况就是从 c（打包） x（解包） t（查看） 中挑一个；有压缩的话再从 z（gzip） j（bzip2） 中挑一个。Ok， 打完收工。</p>
<ol>
<li>如果打包的文件很多很多，造成刷屏，就需要把 v 参数去掉；</li>
<li>包中追加（r）、更新（u）内容，使用率一般不是很高；</li>
</ol>
<p>想要更详细的，哥哥啊，你干嘛不 <code>man tar</code> 呢。就一个命令，从网上查查常用法、惯用伎俩，要想再多懂一些就别再网上折腾了，浪费时间啊，老老实实 man ，最不济 –help 也行啊</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>为知笔记目录安排</title>
    <url>/2017/04/18/tools/</url>
    <content><![CDATA[<h1 id="位置笔记中第一篇"><a href="#位置笔记中第一篇" class="headerlink" title="位置笔记中第一篇"></a>位置笔记中第一篇</h1><p>2016/3/17 17:34:04</p>
<p><strong>Wiz只写开发。</strong></p>
<p>备注1：个别目录下还有“子章节”，其中存放的都是在主目录笔记中附有链接，作为子章节存在的内容。     </p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/tools/wiz.jpg" alt="来源：笔记目录.mmap"></p>
<p>附件：<a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/tools/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95.mmap">笔记目录.mmap</a></p>
<a id="more"></a>

<h1 id="tools-标签下第一篇"><a href="#tools-标签下第一篇" class="headerlink" title="tools 标签下第一篇"></a>tools 标签下第一篇</h1><p>2016年1月5日 14:34:16</p>
<p>这个当然不是该目录下的第一篇笔记，嘻嘻</p>
<p>此目录主要是和工具有关的笔记，重点在于使用工具的经验、教训和心得，是自己实实在在尝试过、折腾过的（比如 <a href="/2017/03/27/VersionControl/">版本控制</a> 这篇单纯罗列的帖子就不应该在此目录下，而应该整理到思维导图中）。<br>另，百度网盘 <a href="mailto:&#x6e;&#x69;&#101;&#108;&#x6f;&#110;&#103;&#x32;&#x30;&#x31;&#52;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;">&#x6e;&#x69;&#101;&#108;&#x6f;&#110;&#103;&#x32;&#x30;&#x31;&#52;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;</a> 中，上传了部分软件工具。</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/tools/f5cf1fe2-a2b3-45de-95f3-b741994ce323.png" alt="来源：工具（2016-01-05）.mmap"></p>
<p>附件：<a href="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/tools/%E5%B7%A5%E5%85%B7%EF%BC%882016-01-05%EF%BC%89.mmap">工具（2016-01-05）.mmap</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>读一读</title>
    <url>/2017/04/19/toread/</url>
    <content><![CDATA[<p>在为知笔记里有一个文件夹《读一读》，是<strong>觉得</strong>有意思应该看一看的博客，可是一放少则几个月，多则一两年过去了。有点类似于 chrome 中的僵尸书签，觉得有用做了标记，可是一直扔在那里占着地方却再也没有翻起。</p>
<p>还有个类似的行为，买书、囤书却不读书。哈哈哈，为什么呢？怎么解决这种行为，这种现象呢？互联网时代在网络上优质资源混杂在垃圾信息里，怎么筛选出有价值的内容？进入新世纪后，出书也变得简单，不再有门槛限制，也是出来了各种各样的垃圾，怎么挑选？</p>
<a id="more"></a>

<p>2016年1月4日 17:05:27</p>
<h1 id="面对糟糕的旧代码，Keep-Calm-amp-Carry-On"><a href="#面对糟糕的旧代码，Keep-Calm-amp-Carry-On" class="headerlink" title="面对糟糕的旧代码，Keep Calm &amp; Carry On!"></a>面对糟糕的旧代码，Keep Calm &amp; Carry On!</h1><p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/toread/be936d64-f90a-4cae-a3d2-70d8b86e09da.jpg" alt="漫画：读别人代码是一种怎样的体验?"></p>
<p>我们很不愿意读别人的代码，我们也不愿意读自己以前写过的代码（时间越久越痛苦）。事实就是读代码更难。</p>
<p>但是，推到重来可能会带来更大的风险，因为旧代码是经过反复测试，甚至上线运行过的。</p>
<p>读代码，觉得眼前的旧代码很烂时，应该怎么办？</p>
<p>你觉得旧代码写的很烂，那又怎样呢?它们已经上线，已经在实际运行中经受住了考验。所以当你发现前任留下的代码乱七八糟的时候，不妨冷静下来，从以下三个方面入手理解代码、改善代码： </p>
<ol>
<li><p>代码的结构有问题 </p>
<p> 如果一段网络代码突然弹出了自己的对话框，应该是UI代码需要被处理。这些问题可以被解决掉，你要一次次小心地移动代码，重构，改变接口。还需要一位细心的工程师立马仔细地检查这些改变是否有问题，从而不打扰到其他人。事实上，甚至比较大的结构变化也可以不扔掉代码来完成。 </p>
<p> 大牛程序员 Joel Spolsky 回忆说，曾经在某个项目中，他和他的团队花了好几个月重新架构在一点上：把代码动来动去、清理、创建有意义的基类，并创建了模块之间的完美接口。但是他们始终非常小心翼翼，并没有产生新的 bug，也没有丢掉任何旧代码。 </p>
</li>
<li><p>代码的效率不高——只需要改动局部 </p>
<p> 曾经，Netscape 的渲染代码被传非常缓慢。但事实上，这只会影响该项目的一小部分，这部分是你可以优化甚至重写的。你完全不必重写全部代码。优化速度的 1% 工作量，会让你获得 99% 的爆炸性提高。 </p>
</li>
<li><p><strong>代码写得很丑——参考某个编程规范，比如 Google 的</strong></p>
<p> 有些代码真的写的很丑，比如 Joel 曾参与一个项目，开始用下划线做开始的成员变量约定，但后来改用更标准的 <code>M_</code>。所以一半的功能用 <code>_</code> 开始，一半用 <code>M</code> 开始，这看起来真的很丑陋。但这个问题 5 分钟就能解决，而不用从头开始写全部的代码。 </p>
</li>
</ol>
<p>最后，你要记住，从头开始再写一遍并不意味着你会写出比以前更好的代码。因为你没有参与到上一个版本的创建，所以你其实根本就不算有经验。一旦你准备推倒重写，你可能会再犯一遍版本一犯过的错，甚至会产生更多的新问题。</p>
<p>以上内容摘自：<a href="http://news.duote.com/30/89540.html">程序员为什么不爱看别人的代码</a></p>
<h1 id="网址清单"><a href="#网址清单" class="headerlink" title="网址清单"></a>网址清单</h1><ul>
<li><a href="http://bbs.csdn.net/topics/390977004">4年半操蛋的IT路&amp;&amp;严重的危机感–请给点建议或者思路-CSDN论坛-CSDN.NET-中国最大的IT技术社区</a></li>
<li><a href="http://blog.csdn.net/leezy_2000/article/details/29407747">程序员生存定律–目录 - 理想流 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.douban.com/doulist/3704423/">豆瓣推荐书单</a></li>
<li><a href="http://blog.csdn.net/foruok/article/details/39998921">漫谈程序员系列：受刺激啦，开篇啦 - 在软件开发的漫漫长路上且行且吟 - 博客频道 - CSDN.NET</a></li>
<li><a href="http://www.vaikan.com/what-is-the-single-most-influential-book-every-programmer-should-read/">哪本书是对程序员最有影响、每个程序员都该阅读的书？ | 外刊IT评论</a></li>
<li><a href="http://www.cnblogs.com/west-link/category/303903.html">提高效率的方法 - 随笔分类 - West_Link - 博客园</a></li>
<li><a href="http://wwww.huxiu.com/article/39799/1.html">一个7年老员工的离职总结：如何打造一个最强大的“自我”-观点-虎嗅网</a></li>
<li><a href="http://blog.csdn.net/csh624366188/article/details/40712317">作为学生，我是怎么半年赚到人生第一个三十万的 - 曹胜欢 - 博客频道 - CSDN.NET</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 去除空格</title>
    <url>/2016/11/03/trimSpace/</url>
    <content><![CDATA[<p>在 C++ 中怎么去除字符串首尾的空格？怎么去掉字符串中所有的空格？</p>
<p>网上可以查到很多，有用 C 写的，有用纯 C++ 写的，混合的更是大有人在。功能都能实现，但哪个是最佳实践的？有以下几个标准 or 问题？</p>
<ul>
<li>代码足够简洁</li>
<li>怎么保证效率？</li>
<li>通用性：跨平台</li>
<li>要不要考虑 C 调用问题？</li>
</ul>
<a id="more"></a>

<h1 id="一、trim"><a href="#一、trim" class="headerlink" title="一、trim"></a>一、trim</h1><p>去除首尾空格，示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;   niel loves liyw   !  &quot;</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  str.erase(<span class="number">0</span>, str.find_first_not_of(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lef: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  str.erase(str.find_last_not_of(<span class="string">&quot; &quot;</span>)+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rig: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 string 的 <code>find_first_not_of()</code> 和 <code>find_last_not_of()</code> 函数找到字符串第一个非空字符和最后一个非空字符的位置，然后进行 <code>erase()</code> 操作。</p>
<h1 id="二、trim-all"><a href="#二、trim-all" class="headerlink" title="二、trim_all"></a>二、trim_all</h1><p>在进入主题之前，先来学习两个函数：<a href="http://en.cppreference.com/w/cpp/algorithm/remove"><code>remove()</code></a> 和 <code>remove_if()</code>。</p>
<p>注意这两个函数的“移除”并不完美，他们并不改变容器的大小。一般结合 <code>erase()</code> 同时使用。</p>
<blockquote>
<p>Return value<br>Past-the-end iterator for the new range of values (if this is not end, then it points to an unspecified value, and so do iterators to any values between this iterator and end)</p>
</blockquote>
<p>调用 <code>remove()</code> 或 <code>remove_if()</code> 函数会返回<em>移除目标成员之后的区间</em>的尾后迭代器。此迭代器及其后面的元素（如果有的话，一直到原区间的末尾）是<strong>不确定的</strong>。而这些不确定元素就是我们需要调用 <code>erase()</code> 清理的。看一段代码来理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// remove</span></span><br><span class="line">  <span class="built_in">string</span> str = <span class="string">&quot;nielonglovesliyawei&quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;origin str: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">auto</span> itor = remove(str.begin(), str.end(), <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after  rem: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str.erase(itor, str.end());</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after  era: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下，可以看到移除所有的字符 <code>&#39;e&#39;</code> 之后字符串长度并没有变。删除了3个，就把原字符串末尾的3个字符重复打印了一次（需要强调的是，此行为在其他编译器上不一定会复现，因为 c++ 标准里并未定义）。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/trim_test$ make test CXXFLAGS=-std=c++11 &amp;&amp; ./test </span><br><span class="line">g++ -std=c++11    test.cpp   -o test</span><br><span class="line">origin str: |nielonglovesliyawei|</span><br><span class="line">after  rem: |nilonglovsliyawiwei|</span><br><span class="line">after  era: |nilonglovsliyawi|</span><br><span class="line">vimer@debian8light:~/see-the-world/code/trim_test$ </span><br></pre></td></tr></table></figure>
<p>进入正题。我们来看去除所有空白字符的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;   niel loves liyw   !  &quot;</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// trim all spaces: remove_if</span></span><br><span class="line">  <span class="keyword">auto</span> itor = remove_if(str.begin(), str.end(), ::<span class="built_in">isspace</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  str.erase(itor, str.end());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: |&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/trim_test$ make test CXXFLAGS=-std=c++11 &amp;&amp; ./test </span><br><span class="line">g++ -std=c++11    test.cpp   -o test</span><br><span class="line">str: |   niel loves liyw   !  |</span><br><span class="line">str: |niellovesliyw!liyw   !  |</span><br><span class="line">str: |niellovesliyw!|</span><br><span class="line">vimer@debian8light:~/see-the-world/code/trim_test$ </span><br></pre></td></tr></table></figure>
<h2 id="isspace"><a href="#isspace" class="headerlink" title="::isspace"></a><code>::isspace</code></h2><p>需要强调的是代码中 <code>::isspace</code> 的作用域前缀，如果使用 <code>isspace</code> （因为全局 <code>using namespace std;</code>，所以同 <code>std::isspace</code>）就会报错。</p>
<p>删除 <code>using namespace std;</code>，使用 <code>isspace</code> 也是正确的。意义等同 <code>::isspace</code>。</p>
<blockquote>
<p><code>::isspace</code> means you’re explicitly calling the global method <code>isspace</code>. The C Standard Library methods are all globals, and <code>&lt;ctype.h&gt;</code> is a C Standard Library header.</p>
<p>Namespaces don’t exist in C, so when using the C library headers, you don’t use the std namespace. The C++ counterpart to <code>&lt;ctype.h&gt;</code> which uses the std namespace is <code>&lt;cctype&gt;</code>. <a href="http://stackoverflow.com/questions/29042224/remove-ifstr-begin-str-end-isspace-what-does-the-isspace-means">引用来源</a></p>
</blockquote>
<p>而 </p>
<blockquote>
<p><code>std::isspace</code> is an overloaded function in C++, with a template function declared in <code>&lt;locale&gt;</code>.</p>
</blockquote>
<p>前者没有重载版本；而后者有（一份是 <code>&lt;cctype&gt;</code> 中从 <code>&lt;ctype.h&gt;</code> 拷贝过来加上 <code>std::</code> 作用域的；一份是 <code>&lt;locale&gt;</code> 中的模板函数），参见 <a href="http://www.cplusplus.com/reference/cctype/isspace/">isspace-cctype</a> 和 <a href="http://www.cplusplus.com/reference/locale/isspace/">isspace-locale</a>。所以如果使用后者（单独使用函数名，没有参数）就存在指代不明的问题。</p>
<p>为什么明确引入 <code>&lt;cctype&gt;</code> 还是报错，还是存在指代不明的问题呢？另外，示例中未明确引用 <code>&lt;ctype.h&gt;</code> 却未报错是因为什么原因呢？</p>
<blockquote>
<p>Implementations are allowed to silently include additional headers you didn’t ask for, and many do so. They do so because they internally make use of those additional headers. <a href="http://stackoverflow.com/questions/29042224/remove-ifstr-begin-str-end-isspace-what-does-the-isspace-means">引用来源</a></p>
</blockquote>
<p>如果坚持使用后者需要 <a href="http://stackoverflow.com/questions/21578544/stdremove-if-and-stdisspace-compile-time-error">解决指代不明的问题 - 使用 lambda</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::remove_if(str.begin(), str.end(), </span><br><span class="line">               [](<span class="keyword">char</span> c)&#123; </span><br><span class="line">                  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c));</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure>
<p>还有几个通过类型转换来解决后者指代不明问题的例子（但和上述的解决方案相比，终非正途）：</p>
<ol>
<li><a href="">http://stackoverflow.com/questions/18589525/removing-all-spaces-from-a-string</a></li>
<li><a href="">http://stackoverflow.com/questions/4537930/removing-a-character-from-a-string</a></li>
<li><a href="">http://stackoverflow.com/questions/8364678/g-string-remove-if-error</a></li>
</ol>
<p>好吧，我承认，主要是太丑陋了。丑得我都没有仔细看的想法。</p>
<p>总的来说 <code>isspace</code> <code>::isspace</code> <code>std::isspace</code> 的问题：</p>
<blockquote>
<p>isspace is defined both in the global namespace and in namespace std, so when you have using namespace std, and you write isspace, there’s an ambiguity. To be specific, there’s one overload in <cctype> and another defined in <locale>.</p>
<p>Just write ::isspace and you’re good to go.</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Unicode 字符集，慎用中文</title>
    <url>/2017/03/21/unicodeInWindows/</url>
    <content><![CDATA[<p>2015年10月29日 17:54:48</p>
<h1 id="问题一：输出异常"><a href="#问题一：输出异常" class="headerlink" title="问题一：输出异常"></a>问题一：输出异常</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _tmain()&#123;</span><br><span class="line">	TCHAR *ch=_T(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">	_tprintf(_T(<span class="string">&quot;%s\n&quot;</span>),ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在以下 2 种字符集都可以正常输出，显示。</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/chooseUnicode.png" alt="使用 Unicode 字符集"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _tmain()&#123;</span><br><span class="line">	TCHAR *ch=_T(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">	_tprintf(_T(<span class="string">&quot;%s\n&quot;</span>),ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在多字节字符集下可以正常显示，而在 Unicode 字符集下显示异常</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/canntPrintNormally.png" alt="输出异常"></p>
<p>结论一：windows 本身自带的 <strong>cmd 工具不能输出 unicode 编码的中文内容。</strong></p>
<h1 id="问题二：更多的限制"><a href="#问题二：更多的限制" class="headerlink" title="问题二：更多的限制"></a>问题二：更多的限制</h1><p><strong>UNICODE 字符集下 CStdioFile 的 Writestring 无法写入中文。</strong></p>
<p>提供三种解决思路：</p>
<ul>
<li>宽字节转换为多字节编码。不推荐</li>
<li>使用setlocale语句设定区域。 参考：<a href="http://blog.csdn.net/ljz888666555/article/details/5511247">CStdioFile的Writestring无法写入中文的问题</a></li>
<li>以二进制形式写入，同时指定文件编码类型。参考： <a href="http://bbs.csdn.net/topics/370037016">CStdioFile以Unicode编码方式写入字符串的文题</a>、<a href="http://www.cppblog.com/greatws/archive/2008/08/31/60546.html">Ansi、Unicode、UTF8字符串之间的转换和写入文本文件</a></li>
</ul>
<p>使用CFile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteToLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CString cstr = _T(<span class="string">&quot;在unicode编码下使用CFile()写入中文需要在文件头部写入开头字节FFFE。\n&quot;</span>);</span><br><span class="line">	CString logPath = _T(<span class="string">&quot;c:\\_logTest.txt&quot;</span>);</span><br><span class="line">	CFile logFile;</span><br><span class="line">	<span class="keyword">if</span>(!logFile.Open( logPath ,CFile::modeCreate | CFile::modeWrite | CFile::modeNoTruncate))</span><br><span class="line">	&#123;</span><br><span class="line">		AfxMessageBox(_T(<span class="string">&quot;运行日志文件打开失败&quot;</span>),MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	logFile.Write(<span class="string">&quot;\xff\xfe&quot;</span>, <span class="number">2</span>);							<span class="comment">//开头字节 Charset/encoding </span></span><br><span class="line">	logFile.SeekToEnd();</span><br><span class="line">	logFile.Write(cstr, _tcsclen(cstr) * <span class="keyword">sizeof</span>(TCHAR));	<span class="comment">//注意第2个参数</span></span><br><span class="line">	logFile.Close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CStdioFile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteToLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CString cstr = _T(<span class="string">&quot;在unicode编码下使用CStdioFile()写入中文需要设置二元模式(CFile::typeBinary)。……\n&quot;</span>);</span><br><span class="line">	CString logPath = _T(<span class="string">&quot;c:\\_logTest.txt&quot;</span>);</span><br><span class="line">	CStdioFile logFile;</span><br><span class="line">	<span class="keyword">if</span>(!logFile.Open( logPath ,CFile::modeCreate | CFile::modeWrite | CFile::modeNoTruncate | CFile::typeBinary))</span><br><span class="line">	&#123;</span><br><span class="line">		AfxMessageBox(_T(<span class="string">&quot;运行日志文件打开失败&quot;</span>),MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	logFile.Write(<span class="string">&quot;\xff\xfe&quot;</span>, <span class="number">2</span>);							<span class="comment">//开头字节 Charset/encoding </span></span><br><span class="line">	logFile.SeekToEnd();</span><br><span class="line">	logFile.Write(cstr, _tcsclen(cstr) * <span class="keyword">sizeof</span>(TCHAR));	<span class="comment">//注意第2个参数</span></span><br><span class="line">	logFile.Close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在百度百科中，CFile 词条提到“CFile 是 MFC 文件类的基类，它直接提供非缓冲的<strong>二进制</strong>磁盘输入/输出设备，并直接地通过派生类支持文本文件和内存文件。”CStdioFile 词条提到“流式文件是被缓冲的，而且可以以<strong>文本方式（缺省）</strong>或二进制方式打开。”</p>
<p>因此，使用 CStdioFile 需明确指定二元模式。</p>
<p>ps：因为指定了文件的编码类型，所以以上两段代码在多字节字符集下会有问题，虽然可以正常运行，但是写入文件的内容为乱码。</p>
<p>另，在 msdn 中明确指出 typeUnicode 模式，可是在 VS2010 调试中提示无此模式：</p>
<p><img src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/CFile-typeUnicode.png" alt="模式"></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Debian</title>
    <url>/2017/03/10/usesDebian8/</url>
    <content><![CDATA[<p>最初是在 x240（个人笔记本，便携、屏幕小）上安装的双系统，因为某些原因一直未能进行实际、有效的练习。曾经考虑是否将其卸载，恢复为原始 windows 系统，使用 windows 的 boot manager。毕竟使用双系统开机启动略有不便，按电源键到进入系统也会慢很多。但后来放弃了，就这样子将就着吧，一方面恢复单系统需要重新花费时间精力，另一方面 x240 上我没有安装虚拟机，有个 Debian 多一个选择。</p>
<p>后来，在 E431（公司笔记本）安装虚拟机，在虚拟机中安装 Debian8.1，使用的是官方社区下载的 ISO 镜像。在默认安装中文语言、图形界面之后，因为习惯使用 xshell 进行操作，所以其图形界面对我来说意义不大，在虚拟机中也很吃资源，一直想关之；从网上搜索，自己折腾，最终还是没有找到理想的解决方法，所以又在虚拟机中重新安装了一个，命名 Debian8Light，安装时没有选择图形界面。后来在 Debian 上的一些测试一直使用后者，前者在我刚刚接触 Debian 使用图形界面安装应用时起到了一定价值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sys:</span><br><span class="line">root&#x2F;Debian.lyw</span><br><span class="line">niel&#x2F;nie123</span><br><span class="line">vimer&#x2F;vimer</span><br></pre></td></tr></table></figure>
<p>最近，在 Bandwagon 中重装了 Debian8，估计是最小化安装，所以没有图形界面，系统环境也是英文的。硬件限制，甚至不如在虚拟机上的配置。不过最满意在这台 vps 上折腾了，毕竟它不会直接对我的系统造成影响，崩溃了重装（一键操作，官网也提供备份镜像）就是，而且只要有网它就一直是在线的，另一种意义上的便携。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>了解 Linux 的启动流程，对于理解运行级别、配置文件、shell 类别有很重要的指导意义。阮一峰的博客很不错：<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">Linux 的启动流程</a>，作者也是以 Debian 来介绍的。</p>
<p>觉得好牛逼，可是到自己 Debian8.1 系统上一看，擦嘞，咋没有 <code>/etc/inittab</code> 文件呀，然后就凌乱了……同时，参考<a href="http://blog.csdn.net/yapingxin/article/details/6247760">安装Debian 6.0之后首先做的几件事</a> 中使用 <code>sysv-rc-conf</code> 命令（需要先安装）使系统默认从命令行启动，操作后无效；参考 <a href="http://www.xitongzhijia.net/xtjc/20150112/34540.html">Debian开机不进入图形界面的方法</a> 想达到上述目的，也无法操作……</p>
<p>然后就了解到了 <a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html">Linux初始化系统（init）</a>，知道了：</p>
<blockquote>
<p>传统的 sysvinit 已经淡出历史舞台，新的 init 系统 UpStart 和 systemd 各有特点，而越来越多的 Linux 发行版采纳了 systemd。</p>
<p>不同的 Linux 发行版在这些 sysvinit 的基本工具基础上又开发了一些辅助工具用来简化 init 系统的管理工作。比如 RedHat 的 RHEL 在 sysvinit 的基础上开发了 initscripts 软件包，包含了大量的启动脚本 (如 rc.sysinit) ，还提供了 service，chkconfig 等命令行工具，甚至一套图形化界面来管理 init 系统。其他的 Linux 发行版也有各自的 initscript 或其他名字的 init 软件包来简化 sysvinit 的管理。</p>
</blockquote>
<p>通过查看Debian8.1系统进程，PID为1的也的确是systemd进程。知道了存在systemd 这么个东东，那就好办啦，去网上搜呗。还是阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程：命令篇</a>，<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target </span><br></pre></td></tr></table></figure>
<p>so，在 systemd 作为初始化系统的版本中，以 sysvinit 为基础的 <code>ckconfig</code>、<code>sysv-rc-conf</code> 等命令很可能就没有意义。（有些命令如 <code>init 运行等级</code> 是兼容的）</p>
<h1 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h1><ol>
<li><p>安装 Debian 之后：</p>
<ul>
<li>Debian 默认是不允许 root 用户登录图形界面的，所以不要认为自己用 root 登录输错了密码而频繁尝试；</li>
<li>墙内访问不了官方源，可以使用 apt-spy 寻找最快源；</li>
<li>切换图形界面和命令行；<strong>使系统直接从命令行启动</strong>；</li>
</ul>
</li>
</ol>
<p>安装应用，在  wiz 中《Linux 安装应用》写的很详细。直接参考就是。</p>
<p>在这里介绍一下，<a href="http://my.oschina.net/u/1382972/blog/335983?fromerr=35ynwUcm">关于debian发布周期和各库的作用</a></p>
<h1 id="图像界面和运行级别"><a href="#图像界面和运行级别" class="headerlink" title="图像界面和运行级别"></a>图像界面和运行级别</h1><p>在虚拟机上使用的经历，我迫切地想在某一次的登录中关掉图形界面服务，需要时再重新打开。当初认为在网上没有找到理想的解决方案，现在反思发现这其实是一件小事，也很容易达到目的。——类似<code>init0</code> 关机、<code>init6</code> 重启，**<code>init3</code> / <code>init5</code>切换运行级别**。</p>
<p>以下几个链接是在当初想关图形界面时保存下来的：（如果系统使用的还是最早的 sysvinit 的 init 系统，可以参考；如果是 upstart 或者 systemd，其参考价值有限。毕竟运行级别是 sysyvinit 中的概念。）</p>
<ol>
<li><a href="http://dagai.net/archives/569">Debian的运行级别</a>，结合下一条理解Debian体系和RedHat体系在运行级别上的差异</li>
<li><a href="http://www.i-so.org/debian-based-runlevel-andx.html">关于DEBIAN、UBUNTU运行级别和图形界面</a></li>
</ol>
<p><strong>在 systemd 的世界里不要再讲运行级别了！</strong>所以，关于运行级别知道就可以了，需要深入了解的是 systemd。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>身处这个更新换代迅速的互联网时代，真是眼花缭乱啊。刚刚了解 sysvinit，可它基本上快被 systemd 淘汰掉了。</p>
<blockquote>
<p>就好像在看我们这个世界，一代人老去，新的一代带着横扫一切的气概登上舞台，还没有喊出他们最有力的口号，更猛的一代已经把聚光灯和所有的目光带走</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网</title>
    <url>/2020/12/25/v2ray/</url>
    <content><![CDATA[<p>最近两会，科学上网又宕机了。打算专心学习一下 v2ray 的插件和配置，此笔记用于备忘操作过程中的细节。也涉及 linux 系统的基础操作。</p>
<ul>
<li>动态端口</li>
<li>websocket + tls</li>
</ul>
<p>为了安全（和方便），提出以下要求或目标：禁用账号密码登录，全部改用密钥。 <a href="https://tnie.github.io/2020/12/25/vps_first/">建立 vps 后的第一步</a></p>
<a id="more"></a>

<h1 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h1><p>在 shell 中修改 config.json 是不够友好的，推荐通过在线或离线的 json 工具编辑之后整体拷贝。</p>
<p>使用 v2ray 本质是学习如何配置其 config.json，配置的核心在于其路由模块分流和传输配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检测配置文件合法性</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/v2ray/v2ray -<span class="built_in">test</span> -config ./config.json</span></span><br></pre></td></tr></table></figure>
<p>如果没有配置路由（或没有匹配的规则时），会以 outbounds 中的第一个出口作为默认的出口。</p>
<p>路由规则中 domain 和 ip 格式约定：<a href="https://www.v2ray.com/chapter_02/03_routing.html">路由功能</a></p>
<p>在 V2Ray 中，星号 * 不具备通配符的意义，如果想要匹配所有子域名，正确的格式是： <code>domain:jd.com</code>，而非 <code>*.jd.com</code>。</p>
<blockquote>
<p><code>domain:</code> 代表子域名</p>
</blockquote>
<p>服务端部署，推荐 <a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC]">一键安装脚本</a><br>Mux 多路复用，只需在客户端开启，服务器会自动识别，所以只给客户端的配置。</p>
<h2 id="伪装和混淆"><a href="#伪装和混淆" class="headerlink" title="伪装和混淆"></a>伪装和混淆</h2><p>保持低调</p>
<p>v2ray 可以自行选择传输层的形式。</p>
<blockquote>
<p>mKCP 使用 UDP 来模拟 TCP 连接，请确定主机上的防火墙配置正确。</p>
</blockquote>
<p>windows 下验证 tcp 端口使用 <code>telnet 127.0.0.1 80</code> 即可，但要验证 udp 端口却没有合适的命令，需要下载工具包 <a href="https://nmap.org/download.html">nmap 网站</a>，不需要 exe 安装，下载其命令行压缩包即可</p>
<p>windows 平台的 v2rayN 提到 <a href="https://github.com/2dust/v2rayNG/issues/155">放弃 kcp 了</a>。</p>
<h3 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h3><blockquote>
<p>客户端不用额外设定</p>
</blockquote>
<p>怎么确认动态端口生效？</p>
<ul>
<li><p>通过查看服务端 v2ray 占用的端口，可以验证其是否生效。</p>
</li>
<li><p>在 Windows 客户端通过 wireshark 监控流量，可以验证是否生效。</p>
<p>  v2rayN 一直没生效呀；客户端使用 Qv2ray 验证是可以的。</p>
</li>
</ul>
<p>延迟测试、连通性测试等选项，需要更换通信方式：</p>
<ul>
<li>imcp 的 ping 连通，不一定能用。意义不大</li>
<li>tcp 在改用 kcp/udp 后肯定不通</li>
<li>通过代理访问某个 url 的方式，推荐（windows 平台 v2rayN 快捷键 <code>ctrl-r</code>）</li>
</ul>
<h2 id="websocket-tls-web"><a href="#websocket-tls-web" class="headerlink" title="websocket + tls + web"></a>websocket + tls + web</h2><p>为什么需要 websocket + tls + web?</p>
<p>——我之前使用的基础配置，今天醒来所有客户端通信异常，能够 ping 成功，但端口被禁了。换了个端口使用正常，但也就说明已经被 GFW 盯上了。2020年5月21日</p>
<p>通过 namesilo 购买域名后，<del>直接使用 <a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC]">一键安装脚本</a> 选项 4 部署即可。自行调整防火墙端口</del> 不再推荐此脚本源于：</p>
<ul>
<li><p>并不能一步到位，比如，更安全的 <a href="https://toutyrater.github.io/advanced/wss_and_web.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE">只监听本地</a>；</p>
</li>
<li><p>Caddy 启动失败，无法创建证书</p>
<blockquote>
<p>failed to obtain certificate: acme: Error -&gt; One or more domains had a problem</p>
</blockquote>
</li>
</ul>
<p><a href="https://github.com/acmesh-official/acme.sh/wiki/sudo">acme.sh</a> 的源站提到：</p>
<blockquote>
<p>Remember: Using <code>sudo</code> is not recommended.</p>
</blockquote>
<p>实际操作之后，发现全程使用 root 用户是最方便的，创建普通用户 v2ray 反而束手束脚（即便授权 sudo 也意义不大）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root 安装 nginx</span></span><br><span class="line">yum install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> need write access to the web root folder</span></span><br><span class="line">chown -R v2ray /usr/share/nginx/html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 否则安装证书时没有权限</span></span><br><span class="line">chown -R v2ray /etc/v2ray/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">systemctl start nginx</span></span><br><span class="line">su - v2ray</span><br><span class="line"><span class="meta">#</span><span class="bash"> 普通用户生成证书</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> acme.sh --issue -d ilyw.xyz -w /usr/share/nginx/html -k ec-256</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装证书（2021年1月18日，单独执行此命令拷贝）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> acme.sh --installcert -d ilyw.xyz --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切回 root</span></span><br><span class="line">su - root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 否则启动 v2ray 服务时没有权限</span></span><br><span class="line">chown -R root /etc/v2ray/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>vcpkg 包管理器</title>
    <url>/2018/12/10/vcpkg/</url>
    <content><![CDATA[<p>除特别备注，全部摘自 <a href="https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017">vcpkg: A C++ package manager for Windows, Linux and MacOS</a></p>
<p><strong>强调</strong>：安装 IDE 时不要变更默认路径！否则，使用 vcpkg 磨难重重，<a href="https://github.com/microsoft/vcpkg/issues/12488">vcpkg issue#12488</a>。我安装 Language English 就失败了，后面也就没尝试。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>此章节类似读书（博客）笔记。</p>
<h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><ol>
<li><p>同时支持动态链接库，以及 <a href="https://blogs.msdn.microsoft.com/vcblog/2016/11/01/vcpkg-updates-static-linking-is-now-available/">静态链接</a>。Windows 下默认编译 32 位的动态库。</p>
<blockquote>
<p> If no triplet is specified, vcpkg will install and compile for <strong>the default triplet</strong> for the target platform: <code>x86-windows</code>, <code>x64-linux.cmake</code>, or <code>x64-osx.cmake</code>.</p>
</blockquote>
</li>
<li><p>MT 和 MD：vcpkg 静态链接库默认 <code>/MT(d)</code>；动态链接库默认 <code>/MD(d)</code></p>
<blockquote>
<p>build static libraries against the static CRT (<code>/MT</code> in Visual Studio): <code>x86-windows-static</code>, <code>x64-windows-static</code>, etc.</p>
</blockquote>
<p> <a href="https://github.com/Microsoft/vcpkg/issues/784">Change Compiler settings from MT to MD</a></p>
<blockquote>
<p>This should be as easy as copying <code>triplets\x86-windows-static.cmake</code> to a new file of your own name (<code>triplets\x86-windows-static-md.cmake</code>, for example). Then change the setting for <code>VCPKG_CRT_LINKAGE</code> to <code>dynamic</code> instead of <code>static</code>.</p>
</blockquote>
<a id="more"></a>
</li>
<li><p>不改变环境变量，不依赖注册表 <del>或 Visual Studio</del> 在 Windwos 平台还是和后者密切关联的</p>
<p> 为什么总要下载 ninja ? 不会弃用自家 Visual Studio，全面拥抱 ninja 了吧？</p>
</li>
<li><p>在 Windows 环境使用时，编译源码需要依赖 MSVC2015 或 2017，优先使用后者</p>
<p> 同时安装了 MSVC2015 和 2017 时，如何指定使用前者？<a href="https://github.com/Microsoft/vcpkg/issues/766">Using VS2015 when VS2017 is available</a>，没门！</p>
<blockquote>
<p>We don’t currently have an easy, supported way to opt out of VS2017.</p>
</blockquote>
<p> 给出的 set <code>VCPKG_PLATFORM_TOOLSET </code> 的 workaround 也有大的缺陷：</p>
<blockquote>
<p>This will work for CMake-based ports that don’t use Ninja and possibly others. Notably, this will <em>not</em> change <code>boost</code>.</p>
</blockquote>
<p> 2019-10-17 打算不管不顾 <a href="https://github.com/tnie/learn_future/blob/master/README.md#binary-compatibility">二进制兼容可能出现的例外</a>，安装时不再纠结 msvc 版本（2015/17/19），就直接安装 vc2019。在 vc2015/17 中使用出错了再说。</p>
</li>
<li><p><strong>支持导出</strong>编译后的库和头文件</p>
</li>
<li><p>vcpkg 自包含，每个 vcpkg 文件夹就是一个实例。每台设备可以有多个实例。</p>
</li>
<li><p>支持更新、升级已经安装的库</p>
<p> 和更新 vcpkg 自身是不同的概念。更新 vcpkg 自身：<code>git pull</code></p>
</li>
<li><p>支持删除已安装的库，并且级联删除其下游（依赖前者的其他库）</p>
<p> 卸载 boost <code>.\vcpkg.exe remove boost-vcpkg-helpers --recurse</code></p>
</li>
<li><p>虽然理论上可能用不到 git、cmake，但好多库都是从 github 上获取，是 cmake 组织的。<del>自己安装并配到环境变量里吧，省得每个实例都下载</del>。</p>
<p> vcpkg 针对 git、cmake 设有最低版本，如果系统中查找到版本较低，依旧会重新下载 git 和 cmake。有点坑的地方在于 vcpkg 基本都在追踪最新版本。所以，交给 vcpkg 自己操心吧。下载慢就多等会儿。</p>
</li>
</ol>
<h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><ol>
<li><p>可以集成到 Visual Studio。当存在多个实例时，最后执行 <code>vcpkg integrate install</code> 的有效</p>
<p> 所以，改变目录后，重新执行上述命令即可！</p>
</li>
<li><p>从 Visual Studio 中解除 vcpkg，执行 <code>vcpkg.exe integrate remove</code> 即可。</p>
<p> 虽然试验中，使用 <code>vcpkg integrate install/remove</code> 开关 vcpkg 能够及时生效，无需重启 MSVC。但总是心里毛毛的。</p>
<p> 之前使用过笨方法，针对每个项目 xxx.vcxproj 手工增加 <code>&lt;VcpkgEnabled&gt;false&lt;/VcpkgEnabled&gt;</code> 配置项</p>
</li>
<li><p>可以撇开主要 Vcpkg 实例，使用库的特定版本 / 将某个实例集成到特定项目中</p>
<blockquote>
<p>This will modify the project file, so we <strong>do NOT recommend</strong> this approach for open source projects.<a href="https://github.com/Microsoft/vcpkg/blob/master/docs/users/integration.md#linking-nuget-file">引用来源：linking-nuget-file</a></p>
</blockquote>
</li>
<li><p>Visual Studio 使用 Vcpkg <a href="https://blogs.msdn.microsoft.com/vcblog/2016/11/01/vcpkg-updates-static-linking-is-now-available/">默认策略</a>是动态库。对静态库的支持很差，需要手工改一些内容。</p>
<blockquote>
<p>In Visual Studio, you can override <em>the auto-detected triplet</em> (which will default to DLLs) using the MSBuild properties “<code>VcpkgTriplet</code>” and “<code>VcpkgEnabled</code>”.</p>
</blockquote>
<p> 如何覆写 MSBuild 属性呢？——目前只发现，以文本形式手动修改 <code>.vxproj</code> 工程文件的方式。好蠢</p>
<p> 试验 Property Sheets 总是莫名其妙无效，直接复制到 .vxproj 中又能生效。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">&quot;Globals&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">VcpkgTriplet</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(Platform)&#x27;==&#x27;Win32&#x27;&quot;</span>&gt;</span>x86-windows-static<span class="tag">&lt;/<span class="name">VcpkgTriplet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;VcpkgEnabled&gt;true&lt;/VcpkgEnabled&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;VcpkgTriplet Condition=&quot;&#x27;$(Platform)&#x27;==&#x27;x64&#x27;&quot;&gt;x64-windows-static&lt;/VcpkgTriplet&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2></li>
</ol>
<p>截止到目前版本，</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">PS E:\vcpkg&gt; .\vcpkg.exe version</span><br><span class="line">Vcpkg package management program version 2018.10.20-nohash</span><br><span class="line"></span><br><span class="line">See LICENSE.txt for license information.</span><br></pre></td></tr></table></figure>
<p>Vcpkg 单个 triplet 文件能够同时生成 <code>Debug/Release</code> 调试版本和发布版本的库。通过自定义 triplet 能够支持 「(<code>x64/win32</code>) &amp;（<code>动态链接库</code>/<code>静态链接库</code>）&amp;（<code>/MD(d)</code>运行时 /<code>/MT(d)</code>运行时）」。</p>
<ol>
<li>其内嵌对 「(<code>x64/win32</code>) &amp;（使用 <code>/MT(d) </code>运行时的<strong>静态链接库</strong> | 使用 <code>/MD(D) </code>运行时的<strong>动态链接库</strong>）」 的支持，在 <code>triplets</code> 文件夹中查看；</li>
<li>其对 「（<code>动态链接库</code>/<code>静态链接库</code>）&amp;（<code>/MD(d)</code>运行时/<code>/MT(d)</code>运行时）」其他组合的支持，需要用户自行编写 triplet 文件实现。</li>
</ol>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>在上述前提下，要求 Visual Studio 自动化支持 （<code>动态链接库</code>/<code>静态链接库</code>）&amp;（<code>/MD(d)</code>运行时/<code>/MT(d)</code>运行时）的任意组合不现实，尤其是场景 2 全权交给用户自行操作的情况。</p>
<p>另外，由于 Visual Studio 并没有「<code>动态链接/静态连接</code>」的开关选项。所以，IDE 仅支持 (<code>Debug/Release</code>) X (<code>x64/win32</code>) X（<code>动态链接库</code>/<del><code>静态链接库</code></del>）X（<code>/MD(d)</code>运行时/<del><code>/MT(d)</code>运行时</del>）。</p>
<ul>
<li>其他组合，需要手动修改 Visual Studio 工程的 property sheet 实现。</li>
</ul>
<p><strong>NOTICE</strong> 第三方库采用的运行时，和项目编译时采用的运行时，这是两个概念。应该一致，但不代表一定一致。</p>
<p>使用 vc2019 时，平台工具集与 IDE 不一致时，<code>vcpkg integrate</code> 不生效。比如：</p>
<ul>
<li>使用 vc2019 + v140 不生效；只能使用 vc2019 + v142</li>
</ul>
<p>但使用 vc2015 时，+ v140/v140_xp/v120 都能够生效（后者不支持 <code>std::chrono</code> 等特性）。</p>
<p>另外，vc2019 在以下方面和 vc2015 也不同：</p>
<ul>
<li>在项目属性 <code>C/C++ -常规-附加包含目录-继承的值</code> 看不到 <code>$(VcpkgRoot)include</code>；</li>
<li>在 <code>链接器-输入-附加依赖项-继承的值</code> 中看不到 <code>$(VcpkgRoot)debug\lib\*.lib</code> 字样。vc2015 能够看到。</li>
</ul>
<h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p><a href="https://blog.csdn.net/cjmqas/article/details/79282847">Visual Studio开源库集成器Vcpkg全教程–利用Vcpkg轻松集成开源第三方库</a></p>
<p>github 中的手册：<a href="https://github.com/Microsoft/vcpkg/blob/master/docs/index.md">docs</a></p>
<p>在 FAQ 中也提到了 Vcpkg 和 NuGet、Conan、Chocolatey 的区别</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 操作及其配置</title>
    <url>/2017/03/08/vim-profile/</url>
    <content><![CDATA[<p>在 Linux 终端下用 Vim 编辑程序时，<a href="http://blog.csdn.net/absurd/article/details/593881">不能按 Ctrl + S！</a></p>
<blockquote>
<p>对于大多数终端，可以用 <code>Ctrl + S</code> 禁用“回显”，然后用<code>Ctrl + Q</code> 启用“回显”。<a href="https://program-think.blogspot.com/2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html">引用来源</a></p>
</blockquote>
<p>打印了一份《Vim基本操作思维导图.pdf》，放在桌子上，用到的时候随时查看。其中有不足之处，例如，关于替换的操作让我困惑了好几次，后来在网上重新搜索 <a href="http://tanqisen.github.io/blog/2013/01/13/vim-search-replace-regex/">Vim查找替换及正则表达式的使用</a> 之后，才明白过来 <code>g</code> 参数并非全局，而是整行。</p>
<p>所以，系统性的学习还是很有必要的。参考 <a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html">Vim命令合集</a>，其中也有瑕疵，多看评论。<strong>在实践中慢慢掌握才是王道</strong>，再如何花费时间去查阅，随手敲敲命令看看效果都是<strong>浪费时间</strong>，刻意地进行反复练习，效果有，但是意义呢？</p>
<a id="more"></a>

<h1 id="windows-之-gVim"><a href="#windows-之-gVim" class="headerlink" title="windows 之 gVim"></a>windows 之 gVim</h1><p>引用 <a href="http://www.path8.net/tn/archives/2191">windows下gVim（Vi/vim）基本使用</a> 中的描述：</p>
<blockquote>
<p>Vim 是一个 Linux 平台上功能非常强大的编辑器，他是早年的 Vi 编辑器的加强版。这个 gVim 是 windows 版的，并且有了标准的 windows 风格的图形界面，所以叫 g(graphical)Vim。我们可以将 gvim 理解为 vim（vi的加强版）图形化版本，其指令和用法都完全相同，所以可以參考 vim 的指令。</p>
</blockquote>
<p>安装之后，gVim, gVim Diff, gVim Easy, gVim Read-only 简单区别：</p>
<ul>
<li><p>通常我们常用的是 gVim.</p>
</li>
<li><p>Diff 是用来对比两个文件内容用的，直接打开挺没用的，不过直接拖 2 个文件到快捷方式上倒是可行；</p>
</li>
<li><p>Easy 启动的时候是 insert 模式，适合普通 windows 用户的习惯； </p>
</li>
<li><p>Read-Only 的用途：比如用 read-only 打开已经用 vim 打开过的文件，就不会提示让人烦躁的 .swp 文件存在的问题；</p>
<p>  比如可以用它来看 TXT 的电子书不会存在误删误改（ctrl+b ctrl+f 很方便）.</p>
</li>
</ul>
<h1 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h1><p>在网上直接找到了 <a href="https://github.com/spf13/spf13-vim">spf13</a>，号称 vim 的终极配置。应该是很棒的样子。但是我只开发 C/C++，感觉 spf13 整合的好多。一方面机器资源有限，能感觉到配置 spf13 之后打开 vim 变慢，另一方面，毕竟是 vim 新手，连复制粘贴都尚未熟练掌握的菜鸟，并不能领会到 spf13 有多强大。或许太容易得到的也就不珍惜吧。</p>
<p>讨论帖-<a href="https://www.v2ex.com/t/231839">用 vim 开发 c/c++，求推荐 vim 配置</a> 中一句甚合我意，说得很是贴心。所以打算自己一点点来，学习 vim 配置的语法，磨合专属的 vim。</p>
<blockquote>
<p>vim 这玩意就是自己磨合出来的，别人的配置拿过来还用 vim 干嘛，直接上 ide 了</p>
</blockquote>
<p>以后就泡 Vimer 的程序世界-<a href="http://www.vimer.cn/archives/91.html">把VIM打造成一个真正的IDE</a>，慢慢来。不要有投机取巧的心理，以为找到一款好的配置就可以熟练操作 vim，写起代码来虎虎生风。所有事情都是需要<strong>积累</strong>，付出<strong>辛苦</strong>，付出<strong>努力</strong>的！</p>
<p>等磨合一段时间之后，回过头来再看别人的配置。</p>
<h1 id="Debian8Light-系统-vimer-用户操作记录"><a href="#Debian8Light-系统-vimer-用户操作记录" class="headerlink" title="Debian8Light 系统 vimer 用户操作记录"></a>Debian8Light 系统 vimer 用户操作记录</h1><p><strong>2016/7/13 19:50:19 Vim 配置暂告一段落，先用用再说。重点在于 c++11 的编程能力！</strong>要懂得<strong>适可而止</strong>，互联网时代任何知识点进行深挖都是可以穷尽时间的。</p>
<ol>
<li><p>安装 <a href="https://github.com/VundleVim/Vundle.Vim">vundle</a>。</p>
</li>
<li><p>安装 <a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a></p>
<p> 安装过程中碰到空间不足问题，其实是 /tmp 分区时分配空间太小，只有几十M造成的。解决方案 <a href="http://blog.csdn.net/feihongwang/article/details/17383833">linux下编译出现空间不足解决办法</a></p>
</li>
<li><p>插件控，主要参考 <a href="http://blog.guorongfei.com/2015/10/06/vim-plugin/">编辑利器 Vim 之插件配置</a> 折腾。大多数插件都设置有快捷键，死记硬背是没用的</p>
<p> 括号、引号的匹配输入，我要求的是在括号、引号中输入完毕后使用快捷键跳出，然后继续输入，而不是手工移到括号、引号外。验证 delimitMate、auto-pairs 相关功能</p>
</li>
<li><p>代码补全： YCM + (<a href="https://github.com/SirVer/ultisnips#quick-start">ultisnips</a> &amp; vim-snippets)，两者在快捷键上存在冲突。。即便</p>
<blockquote>
<p>YouCompleteMe 的文档说它集成了 supertab 的功能</p>
</blockquote>
<p> 需要进一步配置，参考 <a href="http://www.tuicool.com/articles/eU7BNf">How to Make YouCompleteMe Compatible with UltiSnips</a>。可能是 <a href="https://github.com/Valloric/YouCompleteMe#ycm-conflicts-with-ultisnips-tab-key-usage">YCM 集成 supertab 有过调整</a>，如果采用上述中的配置并使之生效的话需要单独安装 supertab。实际操作中，并不理想，会出现莫名其妙的状况。</p>
</li>
<li><p>自动补齐括号、引号。使用 delimitMate 跳出自动补全的括号快捷键 <code>Shift+Tab</code>，一直无效，所以觉得不好用。直到发现：</p>
<ol>
<li>先是被 XShell 终端占用了，作为“转到最近对话”的快捷键；</li>
<li>其次，<a href="https://github.com/Valloric/YouCompleteMe#the-gycm_key_list_previous_completion-option">是被 YCM 占用了</a>；</li>
<li>结果，还是无效……</li>
<li>auto-pairs 的 <M-n> 也无效……</li>
</ol>
</li>
<li><p>注释开关：<a href="https://github.com/scrooloose/nerdcommenter#default-mappings"><code>[count]&lt;leader&gt;c&lt;space&gt;</code></a></p>
</li>
</ol>
<p>截至 <del>2016/7/13 11:07:15</del> 2017/5/26 17:21:35  使用的 .vimrc 文件和 /home/vimer/.vim/ftplugin 目录下的 cpp.vim 文件。（ps：hexo 不支持 VimL 标签，无语法高亮）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&#39;~&#x2F;some&#x2F;path&#x2F;here&#39;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;</span><br><span class="line"></span><br><span class="line">&quot; The following are examples of different formats supported.</span><br><span class="line">&quot; Keep Plugin commands between vundle#begin&#x2F;end.</span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">Bundle &#39;ervandew&#x2F;supertab&#39;</span><br><span class="line">&quot; YCM 已经集成了 syntastic</span><br><span class="line">Bundle &#39;Valloric&#x2F;YouCompleteMe&#39;  </span><br><span class="line">&quot; 引擎 &amp; 代码块描述</span><br><span class="line">Bundle &#39;SirVer&#x2F;ultisnips&#39;</span><br><span class="line">Bundle &#39;honza&#x2F;vim-snippets&#39;</span><br><span class="line">&quot; delimitMate 不好用。使用 auto-pairs</span><br><span class="line">&quot;Bundle &#39;Raimondi&#x2F;delimitMate&#39;</span><br><span class="line">Bundle &#39;jiangmiao&#x2F;auto-pairs&#39;</span><br><span class="line">Bundle &#39;tpope&#x2F;vim-surround&#39;</span><br><span class="line">&quot;Bundle &#39;rdnetto&#x2F;YCM-Generator&#39;</span><br><span class="line">&quot;快速注释</span><br><span class="line">Bundle &#39;scrooloose&#x2F;nerdcommenter&#39;</span><br><span class="line">&quot;文档化注释</span><br><span class="line">Bundle &#39;vim-scripts&#x2F;DoxygenToolkit.vim&#39;</span><br><span class="line">&quot;目录树</span><br><span class="line">Bundle &#39;scrooloose&#x2F;nerdtree&#39;</span><br><span class="line">&quot;函数列表</span><br><span class="line">Bundle &#39;majutsushi&#x2F;tagbar&#39;</span><br><span class="line">&quot;快速查找</span><br><span class="line">Bundle &#39;kien&#x2F;ctrlp.vim&#39;</span><br><span class="line">&quot;状态栏</span><br><span class="line">Bundle &#39;vim-airline&#x2F;vim-airline&#39;</span><br><span class="line">&quot; Git 工具</span><br><span class="line">Bundle &#39;tpope&#x2F;vim-fugitive&#39;</span><br><span class="line">&quot; cpp 语法高亮</span><br><span class="line">Bundle &#39;octol&#x2F;vim-cpp-enhanced-highlight&#39;</span><br><span class="line">&quot;代码格式化工具</span><br><span class="line">Bundle &#39;Chiel92&#x2F;vim-autoformat&#39;</span><br><span class="line">&quot; plugin from http:&#x2F;&#x2F;vim-scripts.org&#x2F;vim&#x2F;scripts.html</span><br><span class="line">Bundle &#39;EasyGrep&#39;</span><br><span class="line">&quot;头文件和源文件快速切换</span><br><span class="line">Bundle &#39;a.vim&#39;</span><br><span class="line">&quot; 自动插入 commets</span><br><span class="line">Bundle &#39;c.vim&#39;</span><br><span class="line">&quot; plugin from http:&#x2F;&#x2F;vim-scripts.org&#x2F;vim&#x2F;scripts.html</span><br><span class="line">&quot; Git plugin not hosted on GitHub</span><br><span class="line">&quot; git repos on your local machine (i.e. when working on your own plugin)</span><br><span class="line">&quot; The sparkup vim script is in a subdirectory of this repo called vim.</span><br><span class="line">&quot; Pass the path to set the runtimepath properly.</span><br><span class="line">&quot; Install L9 and avoid a Naming conflict if you&#39;ve already installed a</span><br><span class="line">&quot; different version somewhere else.</span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line">&quot; To ignore plugin indent changes, instead use:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :PluginList       - lists configured plugins</span><br><span class="line">&quot; :PluginInstall    - installs plugins; append &#96;!&#96; to update or just :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - searches for foo; append &#96;!&#96; to refresh local cache</span><br><span class="line">&quot; :PluginClean      - confirms removal of unused plugins; append &#96;!&#96; to auto-approve removal</span><br><span class="line">&quot;</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; Put your non-Plugin stuff after this line</span><br><span class="line"></span><br><span class="line">let g:ycm_global_ycm_extra_conf &#x3D; &#39;&#x2F;home&#x2F;vimer&#x2F;.ycm_extra_conf.py&#39;</span><br><span class="line">&quot; 允许 vim 加载 .ycm_extra_conf.py 文件，不再提示</span><br><span class="line">let g:ycm_confirm_extra_conf&#x3D;0</span><br><span class="line"></span><br><span class="line">set number</span><br><span class="line">syntax on</span><br><span class="line">&quot; 映射快捷键。&lt;leader&gt; 前缀键默认是 \</span><br><span class="line">nnoremap &lt;F8&gt; :TagbarToggle&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;fl :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot;设置NERDTree子窗口宽度</span><br><span class="line">let NERDTreeWinSize&#x3D;23&quot;</span><br><span class="line">&quot; Trigger configuration. Do not use &lt;tab&gt; if you use</span><br><span class="line">&quot; https:&#x2F;&#x2F;github.com&#x2F;Valloric&#x2F;YouCompleteMe.</span><br><span class="line">let g:UltiSnipsExpandTrigger&#x3D;&quot;&lt;tab&gt;&quot;</span><br><span class="line">let g:UltiSnipsJumpForwardTrigger&#x3D;&#39;&lt;C-b&gt;&#39;</span><br><span class="line">let g:UltiSnipsJumpBackwardTrigger&#x3D;&#39;&lt;C-z&gt;&#39;</span><br><span class="line">&quot; 解决 Ultisnips 与 YCM 插件的冲突</span><br><span class="line">&quot; First, change the default key-binding of YCM</span><br><span class="line">let g:ycm_key_list_select_completion &#x3D; [&#39;&lt;C-n&gt;&#39;, &#39;&lt;Down&gt;&#39;]</span><br><span class="line">let g:ycm_key_list_previous_completion &#x3D; [&#39;&lt;C-p&gt;&#39;, &#39;&lt;Up&gt;&#39;]</span><br><span class="line">&quot; Then set the default action of SuperTab to triggering &lt;C-n&gt;</span><br><span class="line">let g:SuperTabDefaultCompletionType &#x3D; &#39;&lt;C-n&gt;&#39;</span><br><span class="line"></span><br><span class="line">let g:DoxygenToolkit_authorName&#x3D;&quot;nielong &lt;nielong2014@gmail.com&gt;&quot;</span><br><span class="line">let g:DoxygenToolkit_briefTag_funcName&#x3D;&quot;yes&quot;</span><br><span class="line">let g:doxygen_enhanced_color&#x3D;1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set shiftwidth&#x3D;2</span><br><span class="line">&quot; 快捷键，编译运行</span><br><span class="line">nnoremap &lt;F5&gt;   &lt;Esc&gt;:w&lt;CR&gt;:!g++ -std&#x3D;c++11 % -o &#x2F;tmp&#x2F;a.out &amp;&amp; &#x2F;tmp&#x2F;a.out&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F7&gt;   &lt;Esc&gt;:w&lt;CR&gt;:!g++ -std&#x3D;c++11 %&lt;CR&gt;</span><br><span class="line">nnoremap &lt;C-F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ -std&#x3D;c++11 -g % -o &#x2F;tmp&#x2F;a.out &amp;&amp; gdb &#x2F;tmp&#x2F;a.out&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>c.vim 插件支持作者信息、创建日期、文件描述等信息，但不包含更新日期；不支持头文件自动生成 <code>ifndf</code> 等宏。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title>建立 vps 后的第一步</title>
    <url>/2020/12/25/vps_first/</url>
    <content><![CDATA[<p>建立 vps 后首先要保证后续的使用安全。否则再多的功能都是空中楼阁。</p>
<h1 id="SSH-登录"><a href="#SSH-登录" class="headerlink" title="SSH 登录"></a>SSH 登录</h1><p>非对称密钥算法的作用分为两种场景：</p>
<ul>
<li>加密数据：公钥加密，私钥解密。数据由前者发往后者，数据是安全的。</li>
<li>认证：私钥加密，公钥解密。后者验证前者的身份，传输数据的安全性是没有保证的。</li>
</ul>
<p>那么远程登录呢？</p>
<a id="more"></a>

<blockquote>
<p>SSH 本身提供两种级别的验证方法：基于口令的安全验证；基于密钥的安全验证。<a href="https://blog.csdn.net/li528405176/article/details/82810342">引用来源</a></p>
</blockquote>
<ul>
<li><p>口令登录，属于加密数据的场景。</p>
<blockquote>
<p>首次登录时客户端获取服务端的公钥，询问其公钥指纹是否可信（客户需要通过其他方式验证真伪）。</p>
<p>然后客户端以服务端公钥加密口令后传输，服务端使用自身的密钥解密后验证。<a href="https://blog.csdn.net/csm201314/article/details/78453579">参考</a></p>
</blockquote>
</li>
<li><p>密钥登录，属于认证的场景，比如签名。</p>
<blockquote>
<p>需要将客户端的公钥上传给服务端（服务端通过其他方式验证是否可信）。</p>
<p>客户端打个招呼要登录，服务端将一个随机字符串发给客户端。</p>
<p>客户端使用自身的私钥加密后，服务端解密验证是否一致。</p>
</blockquote>
</li>
</ul>
<p>CentOS 上创建普通用户后，默认共用 <code>/etc/ssh/</code> 中的密钥。<del>应该进一步的分离，不同用户使用各自的密钥吧</del>？<code>/etc/ssh/</code> 中的证书可以认为是用于标识主机的，本就和用户无关。</p>
<p><a href="https://alick9188.wordpress.com/2013/02/23/ssh-host-fingerprint/">查看 SSH 主机密钥的指纹</a> 的命令： <code>ssh-keygen -l </code></p>
<p><a href="https://marskid.net/2018/02/05/how-to-verify-ssh-public-key-fingerprint/">验证远程主机 SSH 指纹</a>，通过 <strong>可信渠道</strong> 获得服务器的公钥指纹，与客户端首次登录服务器时的指纹对比。</p>
<h1 id="centos-的基础操作"><a href="#centos-的基础操作" class="headerlink" title="centos 的基础操作"></a>centos 的基础操作</h1><p>为了某人能够业余时间练习、熟悉操作，方便工作。所以使用了与其公司服务器相同的操作系统。限于其公司版本过低， vultr 不提供一键安装服务（需要自行配置），所以采用了目前的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 centos 版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 8.1.1911 (Core)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看用户列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br></pre></td></tr></table></figure>
<p>linux 下查看进程占用的端口分为两步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看nginx进程pid：</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">通过nginx进程pid查看占用端口（进程pid为9836）</span></span><br><span class="line">netstat -nap | grep 9836</span><br></pre></td></tr></table></figure>
<p>操作用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adduser v2ray</span></span><br><span class="line"><span class="meta">#</span><span class="bash">为这个用户初始化密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> passwd v2ray</span></span><br></pre></td></tr></table></figure>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>服务端配置完毕，通信失败时首先要确认的就是端口是否打开。</p>
<blockquote>
<p>Centos 升级到 7 之后，内置的防火墙已经从 iptables 变成了 firewalld</p>
</blockquote>
<p>所以这里只记录 firewall 的操作备忘。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已经开放的端口：</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量开发端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=30000-40000/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>命令含义：</p>
<ul>
<li><code>–zone</code> #作用域</li>
<li><code>–add-port=80/tcp</code> #添加端口，格式为：端口/通讯协议</li>
<li><code>–permanent</code> #永久生效，没有此参数重启后失效</li>
</ul>
<p>调整防火墙（比如删减端口）之后，重启生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="bash">查看默认防火墙状态</span></span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>
<h2 id="启停服务"><a href="#启停服务" class="headerlink" title="启停服务"></a>启停服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">停止firewall</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动</span></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止firewall开机启动</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>2020年6月2日，今天发现在公司的联通网络下无法登录 vps 了，连接总是失败，提示超时。</p>
<p>通过其他主机访问 vps 能够成功，但进入之后看到警告信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There were 2897 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>
<p>提示主机被尝试暴力破解。通过 <code>systemctl status sshd</code> 或者查看 <code>ll /var/log/secure -h</code> 等方式都能够看到异常。</p>
<h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>尝试修改 <code>vim /etc/ssh/sshd_config</code> 默认的 22 端口，重启服务器失败。查询发现报错信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port 88888.</span><br></pre></td></tr></table></figure>
<p>解决方式其实在配置文件的注释中也说明了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> If you want to change the port on a SELinux system, you have to tell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELinux about this change.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> semanage port -a -t ssh_port_t -p tcp <span class="comment">#PORTNUMBER</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#Port 22</span></span></span><br><span class="line">Port 88888</span><br></pre></td></tr></table></figure>
<p>改完端口之后，公司的主机还是无法登录，依然是超时报错。</p>
<p>2020年6月24日13:21:37 修改端口并不能一劳永逸，今天发现 /var/log/secure 文件已经 12M 了，从上次成功登陆到刚刚，有 4500+ 次的错误尝试。</p>
<h3 id="禁用-root-远程登陆"><a href="#禁用-root-远程登陆" class="headerlink" title="禁用 root 远程登陆"></a>禁用 root 远程登陆</h3><p>先创建普通用户。</p>
<p>修改 <code>/etc/ssh/sshd_config</code> 文件，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#PermitRootLogin yes</span><br><span class="line"># 修改为 -&gt;</span><br><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure>
<p>重启 sshd 服务生效。禁止以后，可以使用普通用户 ssh 登录，登录后可以切换到 root 权限。</p>
<p>更安全了，但登录失败的暴力破解日志还是会一直生成，不开心。</p>
<p>2020年6月30日13:30:50 普通用户登录，切换 root 登录时提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Last login: Wed Jun 24 05:51:51 UTC 2020 on pts/0</span><br><span class="line">Last failed login: Tue Jun 30 05:28:48 UTC 2020 from 106.13.69.8 on ssh:notty</span><br><span class="line">There were 14744 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>
<h3 id="添加禁止-ip"><a href="#添加禁止-ip" class="headerlink" title="添加禁止 ip"></a>添加禁止 ip</h3><p>参考 <a href="http://www.cpacm.net/2019/09/23/%E9%98%B2%E6%AD%A2%E6%9C%8D%E5%8A%A1%E5%99%A8SSH%E8%A2%AB%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/">防止服务器SSH暴力破解</a>，拷贝其脚本，在服务器定时执行 /root/a.txt 脚本。</p>
<h3 id="秘钥登录"><a href="#秘钥登录" class="headerlink" title="秘钥登录"></a>秘钥登录</h3><p>为了保证使用的便捷性，<a href="http://ivo-wang.github.io/2019/04/08/vps-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E8%AE%BE%E7%BD%AE/">更改秘钥登录</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>windbg</title>
    <url>/2019/11/04/windbg/</url>
    <content><![CDATA[<h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><p>看一下 pageheap 针对的是什么问题？ <a href="https://blog.csdn.net/xiaohyy/article/details/4174493">堆调试工具——pageheap的使用和原理分析</a></p>
<p>pageheap 和 gflags 什么关系？前者被包含到了后者中。</p>
<blockquote>
<p>This version of GFlags includes the functionality of PageHeap (pageheap.exe), a tool that enables heap allocation monitoring in Windows. </p>
</blockquote>
<p>如何安装 gflags？安装 WinDbg</p>
<blockquote>
<p>GFlags is included in the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">Debugging Tools for Windows 10 (WinDbg).</a></p>
</blockquote>
<p>如何 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/">获取 WinDbg</a>？</p>
<ul>
<li><p>在安装过程中，通过 win 10 sdk 的方式（无论是通过 msvc2019 还是直接安装 win10 sdk）都没有成功。</p>
</li>
<li><p>最终单独安装的 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk">Windows Driver Kit (WDK)</a></p>
<blockquote>
<p>Step 2: Install WDK for Windows 10, version 1903</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>PageHeap / GFlags 使用，只涉及两三条命令。<a href="https://blog.csdn.net/wl_fln/article/details/6283587">使用Gflags来检测heap问题</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置正常页堆：</span></span><br><span class="line">gflags.exe /p /enable myapp.exe</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置完全页堆：</span></span><br><span class="line">gflags.exe /p /enable myapp.exe /full</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出当前启动了页堆的进程列表：</span></span><br><span class="line">gflags.exe /p</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消页堆设置：</span></span><br><span class="line">gflags.exe /p /disable myapp.exe</span><br></pre></td></tr></table></figure>
<p>然后启动 myapp.exe 似乎就能精准定位到异常位置了。可是我在 msvc 中运行 release 只收获了“应用程序无法正常启动(0xc0000142)”，底部“输出框”中打印 </p>
<blockquote>
<p>程序“[1896] test.exe”已退出，返回值为 -1073741502 (0xc0000142) ‘DLL Initialization Failed’。</p>
</blockquote>
<p>中间曲折的尝试不再絮说，来看 GFlags 的一个参数 /debug 描述</p>
<blockquote>
<p>By default, this parameter uses the <strong>NTSD</strong> debugger with the command line <code>ntsd -g -G -x</code> and with page heap enabled, but you can use the DebuggerCommand variable to specify a different debugger and command line.</p>
</blockquote>
<p>关键就在于“调试器”是有很多种类的，windows 上并非只有 visual studio !</p>
<p>没能够掌握如何通过命令行指定 vsjitdebugger.exe，只能通过 gflags-gui</p>
<p><a href="https://blog.csdn.net/lunasea0_0/article/details/6292968">Windbg的gflags.exe – Attach调试利器</a><br><a href="https://blog.csdn.net/bao_bei/article/details/73840674">Windbg的gflags.exe调试堆栈溢出，访问越界等问题</a></p>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>WinDbg</p>
<ul>
<li>Debugging Using WinDbg</li>
<li>Debugging Using KD and NTKD</li>
<li>Debugging Using CBD and NTSD</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>码字，第一篇博客</title>
    <url>/2016/10/27/writing/</url>
    <content><![CDATA[<p>个人学习笔记，学习的总结，肯定是采用文字的形式记录。是以纸笔墨砚的形式，还是以更现代的码字的形式？上学的时候还固执于前者，写写画画了好几个本子，每个上面都有些文字，却也都不成系统，而且基本上全是个人日记，记录心情，发泄情绪。工作后渐渐放弃了纸笔间的习惯，喜欢在键盘上码字，整理的内容也由日记全部过渡成了技术帖。一开始在印象笔记中零零散散保存，后来同时使用为知笔记并逐渐过渡了日记使用前者，技术帖使用后者。因为基本不再写日记，印象笔记也就变成了存储记忆的空间，还是不翻书的那种。</p>
<p>后来迷上 markdown，有半个月打算放弃为知笔记，后来发现 markdown 只能替代为知笔记默认编辑器的位置，而个人知识管理的体系、框架的建立与维护还是得靠为知笔记。但两者的结合并不完美，核心问题在于技术人员（指我自己）使用 GFM，而为知笔记的 markdown 解释器并不能完全支持 GFM，尤其是语法高亮方面（主要使用 shell、vimL、console 的支持），GFM 不支持 <code>[TOC]</code> 标签。</p>
<p>使用 MarkdownPad 2 编辑文字很爽，但保存的 <code>.md</code> 文档在查阅时并不直接。将其拷贝到为知笔记中在首部添加 <code>[TOC]</code> 标签后发布，阅读时直观，查找时无论是根据多层级文件级树形查找还是直接使用内建的搜索框直接搜索都是很方便的，不足之处在于：</p>
<ul>
<li>一方面即便其支持 markdown 编辑，但并不友好，尤其是在使用 MarkdownPad 2 之后；</li>
<li>另一方面，使用 markdown 语法的前提下，无法实现在笔记中插入对另一篇笔记的引用（链接），这在整理系列笔记时尤其不能容忍。</li>
</ul>
<p>想通过搭建个人的博客网站来解决上述矛盾：保留使用 MarkdownPad 2 编辑文字的习惯，放弃为知笔记，将文字直接发布到外网上就可以解决无法链接、笔记之间相互跳转的问题。此种情况下带来一点点不便，如果帖子中涉及个人隐私、公司商业机密（我笑），需要仔细筛选。</p>
<p>在搭建个人博客的摸索阶段，从为知笔记到博客网站的过渡阶段，依然会使用为知笔记，并不在时间轴上一刀切，一下子将为知笔记中的内容全部拷贝到网站中，然后清空、销户。</p>
<p>使用 GitHub Pages 和 Hexo 搭建个人博客，静态网页会在 Github 中保留有版本记录，但源 <code>.md</code> 文件的存储（乃至版本控制）尚需考虑：</p>
<ul>
<li><p><del>对编辑的过程（版本控制）要求高，考虑</del> 在 <code>~\hexo\source</code> 创建版本库；2020/12/25，折腾一遭还是选择此方案</p>
</li>
<li><p><del>只要求结果（对版本控制要求低），有 <code>.md</code> 文件的备份即可，考虑整体迁移到 Dropbox 中；</del> </p>
<p>  <del>因为 <code>hexo\blog\source\_posts</code> 目录（<code>.md</code> 源）只能在 hexo 树形目录的固定节点，所以想将其备份到 dropbox 中，需要 trick / workaround，<a href="09">Windows下硬链接、软链接和快捷方式的区别</a></del></p>
</li>
<li><p>图片库的问题，考虑使用图床；2020/12/25，PicGo+GitHub，谁用谁知道</p>
</li>
<li><p>对目录有需求，使用哪种实现呢？<code>[TOC]</code> 不解析，使用支持目录的主题。</p>
</li>
</ul>
<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><p>阮一峰说喜欢写Blog的人，会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>在网上查找两篇教程，按部就班的操作就能得到结果。目前对于博客没有任何复杂的要求，对评论、对布局、主题都没有挑选的欲望。博客只是用来将自己的整理的笔记、学习总结放到互联网上存储，查阅时不用再打开为知笔记，不用打开 MarkdownPad2 实时生成，带来查阅时的便利即可。</p>
<p>对于评论，教程中多提及中文用户推荐“多说”，起步阶段没有需求，加上暂时不想再多花时间在这些“边缘”上，所以未开启评论功能。总的来说，博客还是处于自我查阅阶段。</p>
<p>参考 <a href="https://hexo.io/zh-cn/">hexo 官方站点</a> 的介绍，在 <a href="https://nodejs.org/zh-cn/">下载安装 Node.js</a> 之后，执行以下命令即可完成搭建。 </p>
<ul>
<li>下载 Node.js 时，不使用代理时下载飞快；</li>
<li>安装 Node.js 的过程会自动配置 Path，安装完毕使用 powershell 输入 <code>node</code> 验证</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog <span class="comment">#解释：初始化了一个文件夹叫做blog，如果不想叫blog可以改为别的名字</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 github 发布需要</span></span><br><span class="line">npm install hexo-deployer-git -S</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用本地搜索需要</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>拉取笔记仓库，并替换 source 目录：进入 <code>blog\</code> 目录，执行 <code>git clone git@github.com:tnie/notes.git</code>，然后 <code>rm source -rf &amp;&amp; move notes source</code></p>
<p>使用仓库中的配置文件，更新 blog 的配置项目。</p>
<p><strong>注意</strong>：绑定本地 hexo 和个人的 Github Pages 后（修改全局配置文件），执行 <code>hexo deploy</code> 命令部署时需要先安装  hexo-deployer-git. <code>npm install hexo-deployer-git -S</code></p>
<h1 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h1><p>整理完笔记之后，怎么发布到 github.io 上？在这里针对具体的步骤做一份备忘录，防止因为懒惰或其他原因较长时间不发博客，“回归”时还要再次花费时间查阅 Hexo + GitHub Pages 技术帖子。而且，技术相通，但每个人都会培养出属于自己的习惯，不想“回归”时再摸索。</p>
<ol>
<li><p>在 Git Shell 中打开至 hexo 目录。<code> cd hexo</code></p>
</li>
<li><p>敲入 <code>hexo new &quot;filename&quot;</code> 命令。此命令会在 source/_posts 目录下创建 filename.md 文件</p>
<ul>
<li>filename 建议使用英文，且不要存在空白字符。可以使用下划线 _ 连接两个单词。</li>
<li>用翻译工具查一查，起个好名字。</li>
</ul>
</li>
<li><p>打开 source/_posts 目录，使用 MarkdownPad2 编辑文字，修改 title tags categories 属性，保存。</p>
<ul>
<li>一般来说，都是将写好的笔记全文粘贴过来。记得删除源文件，在过一段时间之后维护多个相似文件是很痛苦的。</li>
<li>title 使用中文；tags categories 原则上一律小写。</li>
<li>tags 属性存在多个时，可以这样写 <code>tags: [make,makefile]</code>，但注意每一个 tag 中不能有空格，比如 <code>tags: design pattern</code> 这是错的</li>
</ul>
</li>
<li><p>敲入 <code>hexo generate</code> 生成静态网页。</p>
</li>
<li><p>敲入 <code>hexo server</code> 启动本地服务器，查看效果。</p>
</li>
<li><p>敲入 <code>hexo deploy</code> 发布到互联网。</p>
</li>
<li><p>迁移为知笔记中的内容。“迁移”顾名思义，要从为知笔记中删除。</p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>有讲述整体流程的，有着眼于模块的——描述主题的、强调分类和标签的、添加站内搜索、添加评论的……</p>
<ol start="3">
<li>其中，在 Debian8 上安装 Node.js 使用 <a href="https://nodejs.org/en/download/">其官方</a> 的 Linux Binaries (.tar.xz) 版本。解压之后直接配置系统 PATH 路径即可。<code>tar xJvf node-v4.4.7-linux-x64.tar.xz</code></li>
<li>如果有更换域名的需求，可以参考 <a href="http://www.jianshu.com/p/05289a4bc8b2">简明Github Pages与Hexo教程</a>，而且作者是在 win7 环境下搭建的，同时文末给出了大量的参考资料。</li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>官方是有 <a href="https://hexo.io/themes/">辣么多的主题</a> 让我们选，挑花了眼。</p>
<p>2017/4/13，使用新的主题 <a href="https://github.com/theme-next/hexo-theme-next">NexT</a>。原因有二：</p>
<ul>
<li>Jacman 的搜索不能用。网上有很多其搭配 swiftype，但其他的第三方（比如谷歌）却怎么都调试不成功。</li>
<li>Jacman 作者自己貌似都放弃了，<a href="http://wuchong.me/">作者自己的博客</a> 使用 NexT 主题是其一，不再维护 Jacman 是关键。</li>
</ul>
<p>使用 NexT 主题，碰到的问题 —— 其 404 页面的配置在使用 https 协议时有问题：</p>
<blockquote>
<p>Hexo NexT 主题给出的腾讯 404 公益页面的教程仅适用于非 HTTPS 站点，对于严格限制混合内容的 HTTPS 站点来说，腾讯 404 公益页面使用的 JS 文件是无法引入的。</p>
</blockquote>
<p>解决方案：<a href="https://github.com/hexojs/hexo/issues/2411">关于 Hexo 上传 404 页面的问题</a></p>
<h2 id="目录和标签"><a href="#目录和标签" class="headerlink" title="目录和标签"></a>目录和标签</h2><p><a href="http://ijiaober.github.io/2014/08/05/hexo/hexo-04/">Hexo使用攻略：（四）Hexo的分类和标签设置</a></p>
<p>目录和标签有什么区别？关键词：一个目录，多个标签；树状结构，网状结构；</p>
<ol>
<li>怎么给文章添加合适的标签呢？</li>
<li>在目录上尽可能的粗放，再用标签进行管理</li>
<li>使用树状目录尽量不要超过3级。</li>
<li>树状目录应该是和标签系统互补的；</li>
<li>标签起一种聚合作用，将相关性很强的东西联系到一起；分类目录则是相当于存放同类文章的容器，里面的文章虽属同类，相关性却可能不太强。</li>
<li>多参考大牛们的网站</li>
</ol>
<p>不建议你“未雨绸缪”的打上标签。而是在有一定数量的笔记有大量相同性时，再打上标签，目录也是如此。</p>
<p>遵循这么一个原则：想一下读者看了这篇文章后，还会对哪些其他的文章感兴趣，然后这些文章就都添加上同一个标签。这样标签就可以实现目录交叉</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html">利用swiftype为hexo添加站内搜索v2.0</a></p>
<p>swiftype 试用结束后，只能付费。免费试用期到期后，官网登录之后无论点击哪里都是“Your Swiftype free trial has come to an end” 页面，猜测 swiftype 不再提供免费版本，<a href="https://github.com/iissnan/hexo-theme-next/issues/841">佐证</a>。需要寻找备案了……</p>
<p><a href="https://www.sqlsec.com/2017/12/hexosearch.html">使用本地搜索</a>，安装插件（需要相应的配置项）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h1 id="过程也是结果"><a href="#过程也是结果" class="headerlink" title="过程也是结果"></a>过程也是结果</h1><p>在整理笔记的时候肯定会从网上查找资料，每个知识点肯定都会碰到一篇帖子让自己感慨“哇，总结得好好，娓娓道来，该讲的都讲到了，却也不多一句废话”，每每到此刻都觉得自己整理的笔记就是一坨垃圾，用词不当，表述不清晰，上下文转接不流畅，有的重点落下没讲，废话说太多……可这就是<strong>成长必经的过程</strong>，如果不是整理这个知识点，就不会一板一眼、较真地去查阅好多资料，线上的博客、线下的书，随手 google 来的终究只是编码过程中的 code demo，而非知识，只有当你读了很多篇笔记，看过了很多风景，才能有足够的理解，才能通过已经掌握的，通过对比，认识到某一篇是够精彩的。</p>
<p>如果因为总结的笔记太烂而气馁，放弃整理，那么就不会查阅足够的资料，就不会见到那篇“哇，精彩”的帖子！整理出来的笔记是结果，整理过程中见到的风景也是结果！</p>
<p><strong>ps：</strong>在 2017/4/28 10:13:43  之前的文章大多是从 <a href="http://www.wiz.cn/">为知笔记</a> 中手动迁移出来的。</p>
<ul>
<li>源于为知笔记不支持账号销户，所以也就没有清空其中的内容，暂时保留一段时间还可以校正迁移过程中的失误；</li>
<li>但在文章全部迁移完毕之后也就不再使用为知笔记了，因为它 <a href="https://www.zhihu.com/question/53429669">变更服务策略</a> 太激进了。</li>
</ul>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Markdown 注意事项</title>
    <url>/2016/06/13/writing2/</url>
    <content><![CDATA[<p>分为语法和工具两个部分，备忘录。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在使用 JotterPad（CommonMark）阅读 markdown 格式的文本时，发现的细节：</p>
<ol>
<li><p>标题 <code>#</code> 后需要有空格，才能解析成标题，不然就是文本；【重要】</p>
<ul>
<li>进一步修正：任意级别的标题行前后添加空行，至少标题行之前要有空行，<code>#</code> 之后添加空格；</li>
</ul>
</li>
<li><p>使用参考式链接时，链接网址只能放在文件最末尾，不然识别不出来；【重要】</p>
</li>
<li><p>引用内使用编号问题：</p>
<blockquote>
<p>引用文字</p>
<ol>
<li>item1</li>
<li>item</li>
</ol>
<p>编号结束，结尾的引用文字</p>
</blockquote>
</li>
<li><p>怎么写代码块？——是解析的，只不过呈现方式只体现在字体上，排版效果并不明显。</p>
</li>
<li><p><del>尽量不要嵌套使用。在 GitHub 上项目的 README.md 都不复杂。占一屏幕，不需要滚屏。</del> 建议很值得采纳，但实在是不实用。</p>
</li>
<li><p>可以做图片链接的哦，惊喜</p>
</li>
<li><p><del>嵌套时无需有空行（分段需求除外，比如引用时），当两个模块是平行关系时需要有空行（列表除外，列表项之间添加空行会引入 &lt;p&gt;）。参考 1.1 节</del></p>
</li>
<li><p>中英文混合排版加不加空格问题，持保留态度，无论加或者不加，都保持原状。</p>
<ol>
<li><p>强调语义，不加；强调呈现，添加。</p>
</li>
<li><p>书写笔记不考虑纯手工补充空格，为了表现效果美观<strong>吹毛求疵</strong>，时间成本太高，没有意义。【重要】</p>
<p>扩展阅读：</p>
</li>
</ol>
<ul>
<li><a href="http://www.geekpark.net/topics/198213">不仅仅是空格的问题——再谈中西文混排</a></li>
</ul>
</li>
<li><p>测试 item</p>
</li>
</ol>
<h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><p>模块之间的嵌套使用，怎么书写是规范的一直是一件比较困惑的事情。但在我写下这篇文字的时候，我已经感觉到胜利在朝我招手了。</p>
<p>首先一定要有意识区分“块元素（Block Element）”和“Span Element”，对于熟悉 html 的程序员来说可能是很 easy 的一件事情，但是虽然我用 Markdown 两三个月，相关的操作手册、语法说明也看了很多，但我是自动过滤这两个单词的，讲解标题（用不同数目的 # 区分标题级别）和强调（用 * 斜体，** 加粗）时肯定是分别放在 Block Element 和 Span Element 中介绍，但我脑子里是没有这两个概念的，我并未意识到它们意味着什么，甚至并未意识到它们的存在。我真的是个前端白痴，原谅我。</p>
<ol>
<li><p>块元素（Block Element）包括：</p>
<ul>
<li>标题</li>
<li>引用</li>
<li>列表，注意是整个列表，而不是列表的 item</li>
<li>代码块</li>
<li>分割线</li>
</ul>
</li>
<li><p>Span Element 包括：</p>
<ul>
<li>链接</li>
<li>强调</li>
<li>代码</li>
<li>图片</li>
</ul>
</li>
</ol>
<p>块元素是涉及嵌套的主体！Span Element 不是。所以嵌套问题是块元素的嵌套问题，额，如果我了解 html 多好。</p>
<h2 id="结论（针对-GFM）"><a href="#结论（针对-GFM）" class="headerlink" title="结论（针对 GFM）"></a>结论（针对 GFM）</h2><p><strong>秘籍：</strong>（在严格坚持第一点的基础上，除却以下情况不会用到第二点：如果问题出现在章节末尾（见本文末尾）、列表末尾，使用第二点）</p>
<ol>
<li><p>每个独立的块元素（包括分段）之后留有空行，标题、分割线可以除外；</p>
</li>
<li><p>哪个块元素解析有问题，就在哪个块元素之前加空行；</p>
<ol>
<li>为了保证一致性（特殊情形，即当前嵌套情形（列表主体除末尾空行无其他空行，且在末尾嵌套有子列表）），要求嵌套子列表时，子模块前添加空行（即本行之前的空行，否则解释时不完美）；</li>
</ol>
</li>
<li><p>综合上述两点，在每个块元素（包括分段）的前后添加空行可以保证所有情形下解释正确。唯一的不足在于阅读源文本时可能稍显松散。</p>
</li>
<li><p>其实，在每个块元素（包括分段、标题、分割线）之前留有空行是不是就万事大吉了呢？【重要】</p>
</li>
</ol>
<p><strong>详细描述：</strong></p>
<ol>
<li><p>分段用空行，这句是废话；</p>
</li>
<li><p>标题之前加空行，保证所有情况下语法正常解释；【重要】</p>
<ul>
<li>如果前置标题、分割线或者普通段落，则没有空行语法也能正常解释；</li>
<li>如果前置列表、引用等，没有空行，语法解释后呈现有问题；</li>
</ul>
</li>
<li><p>空行意味着引用、列表的结束；标题、分割线是单行的；GFM 中代码块是 ``` 结束的。多个空行合并成一个。</p>
<ul>
<li>分段时，空行意味着段落的结束；</li>
<li>非分段情况下，段落之后不用跟空行。接标题、引用、<del>列表、</del>代码块都意味着段落结束。</li>
<li>非分段情况下，段落之后无空行直接跟有序列表，是有问题的；直接跟无序列表没问题；</li>
<li>综合上述三条，建议每个独立的块元素之后留有空行，标题、分割线除外【重要】</li>
</ul>
</li>
<li><p>列表内容拥有缩进概念；</p>
<ul>
<li>列表 item 中缩进内容（针对引用、代码块）前（或者后）加空行；否则语法无法正常解释</li>
<li>缩进内容为列表（即嵌套子列表）时，按照规则建议添加空行。即使无空行，语法也能正常解释，看着还顺眼一点</li>
<li>综合上述两条，建议在嵌套子模块的结尾留有空行【重要】</li>
</ul>
</li>
</ol>
<p>补充说明：</p>
<ol>
<li><p>列表的 item 之间一般不需要空行（分段除外），如果</p>
<blockquote>
<p>如果列表项之间有空行，markdown会给每一个生成的li元素创建一个p:</p>
</blockquote>
</li>
</ol>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>前两年一直使用的 MarkdownPad2，后来随着系统更新（而软件并未跟进）出现了几项功能性问题，虽然也能通过某些手段结局，但无疑是影响体验的。</p>
<p><a href="https://www.jianshu.com/p/40eb4f8207d1" title="MarkdownPad 2 使用问题">MarkdownPad 2 使用问题</a></p>
<p>在此基础上，由于对 Visual Studio Code 好奇心（喜新厌旧嘛），放弃了使用 MarkdownPad2，但回头再看（2020/12/25 17:38:28 ）前者也只那些 vimer 的狂欢，经过各种调教之后可能好用，但调教本身也是成本。</p>
<blockquote>
<p>快捷键支持并不完全。还是算了。<a href="https://lanlan2017.github.io/blog/11f888fa/">来源</a></p>
</blockquote>
<p>深有感触，不胜其烦。所以又回归了 MarkdownPad2</p>
]]></content>
      <tags>
        <tag>memo</tag>
      </tags>
  </entry>
  <entry>
    <title>XX 笔记，这些应用怎么用？</title>
    <url>/2017/04/17/xxnote/</url>
    <content><![CDATA[<p>2016/1/19 14:35:09</p>
<p>链接内容可以慢慢看，稍后放链接。重点想说以下观点： </p>
<blockquote>
<p>有这样的一个故事：旱鸭子想学游泳，哦，游泳需要游泳衣，游泳还需要游泳帽，游泳还需要潜水镜。然后搜索了各种培训班，还在视频网站上看了各种教学视频，欣赏了奥运冠军的优美泳姿——最终一个夏天过去了，旱鸭子仍然还是旱鸭子。</p>
</blockquote>
<a id="more"></a>

<p>很多人在开始一件事之前都会有这样的问题，所以要提醒的是，<strong>不要把手段当成目的</strong>。使用这类工具时，尽管挑好一个就可以，其实使用各种巩固大家的使用方法都是大同小异的，只是根据个人喜好。</p>
<p>工具综合症和资料收集狂——引以为戒。</p>
<p>知乎话题：</p>
<ul>
<li><a href="https://www.zhihu.com/topic/19831475">Evernote 使用技巧</a></li>
<li><a href="https://www.zhihu.com/question/20094873">如何协调印象笔记（Evernote）的「标签」和「笔记本」整理笔记？</a></li>
<li><a href="https://www.zhihu.com/question/20066940">Evernote的tag功能如何使用最有效？</a></li>
<li>另外，<a href="https://www.zhihu.com/question/21482266">为知笔记（Wiznote）有什么使用心得或技巧？</a></li>
</ul>
<p>所以，既然已经在用印象笔记（个人生活）和为知笔记（专业知识），那么以下帖子就不重要了：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20784991">Evernote、麦库、有道云笔记、天天记事、为知笔记、易趣记事本哪个好？</a></li>
<li><a href="https://www.zhihu.com/question/20227618">印象笔记（Evernote）好用吗？</a></li>
</ul>
<p>2016/3/23 9:25:04 补充</p>
<p>这些工具目前的核心定位无外乎在线笔记、知识管理，或者兼而有之。所以掌握在线笔记是怎么回事，知识管理又是什么才是关键。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>试验虚拟机安装黑群晖</title>
    <url>/2020/12/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%BB%91%E7%BE%A4%E6%99%96/</url>
    <content><![CDATA[<p>安装 VMware workstation 15 player 时，提示</p>
<blockquote>
<p>VMware workstation 15 player 和 Hyper-V 在此版本的 windows 上不兼容。<br>请从系统中移除 hyper-v 角色或将 windows 更新到 windows 10 版本 20H1。</p>
</blockquote>
<p>我选择了在“启用或关闭 windows 功能”中关闭 Hyper-V，需要重启。后续启动虚拟机的时候还是报错：</p>
<blockquote>
<p>您的主机不满足在启用 Hyper-V 或 Device/Credential Guard 的情况下运行 VMware Workstation 的最低要求。</p>
</blockquote>
<a id="more"></a>

<p>参考帖子 ：<a href="https://blog.csdn.net/qq_36761831/article/details/81175736%EF%BC%8C">https://blog.csdn.net/qq_36761831/article/details/81175736，</a> 重启生效。</p>
<p><strong>引导文件</strong></p>
<p><a href="https://xpenology.club/downloads/%EF%BC%8C">https://xpenology.club/downloads/，</a> .img 格式</p>
<p><strong>刷引导的工具</strong></p>
<p>Roadkil’s Disk Image ，将 .img 格式刷入虚拟磁盘供 vm 使用</p>
<p>（未验证）或者使用 StarWind V2V Image Converte 转换引导的.img文件到VM disk形式，直接被 vm 使用</p>
<h1 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h1><p>nothing</p>
<h2 id="网关是什么"><a href="#网关是什么" class="headerlink" title="网关是什么"></a>网关是什么</h2><blockquote>
<p>A gateway is a piece of networking hardware used in telecommunications for telecommunications networks that allows data to flow from one discrete network to another.</p>
<p>使数据在两个离散的网络之间通信的硬件设备：回顾历史，早期的电话网络肯定是离散的，且各自很可能使用了不同的协议，彼此间要完成通信，就需要某种转换的设备。<del>好像早期的局域网协议和互联网协议也是不同的，我忘记在哪里看到的</del></p>
<p>Gateways are distinct from routers or switches in that they communicate using more than one protocol to connect a bunch of networks and can operate at any of the seven layers of the open systems interconnection model (OSI).</p>
<p>到底不同在哪里呢？</p>
<p>The term gateway can also loosely refer to a computer or computer program configured to perform the tasks of a gateway, such as a default gateway or router.</p>
<p>默认网关或软路由</p>
</blockquote>
<ul>
<li>gate 大门， gateway</li>
<li>route 路线 -&gt; router</li>
<li>switch 开关</li>
</ul>
<p>网关的概念早于路由的概念，路由是特化（限于现在的 OSI 框架内）的、扩展了功能（除了网络边界的大门，还有路线规划）的网关。 路由还集成了交换机、动态域名分配和防火墙等功能。</p>
<h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><ul>
<li>第七层，应用层。例如 HTTP SSH POP3 等</li>
<li>第六层，表达层</li>
<li>第五层，会话层</li>
<li>第四层，传输层。例如 传输控制协议 TCP</li>
<li>第三层，网络层。例如 互联网协议 IP ICMP(ping)</li>
<li>第二层，数据链路层。例如 arp</li>
<li>第一层，物理层</li>
</ul>
<p>OSI 模型只是一个定义良好的协议规范集，并没有提供实现的方法。不是一个标准，而是在制定标准时所使用的的概念性框架。</p>
<p>TCP/IP 协议栈，是与 OSI 模型有类似结构的现行网络模型。它将软件通信抽象化为四个抽象层：</p>
<ul>
<li>应用层，HTTP 等</li>
<li>传输层，TCP 等</li>
<li>网络互连层，IP 协议</li>
<li>网络访问（链接）层，例如以太网、WiFi 等</li>
</ul>
<p>ARP是通过网络地址来定位MAC地址。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP 地址是以网络号和主机号来标示网络上的主机的，比如 <code>172.16.10.0/24</code> 所表示的一个子网前 24 个 bits 表示网络号，后 8bits 表示主机号，该子网的IP地址的范围是 172.16.10.0-172.16.10.255。网络号为相同子网，同子网的主机可以直接相互通信；不同子网须通过本地网关（Gateway）经由路由器来转发数据。</p>
<p>子网掩码并不局限于整数个八位位组的情况。</p>
<p>从 <a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C">分类网络</a> 到 <a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1">无类别域间路由 CIDR</a>，前者三类地址的子网掩码分别是 <code>/8</code> <code>/16</code> <code>/24</code>，后者基于可变长子网掩码。</p>
<blockquote>
<p>可变长子网掩码（VLSM）和 CIDR 是相同的概念，不过一般只在历史上使用。</p>
</blockquote>
<h2 id="集线器、交换机和路由器"><a href="#集线器、交换机和路由器" class="headerlink" title="集线器、交换机和路由器"></a>集线器、交换机和路由器</h2><p>回顾历史，在时间轴上用发展的视角理解这些硬件。</p>
<ul>
<li>集线器，数据帧被广播到它的每个端口。数据帧不需要 mac 地址和 ip 地址。</li>
<li>交换机，使用 mac 地址进行识别。数据帧需要包含 mac 地址（源和目标），不需要 ip 地址。交换机维护“端口：MAC地址”的映射表。</li>
<li>路由器，依赖 ip 完成功能。数据帧需要包含 ip 地址（源和目标）</li>
</ul>
<ol>
<li><p>保留的三个地址段分别位于 A、B、C 三类地址内，如何使用？</p>
<ul>
<li>A类地址：10.0.0.0–10.255.255.255</li>
<li>B类地址：172.16.0.0–172.31.255.255</li>
<li>C类地址：192.168.0.0–192.168.255.255 <a href="https://blog.csdn.net/superit401/article/details/78246298">来源</a></li>
</ul>
</li>
<li><p>北分这里很明显是使用到了 B、C 两层的私有地址：172.18.3.x 和 192.168.1.x，如何配置能够上网呢</p>
</li>
<li><p>内外网联通，是通过什么技术手段？NAT 吗</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>Makefile 入门</title>
    <url>/2016/09/18/Makefile1st/</url>
    <content><![CDATA[<p>原来的笔记写于 2015年11月23日，当时使用的是为知笔记默认编辑器。十个月过去了，对于 make &amp; Makefile 也有了更多的认识。今天重新整理一下，不过仍然定位在<strong>入门的帖子</strong>，所以不会添加新的内容，只是修改表述不当的地方，对原有内容作出删减，并用 markdown 格式重写。</p>
<p><strong>这篇本来是打算写成阅读笔记的。但是所知不多，刚开始学习应该博览，求入门，求上手使用。再加上看的东西越来愈多，单纯的记录一篇帖子中的重点、难点，较真于一处在实践中基本不会碰到的细节，格局太小，意义也不大。</strong></p>
<a id="more"></a>

<p>在正式讲解之前，我们先介绍一下使用的文件：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn/example$ tree</span><br><span class="line">.</span><br><span class="line">└── prj</span><br><span class="line">    ├── abc.c</span><br><span class="line">    ├── abc.h</span><br><span class="line">    ├── main.c</span><br><span class="line">    ├── xyz.c</span><br><span class="line">    └── xyz.h</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn/example$ </span><br></pre></td></tr></table></figure>
<p>其中 <code>main.c</code> 包含头文件 <code>abc.h</code> 和 <code>xyz.h</code>，<code>abc.c</code> 包含头文件 <code>abc.h</code>，<code>xyz.c</code> 包含头文件 <code>xyz.h</code>。</p>
<h1 id="完整的手写-Makefile"><a href="#完整的手写-Makefile" class="headerlink" title="完整的手写 Makefile"></a>完整的手写 Makefile</h1><p>明明白白、完完整整地写 Makefile 文件，是这个样子的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o abc.o xyz.o</span></span><br><span class="line">        gcc main.o abc.o xyz.o -o main</span><br><span class="line">        </span><br><span class="line"><span class="section">main.o: main.c abc.h xyz.h</span></span><br><span class="line">        gcc -c -o main.o main.c</span><br><span class="line">        </span><br><span class="line"><span class="section">abc.o: abc.c abc.h</span></span><br><span class="line">        gcc -c -o abc.o abc.c</span><br><span class="line">        </span><br><span class="line"><span class="section">xyz.o: xyz.c xyz.h</span></span><br><span class="line">        gcc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure>
<p>但事实上，我们在实际项目中并不这样写。从例子可以看到其中有相似的重复的操作，而当代码文件增加几倍后，管理这些重复的命令将会是“费力不讨好”的事情。好在 Makefile 提供了隐含规则和自动推导帮我们“省力”。</p>
<h1 id="隐含规则和自动推导"><a href="#隐含规则和自动推导" class="headerlink" title="隐含规则和自动推导"></a>隐含规则和自动推导</h1><p>我们可以将以上的 Makefile 文件写得更简单，但功能相同：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">main:   abc.o xyz.o</span></span><br><span class="line"><span class="section">main.o: abc.h xyz.h</span></span><br><span class="line"><span class="section">abc.o:  abc.h</span></span><br><span class="line"><span class="section">xyz.o:  xyz.h</span></span><br></pre></td></tr></table></figure>
<p><code>CC</code> 是 Makefile 的预定义变量之一，用于指定编译 C 项目时所用编译器。如果我们不指定 <code>CC</code> 变量，则调用其默认值 cc 编译器。这在Linux上没有问题，因为 cc 常常会链接到 gcc 程序。</p>
<p>Makefile 预定义变量用于隐含规则生成的每条编译命令中，所以只要为这些预定义变量指定新的值，就可以改变隐含规则的默认动作。除了 <code>CC</code> 之外，常用的还有 <code>CFLAGS</code> <code>CPPFLAGS</code> <code>LDLIBS</code> <code>LDFLAGS</code> 等等。</p>
<p>这个 Makefile 文件只描述了<em>部分</em>依赖关系，源文件的编译命令和目标文件的链接命令也都被省略了。这正是 Makefile 的<strong>自动推导</strong>功能：它可以将目标文件自动依赖于同名的源文件（可执行文件自动依赖于同名的目标文件或源文件），根据扩展后的依赖关系使用<strong>隐含规则</strong>生成目标文件。所以其功能完全等价于第一节中我们完整手写的 Makefile 文件。</p>
<h2 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以:</p>
<ol>
<li>在你的 makefile 中改变这些变量的值，</li>
<li>或是在 make 的命令行中传入这些值，</li>
<li>或是在你的环境变量中设置这些值，</li>
</ol>
<p>无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用 make 的“-R”或“–no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，编译 C 程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以 “gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相关的，如“CFLAGS”。在此只描述最常用的几个变量，更多的请移步 <a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">Variables Used by Implicit Rules</a>。</p>
<ol>
<li><p>关于命令的变量。</p>
<ul>
<li><code>AR</code>  函数库打包程序。默认命令是“ar”。</li>
<li><code>CC</code>  C 语言编译程序。默认命令是“cc”。</li>
<li><code>CXX</code> C++ 语言编译程序。默认命令是“g++”。</li>
<li><strong>CPP</strong>（the C preprocessor，C P re P rocessor） C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</li>
<li><code>RM</code>  删除文件命令。默认命令是“rm –f”。</li>
</ul>
</li>
<li><p>关于命令参数的变量：如果没有指明其默认值，那么其默认值都是空。 </p>
<ul>
<li><p><code>ARFLAGS</code>  函数库打包程序 AR 命令的参数。默认值是“rv”。</p>
</li>
<li><p><code>CFLAGS</code>  C 语言编译器参数。</p>
</li>
<li><p><code>CXXFLAGS</code>  C++ 语言编译器参数。</p>
</li>
<li><p><code>CPPFLAGS</code>  C 预处理器参数。（ C 和 Fortran 编译器也会用到）。</p>
<blockquote>
<p>CPPFLAGS<br>Extra flags to give to the C preprocessor and programs that use it (the C and Fortran compilers).</p>
</blockquote>
</li>
<li><p><code>LDFLAGS</code>  链接器参数。（如：“ld”）</p>
<blockquote>
<p>LDFLAGS<br>Extra flags to give to compilers when they are supposed to invoke the linker, ‘ld’, such as -L. Libraries (-lfoo) should be added to the LDLIBS variable instead.</p>
</blockquote>
</li>
<li><p><code>LDLIBS</code></p>
<blockquote>
<p>Library flags or names given to compilers when they are supposed to invoke the linker, ‘ld’. LOADLIBES is a deprecated (but still supported) alternative to LDLIBS. Non-library linker flags, such as -L, should go in the LDFLAGS variable.</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>有几组容易混淆的变量，需要重点区分：</p>
<ol>
<li><p>区分 <code>CFLAGS</code> <code>CXXFLAGS</code> <code>CPPFLAGS</code>：</p>
<p> 首先 CPPFLAGS 作用于预处理器 CPP，所以能够同时用于 c代码和c++代码，eg <code>-I./</code>；CFLAGS CXXFLAGS 作用于编译器，分别针对C 编译器器、C++编译器，eg <code>-g --std=c++11</code>。编译器参数并不会传给链接器使用。</p>
</li>
<li><p>区分 <code>LDFLAGS</code> 和 <code>LDLIBS</code>：</p>
<p> LDFLAGS 告诉链接器从哪里寻找库文件，LIBS 告诉链接器要链接哪些库文件，eg <code>-L ../ -lpthread</code>。</p>
</li>
</ol>
<h1 id="自动生成依赖关系"><a href="#自动生成依赖关系" class="headerlink" title="自动生成依赖关系"></a>自动生成依赖关系</h1><p>此节参考自：<a href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch22s04.html">自动处理头文件的依赖关系</a></p>
<p>上一节中如果不添加目标文件对头文件的依赖关系，如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">main:abc.o xyz.o</span></span><br></pre></td></tr></table></figure>
<p>导致的直接问题就是：修改项目的头文件之后，执行 <code>make</code> 命令不会自动更新可执行文件。（在这半年多时间里，我写的 Makefile 大多都缺少针对头文件的依赖关系）</p>
<p>可是在写 main.o、abc.o 和 xyz.o 这三个目标的规则时要查看源代码，找出它们依赖于哪些头文件，这很容易出错，一是因为有的头文件包含在另一个头文件中，在写规则时很容易遗漏，二是如果以后修改源代码改变了依赖关系，很可能忘记修改 Makefile 的规则。</p>
<p>能不能让 make &amp; Makefile 帮我们做了这个工作？很不幸，不能。Makefile 的自动推导依赖<strong>同名</strong>，从源文件到目标文件到可执行文件。而且一个源文件往往依赖很多个头文件，所以 Makefile 无法帮我们做自动依赖。必须由我们来告诉 Makefile 详细的依赖关系。好在我们可以用 gcc 的 <code>-M</code> 选项自动生成目标文件和源文件的依赖关系，然后把这些规则包含到 Makefile 中。</p>
<p><code>-M</code> 选项把 stdio.h 以及它所包含的系统头文件也找出来了，如果我们不需要输出系统头文件的依赖关系，可以用 <code>-MM</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/make_learn/example/prj$ gcc -MM main.c </span><br><span class="line">main.o: main.c abc.h xyz.h</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn/example/prj$ gcc -MM *.c</span><br><span class="line">abc.o: abc.c abc.h</span><br><span class="line">main.o: main.c abc.h xyz.h</span><br><span class="line">xyz.o: xyz.c xyz.h</span><br><span class="line">vimer@debian8light:~/see-the-world/code/make_learn/example/prj$ </span><br></pre></td></tr></table></figure>
<p>把 <code>gcc -MM</code> 自动生成的规则包含到 Makefile 中，<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">GNU make的官方手册 - Generating Prerequisites Automatically</a> 建议这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">TARGET=main</span><br><span class="line">SRCS=main.c abc.c xyz.c</span><br><span class="line"><span class="comment">#SRCS=$(wildcard *.c)</span></span><br><span class="line">OBJS=$&#123;SRCS:.c=.o&#125;</span><br><span class="line">DEPS=$&#123;SRCS:.c=.d&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:$&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;TARGET&#125;:$&#123;OBJS&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        $&#123;RM&#125; $&#123;TARGET&#125; $&#123;OBJS&#125; $&#123;DEPS&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动生成依赖关系</span></span><br><span class="line"><span class="keyword">include</span> $&#123;DEPS&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.c </span></span><br><span class="line">        set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">        <span class="variable">$(CC)</span> -MM <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">        sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ : ]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">        rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<p><code>$&#123;SRCS:.c=.d&#125;</code> 表示将 SRC 中的以 <code>*.c</code> 结尾的源文件名替换为 <code>*.d</code> 的形式，比如 main.c 对应着文件 main.d，这就是 main.c 的依赖关系文件。<del>也可以替换成 <code>.*.d</code> 的形式用来隐藏文件。</del></p>
<p><code>.PHONY</code> 伪目标的概念请移步下一节了解。</p>
<p>为了生成每个源文件的依赖文件，建立了目标依赖关系 <code>%.d: %.c</code>，该关系表示，对于目标集合，通过 <code>$@</code> 可以访问一个依赖文件，通过 <code>$&lt;</code> 则访问对应的同名源文件。其他更多的语法特性请自行 google 学习。</p>
<p>将该文件应用于任何单目录的 C/C++ 工程（C++ 需要修改部分细节，不作赘述）都能正常工作。</p>
<h2 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h2><p>前者针对每个源文件单独生成对应的依赖文件，而下面是将所有的依赖规则放到了一个文件中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">EXE=main</span><br><span class="line">CC=gcc</span><br><span class="line">SRCS=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#如果看不懂，自行google</span></span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line">CFLAGS=-g</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all </span></span><br><span class="line"><span class="section">all: <span class="variable">$(EXE)</span></span></span><br><span class="line"><span class="comment">#all: $(EXE) .depend #这种写法没有意义。详见“include调用方式&amp;Makefile执行过程”</span></span><br><span class="line"></span><br><span class="line"><span class="section">.depend: <span class="variable">$(SRCS)</span> </span></span><br><span class="line">        @<span class="variable">$(CC)</span> -MM <span class="variable">$(SRCS)</span> &gt; .depend</span><br><span class="line">        </span><br><span class="line"><span class="keyword">-include</span> .depend <span class="comment">#和其它版本 make 兼容的相关命令是 sinclude</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(EXE)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean   </span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm <span class="variable">$(EXE)</span> <span class="variable">$(OBJS)</span> .depend -f</span><br></pre></td></tr></table></figure>
<p>网上有 <a href="http://blog.csdn.net/duanbeibei/article/details/2910845">一种模棱两可的说法</a>，认为此种方式是过时的，被淘汰的。原因是在 <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">Generating Prerequisites Automatically</a> 中有如下描述：</p>
<blockquote>
<p>With old make programs, it was traditional practice to use this compiler feature to generate prerequisites on demand with a command like ‘make depend’. That command would create a file depend containing all the automatically-generated prerequisites; then the makefile could use include to read them in.</p>
<p>In GNU make, the feature of remaking makefiles makes this practice obsolete（废弃的；过时的）—you need never tell make explicitly to regenerate the prerequisites, because it always regenerates any makefile that is out of date.</p>
</blockquote>
<p>我一开始被误导，先入为主也认为此种方法不合适。然而始终未明白此方法哪里不好。</p>
<ol>
<li><p>官方手册 <a href="https://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html">How Makefiles Are Remade</a>；</p>
<blockquote>
<p>after reading in all makefiles, make will consider each as a goal target and attempt to update it. If a makefile has a rule which says how to update it (found either in that very makefile or in another one) or if an implicit rule applies to it (see Using Implicit Rules), it will be updated if necessary. After all makefiles have been checked, if any have actually been changed, make starts with a clean slate and reads all the makefiles over again. (It will also attempt to update each of them over again, but normally this will not change them again, since they are already up to date.)</p>
</blockquote>
</li>
<li><p>另外，<a href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch22s04.html">自动处理头文件的依赖关系</a> 中描述：</p>
<blockquote>
<p>不管是Makefile本身还是被它包含的文件，只要有一个文件在make过程中被更新了，make就会重新读取整个Makefile以及被它包含的所有文件</p>
</blockquote>
</li>
<li><p>我自己也另有笔记 <a href="/2017/04/26/Makefile3rd/">《Makefile 执行过程 &amp; include 调用方式》</a></p>
</li>
</ol>
<p>仔细阅读上述3个链接之后，我认为：两种方式并无本质区别，是一样的。官方手册中提及的“obsolete”是针对以前的非 GNU make 的 make 版本，“old make programs” 和 GNU make 的一个显著区别是不会 “remaking makefiles”。即 include 操作只会单纯的包含目标文件进来，而不关心其内容是否是待更新的（即，在 include 之后其目标更新了），所以“old make programs” 总是要先手动执行 <code>make depend</code> 保证依赖文件是最新的，然后再执行 <code>make</code> 命令。区别是由 “old make programs” 和 GNU make 带来的，而不是上述两种书写方式带来的。</p>
<h1 id="更多的特性"><a href="#更多的特性" class="headerlink" title="更多的特性"></a>更多的特性</h1><p>Makefile 文件最核心的内容就是上面这些。但是为了使用上方便，扩展更多的功能，比如 <code>make clean</code> <code>make install</code>，Makefile 文件的包含引用 <code>include</code> 等等，延伸出来了好些东西。有些特性作为惯例、最佳实践被开发者普遍使用。</p>
<h2 id="PHONY-伪目标"><a href="#PHONY-伪目标" class="headerlink" title=".PHONY 伪目标"></a>.PHONY 伪目标</h2><p>开发过程中肯定有清理目标文件、可执行文件的需求，但是频频使用 <code>rm abc.o xyz.o main.o main</code> 命令手工删除不是我们风格。所以就有</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm abc.o xyz.o main.o main</span><br></pre></td></tr></table></figure>
<p>我们直接执行 <code>make clean</code> 就可以达到清理目录的目的。但这么写有两个问题：</p>
<ol>
<li>当某个删除目标不存在时 <code>rm</code> 就会执行失败，进而 <code>make</code> 报错执行 <code>clean</code> 目标失败。为了规避此问题，我们使用 <code>rm -f</code>，与此等价的 Makefile 预定义变量是 <code>$&#123;RM&#125;</code>。</li>
<li>如果目录下存在 clean 同名文件，因为 clean 不存在依赖目标，所以 clean 就是最新的，就不会再执行 <code>rm -f</code> 命令。此问题的解决方法是：将 clean 声明为 <code>.PHONY</code> 伪目标。</li>
</ol>
<p>为了偷懒，不用在多个地方重复修改，我们引入 <code>$&#123;TARGET&#125;</code> <code>$&#123;OBJS&#125;</code>变量。按照惯例，用 <code>all</code> 做缺省目标。Makefile 文件变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">TARGET=main</span><br><span class="line">OBJS=main.o abc.o xyz.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:$&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;TARGET&#125;:$&#123;OBJS&#125;</span></span><br><span class="line"><span class="section">main.o:abc.h xyz.h</span></span><br><span class="line"><span class="section">abc.o: abc.h</span></span><br><span class="line"><span class="section">xyz.o: xyz.h</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        $&#123;RM&#125; $&#123;TARGET&#125; $&#123;OBJS&#125;</span><br></pre></td></tr></table></figure>
<h2 id="include-和-sinclude"><a href="#include-和-sinclude" class="headerlink" title="include 和 sinclude"></a>include 和 sinclude</h2><p>Makefile 中 <code>include</code> 的调用方式：（详见 <a href="/2017/04/26/Makefile3rd/">《Makefile 执行过程 &amp; include 调用方式》</a>）</p>
<ol>
<li>首先在指定的目录下搜索被调用文件（如果没有路径，则为当前目录）</li>
<li>如果没有找到，则从 <code>-I</code> 所指定的 include 目录查找，如果还没找到，则从 <code>/usr/gnu/include</code> <code>/usr/local/include</code> 等目录查找</li>
<li>最终结果还是没找到，则 Makefile 输出异常信息 <code>No such file or directory</code>。<strong>但此时不会立刻退出</strong>，而是继续处理 Makefile 的后续内容</li>
<li>当完成读取整个 Makefile 后，make 将试图使用规则来创建通过指示符 <code>include</code> 指定的但未找到的文件</li>
<li>如果没有对应规则，输出错误信息 <code>make: *** No rule to make target &#39;non-exit-file&#39;.  Stop.</code>。Makefile终止执行</li>
</ol>
<p>通常我们在 Makefile 中可使用 <code>-include    </code> 来代替 <code>include</code>，来忽略由于包含文件不存在或者无法创建时的错误提示。<code>-</code> 的意思是告诉 make，忽略此操作的错误，继续执行。</p>
<p><code>include</code> 会报错导致 make 终止执行；<code>-include</code> 不会终止 make 的执行；而为了进一步和其它的 make 程序进行兼容，也可以使用 <code>sinclude</code> 来代替 <code>-include</code>。综合以上，优先使用 <code>sinlude</code>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>用 make 命令加 <code>-p</code> 选项后，可以打印出系统缺省定义的内部规则。它们包括系统预定义的宏、以及产生某些种类后缀的文件的内部相关行。内部规则涉及的文件种类很多，它不仅包括 C 源程序文件及其目标文件，还包括 SCCS 文件、yacc 文件和 lex 文件，甚至还包括 Shell 文件。</p>
<p>注意 gmake 和 make 的区别：</p>
<blockquote>
<p>gmake 是GNU Make的缩写。 Linux系统环境下的 make 就是 GNU Make，之所以有 gmake，是因为在别的平台上，make 一般被占用，GNU make 只好叫 gmake 了。 <a href="http://blog.csdn.net/chenglian_999/article/details/4655117">引用来源</a></p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过前边的讨论，我们得到一个能在<strong>单目录工程</strong>下工作的通用 Makefile，至于是实现为单独一个依赖文件的形式，还是每个源文件产生一个独立的依赖文件，要根据程序作者自己的喜恶来选择。虽然每种方法都有一些细微的瑕疵，但是不影响这个通用的 Makefile 的实用性，试想一下在工程目录下拷贝一份当前的 Makefile，稍加修改便可以正确的编译开发，一定会令人心情大好。</p>
<p>网上关于 make &amp; Makefile 的入门有很多不错的文章，单篇和系列的都有。整理此篇笔记时也多有参考、摘抄。列举如下：</p>
<ol>
<li>如果之前一点也不了解 make，想快速上手写 makefile 编译小程序。推荐 <a href="http://www.cnblogs.com/luchen927/archive/2012/02/05/2339002.html">《如何自己编写Makefile》</a> 这一篇。★★★</li>
<li>如果想更进一步的学习，则推荐 <a href="http://blog.csdn.net/haoel/article/details/2886/">《 跟我一起写 Makefile》</a> 系列，总共十四篇。具体目录可以下载附件查看，另有此系列汇总的pdf版本，也一并上传在附件中。★★★★★</li>
<li>如果较真于语法，可以查看 <a href="http://www.cnblogs.com/wang_yb/p/3990952.html">Makefile 使用总结</a>，目录也在附件中。可以用来检索，综合来说意义不大。★★</li>
<li>发现一篇很好的帖子，不吐不快。<a href="http://www.cnblogs.com/yyangblog/p/4159778.html">《说说Makefile那些事儿》</a>，重点是看完1、2之后，读这篇帖子还能学到新的东西。★★★★★</li>
</ol>
<p>实际项目中肯定会涉及到复杂的目录结构以及对链接库的使用，在姊妹篇 <a href="https://tnie.github.io/2016/12/09/Makefile2nd/">《不同场景下的 Makefile》</a> （也是入门篇）略有提及。关于链接库更详细的知识请移步 <a href="https://tnie.github.io/2016/12/09/library-static-dynamic/">《共享库 &amp; 静态库》</a>，在大型的项目中手工编写 Makefile 都是一场挑战，Makefile 自动化生成请移步 [《》][/(ㄒoㄒ)/~~ 我还没整理呢]。</p>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 自动生成 - 三种目录结构</title>
    <url>/2017/04/27/automake1st/</url>
    <content><![CDATA[<p>2015年12月22日 14:48:52</p>
<p>这个标题《Makefile 自动生成》 8 号立的，拖到今天刚好两周。ps 2017/8/24 14:04:25 删改了 2/3 的内容，改为现在的标题。</p>
<p>一方面因为最近的工作是关于 MySQL，整理数据库表结构的；另一方面，是直到今天，对于自动生成 Makefile 操作依旧懵懵懂懂，在实际项目中无法使用，还是自己手动写 Makefile 文件。下面进入主题。</p>
<p>Makefile 自动生成，实际项目中接触到的工具有：easymake、cmake 和 autotools。 在这里只整理 autotools。</p>
<ul>
<li>easymake 怎么用，给个简单使用的参考，进一步的细节和更深程度上的使用，以后用到了再学。<a href="http://www.cnblogs.com/Pony279/p/3888774.html">通用的 makefile 小工具分享 - Easymake 使用说明</a>。</li>
<li>cmake 又是值得大书特书的一款工具。<a href="http://www.hahack.com/codes/cmake/">CMake 入门实战</a></li>
</ul>
<p>autotools 作为重点学习，所以发现了很多篇不错的帖子。</p>
<ol>
<li><a href="/2017/08/24/autotools/">编译利器：大型项目如何使用Automake和Autoconf完成编译配置(ver+0.6)</a> 内容很棒，却找不到好的排版，将其摘入自己博客</li>
<li><a href="http://www.pchou.info/linux/2016/09/16/gnu-build-system-1.html">概念：GNU构建系统和Autotool</a>、<a href="http://www.pchou.info/linux/2016/09/24/gnu-build-system-2.html">实践：GNU构建系统</a> 作者整理的真心不错，专业功底、语言描述、文章结构都很赞；</li>
<li><a href="https://geesun.github.io/posts/2015/02/autotool.html">使用autotools生成Makefile学习笔记</a> 不能当做一篇学习的帖子，其“常用功能分析”一节可以作为参考手册，认清知识点</li>
</ol>
<a id="more"></a>

<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>无论是在 Linux 还是在 Unix 环境中，make 都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到 make 或 make install。利用 make 工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用 make 和 makefile 工具就可以轻而易举的理顺各个源文件之间纷繁复杂的相互关系。</p>
<p>但是如果通过查阅 make 的帮助文档来手工编写 Makefile,对任何程序员都是一场挑战。幸而有 GNU 提供的 Autoconf + Automake 这两套工具使得编写 makefile 不再是一个难题。</p>
<p>本文将介绍如何利用 GNU Autoconf + Automake 这两套工具来协助我们自动产生 Makefile 文件，并且让开发出来的软件可以像大多数源码包那样，只需”./configure”, “make”,”make install” 就可以把程序安装到系统中。</p>
<p>以下文字转载自：<a href="http://www.cnblogs.com/ericdream/archive/2011/12/09/2282359.html">运用 Autoconf 和 Automake 生成 Makefile 的学习之路</a> ，原作者的几处笔误已改正，除此之外，<del>重写第七、八、十节，新添第十一节</del> <strong>放弃作者第六、七、八、十节</strong>。这篇帖子的评论也值得一看。</p>
<blockquote>
<p>niel 2017/8/24 8:53:09 补充，再次学习 autotools 时，发现作者写的全都是皮毛。七、八、十节作者纯粹是强行凑字数，估计作者自己就没弄懂——没说到点上不说，好几处地方说的似是而非——初学者看了反而增加学习难度，甚至误入歧途。我在作者基础上重新整理的这三节，当时表述起来就觉得困难，整理完依旧是不清不楚，现在看来根本原因就在于毫无理解，全文都是在介绍表面功夫，一点点原理的东西都没讲。</p>
</blockquote>
<blockquote>
<p>niel 最让人难以忍受的是，看完作者的帖子，你发现你只会例子，做不到举一反三，稍微复杂点的项目（比如使用动态库、配置文件的存放）就无从下手。因为使用 autotools 的关键——怎么编写 configure.ac 和 Makefile.am——作者根本就没讲（没讲明白和没讲等价），从网上滥竽充数的各种帖子里生拉硬拽凑了第七、八、十节，作者自己都不会写 configure.ac、Makefile.am，给我们讲个毛线啊</p>
</blockquote>
<p>网上有很多帖子都参考了 IBM 的例解 <a href="http://www.ibm.com/developerworks/cn/linux/l-makefile/">autoconf 和 automake 生成 Makefile 文件</a>，但相比上面这篇帖子就显得很一般了，只是平台好罢了！</p>
<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>　　<br>makefile 用来定义整个工程的编译规则。一个工程中的源文件计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。<br>　　<br>makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。可见，makefile 都成为了一种在工程方面的编译方法。</p>
<h2 id="Autoconf"><a href="#Autoconf" class="headerlink" title="Autoconf"></a>Autoconf</h2><p>Autoconf 是一个用于生成可以自动地配置软件源码包，用以适应多种UNIX类系统的 shell 脚本（即 configure）工具。由 Autoconf 生成的配置脚本在运行的时候与 Autoconf 是无关的， 就是说配置脚本的用户并不需要拥有 Autoconf。 </p>
<p>对于每个使用了 Autoconf 的软件包，Autoconf 从一个列举了该软件包需要的，或者可以使用的系统特征的列表的模板文件中生成配置脚本。在 shell 代码识别并响应了一个被列出的系统特征之后，Autoconf 允许多个可能使用（或者需要）该特征的软件包共享该特征。 如果后来因为某些原因需要调整 shell 代码，就只要在一个地方进行修改； 所有的配置脚本都将被自动地重新生成以使用更新了的代码。</p>
<h2 id="Automake"><a href="#Automake" class="headerlink" title="Automake"></a>Automake</h2><p>Automake 是一个从 “Makefile.am”文件自动生成 “Makefile.in” 的工具。每个“Makefile.am”基本上是一系列 make 的宏定义 （make 规则也会偶尔出现）。生成的“Makefile.in”服从 GNU Makefile 标准。GNU Makefile 标准文档长、复杂，而且会发生改变。Automake 的目的就是解除个人 GNU 维护者维护 Makefile 的负担 （并且让 Automake 的维护者来承担这个负担）。典型的 Automake 输入文件是一系列简单的宏定义。处理所有这样的文件以创建 “Makefile.in”。在一个项目（project）的每个目录中通常包含一个 “Makefile.am”。Automake 在几个方面对一个项目做了限制；例如它假定项目使用 Autoconf 并且对 “configure.in”的内容施加了某些限制。 </p>
<p><strong>Automake 支持三种目录层次： “flat”、“shallow”和“deep”。</strong></p>
<ul>
<li>一个 flat（平）包指的是所有文件都在一个目录中的包。为这类包提供的“Makefile.am” 缺少宏 SUBDIRS。这类包的一个例子是 termutils。</li>
<li>一个deep（深）包指的是所有的源代码都被储存在子目录中的包；顶层 目录主要包含配置信息。GNU cpio 是这类包的一个很好的例子，GNU tar 也是。deep包的顶层“Makefile.am”将包括宏SUBDIRS，但没有其它定义需要创建的对象的宏。</li>
<li>一个shallow（浅）包指的是主要的源代码储存在顶层目录中，而 各个部分（典型的是库）则储存在子目录中的包。Automake 本身就是这类包（GNU make 也是如此，它现在已经不使用 automake）。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>libtool 是一款方便生成各种程序库的工具。非必须。</p>
<p>下面，就以这三种目录层次结构分别讲解。</p>
<h1 id="Flat-目录结构："><a href="#Flat-目录结构：" class="headerlink" title="Flat 目录结构："></a>Flat 目录结构：</h1><h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Helloworld </span><br><span class="line">|-mytest.h </span><br><span class="line">|-mytest.c </span><br><span class="line">|-mymain.c</span><br></pre></td></tr></table></figure>
<p>顶级目录 helloworld，该目录下存在三个文件。mytest.h 头文件声明了 <code>sayhello()</code> 方法；mytest.c 中实现了 <code>sayhello()</code> 方法；mymain.c 中的 main 调用了 <code>sayhello()</code> 方法。 </p>
<h2 id="执行步骤："><a href="#执行步骤：" class="headerlink" title="执行步骤："></a>执行步骤：</h2><ol>
<li><p>Autoscan </p>
<p> 在 helloworld 目录下执行 autoscan 命令，其中生成一个 configure.scan 的文件。 </p>
</li>
<li><p>将 configure.scan 文件更名为 <del>configure.in</del>（ps 帖子太早，未与时俱进） configure.ac 文件。</p>
</li>
<li><p>打开 <del>configure.in</del> configure.ac 文件，修改文件内容</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line"></span><br><span class="line">#AC_INIT([2.68])</span><br><span class="line">AC_INIT([hello], [1.0], [**@126.com]) # 修改</span><br><span class="line">AC_CONFIG_SRCDIR([mymain.c])</span><br><span class="line">#AC_CONFIG_HEADERS([config.h])  # 注释掉了</span><br><span class="line"></span><br><span class="line">#AM_INIT_AUTOMAKE(hello, 1.0)  # 新增 ps 这种语法已经不推荐使用了</span><br><span class="line">AM_INIT_AUTOMAKE # 参考 autoconf 手册</span><br><span class="line"></span><br><span class="line"># Check for programs</span><br><span class="line">AC_PROG_CC</span><br><span class="line"></span><br><span class="line"># Check for libraries</span><br><span class="line"># Check for header files</span><br><span class="line"># Check for typedefs, structures, and compiler characteristics.</span><br><span class="line"># Check for library functions.</span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile)   # 修改</span><br></pre></td></tr></table></figure></li>
<li><p>然后分别执行以下两个命令： </p>
<ul>
<li>aclocal </li>
<li>autoconf </li>
<li>autoheader（可选，和 AC_CONFIG_HEADERS 宏有关联，此细节【稍后详细描述】【另，注释掉 AC_CONFIG_HEADERS 宏应该是一种不规范的写法】）</li>
</ul>
</li>
<li><p>在 helloworld 文件夹下创建一个名为 Makefile.am 的文件，并输入以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">bin_PROGRAMS&#x3D;hello</span><br><span class="line">hello_SOURCES&#x3D;mymain.c mytest.c mytest.h</span><br></pre></td></tr></table></figure></li>
<li><p>执行命令 <code>automake &lt;--add-missing | -a&gt;</code>，automake 会根据 Makefile.am 文件产生一些文件，其中包含最重要的 Makefile.in。在这里使用选项 <code>&lt;--add-missing | -a&gt;</code> 可以让 automake <strong>自动添加</strong>一些必需的脚本文件，如果不带此参数会因为缺失文件而报错。（更多内容参考最后一章：automake 软件等级）</p>
</li>
<li><p>执行“./configure”命令生成 Makefile 文件 </p>
</li>
<li><p>执行“make”命令来编译 hello.c 程序，从而生成可执行程序 hello。生成可执行程序 hello 后，执行“./hello”。</p>
</li>
</ol>
<p>哈哈，一定看到你想要的结果了吧。ps：更详细介绍<a href="/2017/04/27/automake2nd/">《Automake 之 Flat 目录机构》</a></p>
<h1 id="shallow-目录结构"><a href="#shallow-目录结构" class="headerlink" title="shallow 目录结构"></a>shallow 目录结构</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloworld </span><br><span class="line">|-mymain.c </span><br><span class="line">|head </span><br><span class="line">||-mytest.h </span><br><span class="line">||-mytest.c </span><br></pre></td></tr></table></figure>
<p>　　<br>顶级目录 helloworld，该目录下存在一个主文件 mymain.c 和一个目录 head。head 目录中，mytest.h 头文件声明了 <code>sayhello()</code> 方法；mytest.c 中实现了 <code>sayhello()</code> 方法；mymain.c 中的 main 调用了 <code>sayhello()</code> 方法。 </p>
<h2 id="执行步骤：-1"><a href="#执行步骤：-1" class="headerlink" title="执行步骤："></a>执行步骤：</h2><ol>
<li><p>在顶层目录下运行 autoscan 产生 configure.scan 文件 </p>
</li>
<li><p>将configure.scan文件更名为 <del>configure.in</del> configure.ac 文件 </p>
</li>
<li><p>打开 <del>configure.in</del> configure.ac 文件，修改文件内容</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line"> </span><br><span class="line">#AC_INIT([2.68])</span><br><span class="line">AC_INIT([hello], [1.0], [**@126.com])</span><br><span class="line">AC_CONFIG_SRCDIR([mymain.c])</span><br><span class="line">#AC_CONFIG_HEADERS([config.h])</span><br><span class="line"> </span><br><span class="line">AM_INIT_AUTOMAKE(hello, 1.0)</span><br><span class="line"> </span><br><span class="line"># Check for programs</span><br><span class="line">AC_PROG_CC</span><br><span class="line">#使用静态库编译，需要此宏定义</span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line"></span><br><span class="line"># Check for libraries</span><br><span class="line"># Check for header files</span><br><span class="line"># Check for typedefs, structures, and compiler characteristics.</span><br><span class="line"># Check for library functions.</span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile head&#x2F;Makefile)</span><br></pre></td></tr></table></figure></li>
<li><p>然后分别执行以下两个命令： </p>
<ul>
<li>aclocal </li>
<li>autoconf </li>
</ul>
</li>
<li><p>在 head 文件夹下创建 Makefile.am 文件，内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">noinst_LIBRARIES&#x3D;libmytest.a</span><br><span class="line">libmytest_a_SOURCES&#x3D;mytest.h mytest.c</span><br></pre></td></tr></table></figure></li>
<li><p>在 helloworld 文件夹下创建 Makefile.am 文件，内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">SUBDIRS&#x3D;head</span><br><span class="line">bin_PROGRAMS&#x3D;hello</span><br><span class="line">hello_SOURCES&#x3D;mymain.c</span><br><span class="line">hello_LDADD&#x3D;head&#x2F;libmytest.a</span><br></pre></td></tr></table></figure></li>
<li><p>执行命令“automake –add-missing”，automake 会根据 Makefile.am 文件产生一些文件，其中包含最重要的 Makefile.in</p>
</li>
<li><p>执行“./configure”命令生成 Makefile 文件 </p>
</li>
<li><p>执行“make”命令来编译 hello.c 程序，从而生成可执行程序 hello。生成可执行程序 hello 后，执行“./hello”。</p>
</li>
</ol>
<p>哈哈，shallow 的目录结构也搞定了哦。</p>
<h1 id="Deep-目录结构"><a href="#Deep-目录结构" class="headerlink" title="Deep 目录结构"></a>Deep 目录结构</h1><h2 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloworld </span><br><span class="line">|head </span><br><span class="line">||-mytest.h </span><br><span class="line">||-mytest.c </span><br><span class="line">|src </span><br><span class="line">||-mymain.c</span><br></pre></td></tr></table></figure>
<p> 　　<br>顶级目录 helloworld，该目录下存在两个目录 src 和 head。Head 目录中，mytest.h 头文件声明了 <code>sayhello()</code> 方法；mytest.c 中实现了 <code>sayhello()</code>方法；src 目录中的 mymain.c 中的 main 调用了 <code>sayhello()</code> 方法。 </p>
<h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol>
<li><p> 在顶层目录下运行 autoscan 产生 configure.scan 文件 </p>
</li>
<li><p> 将 configure.scan 文件更名为 <del>configure.in</del> configure.ac 文件 </p>
</li>
<li><p>打开 <del>configure.in</del> configure.ac 文件，修改文件内容</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line"> </span><br><span class="line">#AC_INIT([2.68])</span><br><span class="line">AC_INIT([hello], [1.0], [**@126.com])</span><br><span class="line">AC_CONFIG_SRCDIR([src&#x2F;mymain.c])</span><br><span class="line">#AC_CONFIG_HEADERS([config.h])</span><br><span class="line"> </span><br><span class="line">AM_INIT_AUTOMAKE(hello, 1.0)</span><br><span class="line"> </span><br><span class="line"># Check for programs</span><br><span class="line">AC_PROG_CC</span><br><span class="line">#使用静态库编译，需要此宏定义</span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line"></span><br><span class="line"># Check for libraries</span><br><span class="line"># Check for header files</span><br><span class="line"># Check for typedefs, structures, and compiler characteristics.</span><br><span class="line"># Check for library functions.</span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile head&#x2F;Makefile src&#x2F;Makefile)</span><br></pre></td></tr></table></figure></li>
<li><p>然后分别执行以下两个命令： </p>
<ul>
<li>aclocal </li>
<li>autoconf </li>
</ul>
</li>
<li><p>在 head 文件夹下创建 Makefile.am 文件，内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">noinst_LIBRARIES&#x3D;libmytest.a</span><br><span class="line">libmytest_a_SOURCES&#x3D;mytest.h mytest.c</span><br></pre></td></tr></table></figure></li>
<li><p>在 src 文件夹下创建 Makefile.am 文件，内容如下： </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">bin_PROGRAMS&#x3D;hello</span><br><span class="line">hello_SOURCES&#x3D;mymain.c</span><br><span class="line">hello_LDADD&#x3D;..&#x2F;head&#x2F;libmytest.a</span><br></pre></td></tr></table></figure></li>
<li><p>在 helloworld 文件夹下创建 Makefile.am 文件，内容如下： </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class="line">SUBDIRS&#x3D;head src</span><br></pre></td></tr></table></figure></li>
<li><p> 执行命令“automake –add-missing”，automake 会根据 Makefile.am 文件产生一些文件，其中包含最重要的 Makefile.in </p>
</li>
<li><p> 执行“make”命令来编译 hello.c 程序，从而生成可执行程序 hello。生成可执行程序 hello 后，执行“./hello”。</p>
</li>
</ol>
<p>哈哈，deep 目录下的编译与链接也搞定了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上 3 种目录层次结构的测试代码在 <a href="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/Automake_Test_Code.tar.bz2">附件</a> 中。归纳一下以上所有例子的流程： </p>
<ol>
<li>在存放源代码的顶层目录下执行 autoscan 命令生成 configure.scan 文件。 </li>
<li>将 configure.scan 文件改名为 <del>configure.in</del> configure.ac，并对其默认配置进行修改。 </li>
<li>执行 aclocal、autoconf 两个命令，分别生成 aclocal.m4、configure 文件。 </li>
<li>在每个目录下创建一个名为 Makefile.am 的文件，并输入相应的内容。 （ps 下文试验证明最好将此步骤放到最前面）</li>
<li>执行 automake –add-missing，它根据 Makefile.am 文件，生成 Makefile.in。 （ps 此步骤只能在 aclocal -？autoconf-之后）</li>
<li>执行 ./configure 脚本文件，它根据 Makefile.in 文件，生成最终的 Makefile 文件。 </li>
<li>生成 Makefile 之后，执行“make”编译工程并且生成可执行程序。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/1.png" alt="流程图"></p>
<p>看到这里，你除了跑跑例子什么都不会，只是对于使用 autotools 创建 Makefile 的步骤有了一个模糊的认识，但正如文章开头吐槽的那样，使用 autotools 的<strong>关键</strong>在于 configure.ac 和 Makefile.am 文件的书写。在 <a href="/2017/08/24/autotools/">编译利器：大型项目如何使用Automake和Autoconf完成编译配置(ver+0.6)</a> 中着重介绍了这两个文件的书写规则。</p>
<h1 id="附：automake-软件等级【测试……】"><a href="#附：automake-软件等级【测试……】" class="headerlink" title="附：automake 软件等级【测试……】"></a>附：automake 软件等级【测试……】</h1><p>在上文的例子中我们看到 Makefile.am 文件的第一行内容就是设置 automake 软件等级。</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/4.png" alt="简单的例子"></p>
<p>AUTOMAKE_OPTIONS 为设置 automake 的选项，由于 GNU 对自己发布的软件有严格的规范，比如必须带许可证声明文件等，否则 automake 执行时会出错，automake 提供了 3 种软件等级：foreign、gnu 和 gnits，让用户选择采用，默认等级为 gnu。在本例中使用 foreign 等级，它只检查必须的文件。</p>
<h2 id="gun-等级"><a href="#gun-等级" class="headerlink" title="gun 等级"></a>gun 等级</h2><p>automake 软件等级默认 gnu，此等级下执行 automake 需要文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* install-sh </span><br><span class="line">* missing </span><br><span class="line">* INSTALL </span><br><span class="line">* NEWS </span><br><span class="line">* README </span><br><span class="line">* AUTHORS </span><br><span class="line">* ChangeLog </span><br><span class="line">* COPYING </span><br><span class="line">* depcomp  </span><br></pre></td></tr></table></figure>
<p>其中，以下文件在执行 automake -a 的时候会自动生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* install-sh </span><br><span class="line">* missing </span><br><span class="line">* INSTALL </span><br><span class="line">* COPYING </span><br><span class="line">* depcomp</span><br></pre></td></tr></table></figure>
<p>所以，接下来手动生成剩下的文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost str]# touch NEWS README AUTHORS ChangeLog </span><br></pre></td></tr></table></figure>
<p>8、执行 automake -a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost str]# automake -a</span><br><span class="line">configure.ac: installing &#96;.&#x2F;install-sh&#39;</span><br><span class="line">configure.ac: installing &#96;.&#x2F;missing&#39;</span><br><span class="line">Makefile.am: installing &#96;.&#x2F;INSTALL&#39;</span><br><span class="line">Makefile.am: installing &#96;.&#x2F;COPYING&#39;</span><br><span class="line">Makefile.am: installing &#96;.&#x2F;compile&#39;</span><br><span class="line">Makefile.am: installing &#96;.&#x2F;depcomp&#39;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>编译利器：大型项目如何使用Automake和Autoconf完成编译配置(ver+0.6)</title>
    <url>/2017/08/24/autotools/</url>
    <content><![CDATA[<p>这篇帖子很棒！我从百度文库中下载了 <a href="https://github.com/tnie/MarkdownPhotos/blob/master/autotools/%E7%BC%96%E8%AF%91%E5%88%A9%E5%99%A8%EF%BC%9A%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Automake%E5%92%8CAutoconf%E5%AE%8C%E6%88%90%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE(ver+0.6).docx?raw=true">此教程</a>，因为未做深度的考证，所以也不知原作者是谁，但在此谢谢作者。以下是作者原文，略有删改，本人有修改部分都已做出备注。</p>
<hr>
<p>使用过开源 C/C++ 项目的同学们都知道，标准的编译过程已经变成了简单的三部曲：configure/make/make install, 使用起来很方便，不像平时自己写代码，要手写一堆复杂的 Makefile，而且换个编译环境，Makefile 还需要修改（Eclipse 也是这样）。</p>
<p>这么好的东东当然要拿来用了，但 GNU 的 Autotool 系列博大精深，工具数量又多，涉及的语言也多，要是自己从头看到尾，黄花菜都凉了，项目估计早就结束了；上网搜样例倒是有一大堆，但都是“hello world”的样例，离真正完成大型项目的目标还差得远。</p>
<p>没有办法，对照网上的样例，再找几个开源的源码，然后参考各种 Autotools 的手册，花了 2 天时间，终于完成了一个基本可用的 Autotools。为了避免其他 XDJM 也浪费时间，因此将过程总结下来，就算是新年礼物，送给大家！！</p>
<a id="more"></a>

<h1 id="提纲挈领：使用-Autotools-其实很简单"><a href="#提纲挈领：使用-Autotools-其实很简单" class="headerlink" title="提纲挈领：使用 Autotools 其实很简单"></a>提纲挈领：使用 Autotools 其实很简单</h1><p>大家不要看到那么多工具，其实使用起来很简单，总结起来就是两部分：</p>
<ol>
<li>按照顺序调用各个工具；</li>
<li>修改或者添加 3 个文件；</li>
</ol>
<p>整个操作顺序如下图：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/autotools/2.jpg" alt="流程图"></p>
<blockquote>
<p>niel:作者这幅图强调的是操作顺序，在表现文件依赖关系上力不从心，所以我又多配了一幅图。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/1.png" alt="依赖关系"></p>
<p>听到我这么讲，大家是否觉得有信心了？好的，下面我们来看具体如何操作：</p>
<ol>
<li>   源码根目录调用 autoscan 脚本，生成 configure.scan 文件，然后将此文件重命名为 configure.ac</li>
<li>   修改 <strong>configure.ac</strong>，利用 autoconf 提供的各种 M4 宏，配置项目需要的各种自动化探测项目</li>
<li>   编写<strong>自定义宏</strong>，建议每个宏一个单独的 *.m4 文件；</li>
<li>   调用 aclocal 收集 configure.ac 中用到的各种非 Autoconf 的宏，包括自定义宏；</li>
<li>   调用 autoheader，扫描 configure.ac、acconfig.h（如果存在），生成 config.h.in 宏定义文件，里面主要是根据 configure.ac 中某些特定宏(如 <code>AC_DEFINE</code>)生成的 <code>#define</code> 和 <code>#undefine</code> 宏，configure 在将根据实际的探测结果决定这些宏是否定义（具体见后面例子）。</li>
<li>   按照 automake 规定的规则和项目的目录结构，编写一个或多个 <strong>Makefile.am</strong>(Makefile.am 数目和存放位置和源码目录结构相关)，Makefile.am 主要写的就是编译的目标及其源码组成。</li>
<li>   调用 automake，将每个 Makefile.am 转化成 Makefile.in，同时生成满足 GNU 编码规范的一系列文件（带 <code>-a</code> 选项自动添加缺少的文件，但有几个仍需要自己添加，在执行 automake 前需执行<code>$ touch NEWS README AUTHORS ChangeLog</code>）。如果 configure.ac 配置了使用 libtool(定义了 <code>AC_PROG_LIBTOOL</code> 宏（老版本）或 <code>LT_INIT</code> 宏)，需要在此步骤前先在项目根目录执行 <code>$ libtoolize --automake --copy --force</code>，以生成 ltmain.sh，供 automake 和 config.status 调用。</li>
<li>   调用 autoconf，利用 M4 解析 configure.ac，生成 shell 脚本 configure。以上几步完成后，开发者的工作就算完成了，后面的定制就由开源软件的用户根据需要给 configure 输入不同的参数来完成。</li>
<li>   用户调用 configure，生成 Makefile，然后 <code>$ make &amp;&amp; make install</code>。</li>
</ol>
<p>整个过程步骤有 9 步，但其中有 6 步你只需要简单的敲一个命令即可，只有剩下的三步需要你动手写一些东西，对应上面步骤中的蓝色黑体字部分，而本文的重点就是如何在大型项目中完成这三歩。</p>
<h1 id="步步为营：三步完成编译配置"><a href="#步步为营：三步完成编译配置" class="headerlink" title="步步为营：三步完成编译配置"></a>步步为营：三步完成编译配置</h1><blockquote>
<p>niel:关键的三步即：第2步-修改 configure.ac 文件、第3步-编写自定义的 Autoconf 宏、第6步-编写 Makefile.am 文件</p>
</blockquote>
<h2 id="修改configure-ac文件"><a href="#修改configure-ac文件" class="headerlink" title="修改configure.ac文件"></a>修改configure.ac文件</h2><p>从上面的步骤可以看到，使用 autoscan 工具扫描后就会生成一个简单的 <del>configure.ac</del>configure.scan 文件，这已经是一个完整的 configure.ac 文件框架了，但还不足以达到我们的要求，因此我们要在框架里面添加一些东西：</p>
<ol>
<li><p>添加 <code>AM_INIT_AUTOMAKE</code> 宏</p>
<p> 在 <code>AC_INIT</code> 宏下一行添加 <code>AM_INIT_AUTOMAKE([foreign -Wall -Werror])</code>，中括号里面的选项可以根据需要来修改，具体请看 <a href="https://www.gnu.org/software/automake/manual/html_node/Public-Macros.html">automake 手册 6.4.1 节</a> 关于这个宏的说明。</p>
<blockquote>
<p>This macro can also be called in another, *deprecated *form: <code>AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])</code>.This usage is mostly obsolete because the <code>package</code> and <code>version</code> can be obtained from Autoconf’s <code>AC_INIT</code> macro.</p>
<p>Today, <code>AM_INIT_AUTOMAKE</code> is called with a single argument: a space-separated list of Automake options that should be applied to every Makefile.am in the tree. The effect is as if each option were listed in <code>AUTOMAKE_OPTIONS</code>. </p>
</blockquote>
</li>
<li><p>如果需要，添加 <code>AC_CONFIG_HEADERS([config.h])</code> 宏</p>
<p> 添加这个宏很简单，但关键是“如果需要”，什么情况下需要这个宏呢？</p>
<p> 这个宏的目的是输出 config.h，这是一个 C 的头文件，里面主要是包含很多宏定义 <code>#define</code>，说到这里其实就很明确了，输出这个文件的目的就是提供各种相关的宏，而宏在代码中的作用就是 <code>#ifdef</code>，也就是说：如果你的代码需要用到宏开关进行控制，那么就要输出这个文件。具体的使用方法如下：</p>
<ol>
<li>首先确定代码中需要使用什么宏来进行开关定制，确定宏的名称，编写和宏相关的代码，且要包含 config.h 的头文件；</li>
<li>在 configure.ac 中的各种处理（例如 <code>AC_CHECK_***</code>，<code>AC_ARG_***</code>）中使用 <code>AC_DEFINE</code> 宏定义 C/C++ 的宏，名称和上面的相同；如果是使用 <code>AC_CHECK_HEADERS</code>，会自动添加宏定义；</li>
<li>执行完第 7 歩（存疑？）后 ，Autoconf 就会自动生成 config .h 文件</li>
</ol>
</li>
<li><p>添加编译链接需要的程序</p>
<p> 编译、链接需要用到的程序需要添加在 <code># Checks for programs.</code> 注释后面。对于 C/C++ 来说，最常见的就是 gcc、g++、静态库编译、动态库编译，对应的选项如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AC_PROG_CXX</span><br><span class="line">AC_PROG_CC</span><br><span class="line">AC_PROG_RANLIB</span><br></pre></td></tr></table></figure>
<p> 如果使用 libtool 编译，则选项如下 <code>LT_INIT</code>，注意使用了 libtool 则需要将 <code>AC_PROG_RANLIB</code> 去掉</p>
</li>
<li><p>在 configure.ac 代码中各个部分添加自己的检测处理</p>
<p> 这一步是我们的主要工作，需要根据自己的项目具体情况来编写，常见操作对应的宏和样例请参考本文后面的“【常见操作对应的宏】”：。至于具体添加在哪个地方，configure.ac 中的注释已经清楚的告诉你了，例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Checks for libraries.</span><br><span class="line"># Checks for library functions.</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>AC_OUTPUT</code> 上一行添加 <code>AC_CONFIG_FILES</code> 宏</p>
<p> 添加这个宏的目的是制定 Autoconf 输出哪些文件，常见的文件就是 Makefile 文件，config.h 在 <code>AC_CONFIG_HEADERS</code> 宏里面指定了，这里不需要再次指定。例如：</p>
<p> <code>AC_CONFIG_FILES([Makefile tools/Makefile common/Makefile worker/Makefile])</code></p>
</li>
</ol>
<blockquote>
<p>niel 补充 - 关于 <code>AC_CONFIG_FILES</code> 宏我有话说，见 <a href="/2017/08/24/automake4th/">Makefile 自动生成 - 渣滓</a></p>
</blockquote>
<h2 id="编写自定义的-Autoconf-宏"><a href="#编写自定义的-Autoconf-宏" class="headerlink" title="编写自定义的 Autoconf 宏"></a>编写自定义的 Autoconf 宏</h2><p>Autoconf 虽然提供了很多内置的宏，但在实际项目中，这些宏不可能满足所有的要求，有的处理还是要自己完成。虽然在 configure.ac 文件中可以直接编写各种处理代码，但这样做有几个缺点：</p>
<ul>
<li>很不美观：打开 configure.ac 文件，密密麻麻的一大段花花绿绿的 Shell 代码，看着眼花缭乱；</li>
<li>修改起来很麻烦：要找半天才能找到要修改的位置，一不小心就改错了；</li>
<li>niel 补充：编写跨平台的 shell 脚本太考验能力</li>
</ul>
<p>就像写 C/C++ 代码要进行封装一样，Autoconf 的处理也需要进行封装，这个封装就是自定宏，定义完成后在 configure.ac 中调用，看起来很清爽，修改也很简单。下面我们来看如何自定义宏：</p>
<ol>
<li><p>新建一个单独的目录，用于存放自定义宏，一般定义为 m4</p>
</li>
<li><p>新建自定义宏文件</p>
<p> 建议每个宏一个文件，文件必须以 .m4 结尾，文件名就是宏名（当然如果你非要不这么做也可以，文件名随便取）</p>
</li>
<li><p>编写 Autoconf 宏</p>
<p> 具体的编写方式请参考 Autoconf 的手册第 10 章节，最好边看手册边对照一个开源软件的样例，这样效果最好了。这里说明几个需要注意的地方：</p>
<ul>
<li><p>m4宏不是 shell，请不要直接在文件中写 shell 代码，而要在宏的各个部分里面写代码；</p>
<p>  最常见的就是 if-else 判断，如果要在代码中编写 if-else 判断，需要使用 <code>AS_IF</code> 宏，或者在其它宏里面写，例如 <code>AC_ARG_WITH</code>, <code>AC_CACHE_CHECK</code>；</p>
</li>
<li><p><code>AC_DEFUN</code> 是定义 autoconf 的宏，<code>AC_DEFINE</code> 是定义 C/C++ 的 config .h 里面的宏，不要混淆了；</p>
</li>
</ul>
</li>
<li><p>运行 aclocal 工具，生成 aclocal.m4</p>
<p> 由于自定义宏是放在我们新建的目录中的，configure.ac 并没有像 C/C++ 那样的 include 语句可用，因此也就找不到这些宏，这时就需要 aclocal 工具了：aclocal 会将自定义宏编译成configure.ac 可用的宏，保存在和 configure.ac 同级目录下的 aclocal.m4 文件中，这样在 configure.ac 就能够直接使用了。具体的编译方法如下（m4 就是你的目录）: <code>aclocal -I m4</code></p>
<p> 同时需要在根目录下的 Makefile.am 中添加 <code>ACLOCAL_AMFLAGS = -I m4</code>。</p>
</li>
</ol>
<p>还有一种方法是将所有的自定义宏都放入到一个 acinclude.m4 文件中，不过不推荐这种方法，原因是因为这种方法的缺点和直接将所有自定义宏放入 configure.ac 中没有多大差别。</p>
<h2 id="编写Makefile-am文件"><a href="#编写Makefile-am文件" class="headerlink" title="编写Makefile.am文件"></a>编写Makefile.am文件</h2><p>对于大型项目来说，代码一般都是分目录存放的，而不会像 Hello world 样例那样简单的就几个文件，因此写 Makefile.am 就麻烦一些，但其实主要是工作量增加了，原则都是一样的：</p>
<ul>
<li><p>原则1：每个目录一个 Makefile.am 文件；同时在 configure.ac 的 <code>AC_CONFIG_FILES</code> 宏中指定输出所有的 Makefile 文件，例如：</p>
<p>  <code>AC_CONFIG_FILES([Makefile tools/Makefile common/Makefile worker/Makefile])</code></p>
</li>
<li><p>原则2：父目录需要包含子目录</p>
<p>  在父目录下的 Makefile.am 中添加: <code>SUBDIRS = 所有子目录</code>，例如 <code>SUBDIRS=test tools</code></p>
</li>
<li><p>原则3：Makefile.am 中指明当前目录如何编译</p>
<p>  前两个原则很简单，这里就不多说了，重点说一下如何编写 Makefile.am。</p>
</li>
</ul>
<blockquote>
<p>niel 补充 - 在 Makefile.am 中尽量使用相对路径，系统预定义了两个基本路径：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/automake1st/table3.gif" alt="Makefile.am 中可用的路径变量"></p>
<blockquote>
<p>niel 补充 - 这两个路径的区别：$(top_builddir)引用的是 make 发生时的工作目录，上文提到，我们将在 build 目录下进行构建，那么库文件会生成在 build 目录下，而不是源码根目录下，所以$(top_builddir) 实际就是 gnu-build/build 目录，而这样可以很好的支持在另一个目录中编译程序。与之相对应的是 $(top_srcdir) 对应的是源码的根目录，即 gnu-build 目录。 <a href="http://www.pchou.info/linux/2016/09/24/gnu-build-system-2.html">引用来源</a></p>
<p>niel 补充 - 这篇帖子缺失了“外部编译”的知识点，上述引用出处刚好补上。</p>
</blockquote>
<p>编写 Makefile.am 主要是完成 3 件事情：编译(make)、安装(make install)、打包(make dist)，下面我们一一来进行讲解。</p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>编译和安装的规则是绑定在一起的，通过同一条语句同时指定了编译和安装的处理方式，<strong>具体的格式</strong>为：<code>安装目录_编译类型=编译目标</code></p>
<h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><p>例如：<code>bin_PROGRAMS = hello subdir/goodbye</code>，其中安装目录是 bin，编译类型是 PROGRAMS，编译目标是两个程序 hello, goodbye。</p>
<p>常用缺省的安装目录如下</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>Makefile.am 中的变量</th>
<th>使用方式</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>prefix</td>
<td>/usr/local</td>
<td>安装目录，通过–prefix指定</td>
<td></td>
</tr>
<tr>
<td>exec_prefix</td>
<td>${prefix}</td>
<td>同prefix</td>
<td></td>
</tr>
<tr>
<td>bindir</td>
<td>${exec_prefix}/bin</td>
<td>bin_编译类型</td>
<td></td>
</tr>
<tr>
<td>libdir</td>
<td>${exec_prefix}/lib</td>
<td>lib_编译类型</td>
<td></td>
</tr>
<tr>
<td>includedir</td>
<td>${prefix}/include</td>
<td>include_编译类型</td>
<td></td>
</tr>
<tr>
<td>noinstdir</td>
<td>无</td>
<td>noinst_编译类型，特殊的目录，表示编译目标不安装。</td>
<td></td>
</tr>
<tr>
<td>datadir</td>
<td>$(prefix)/share</td>
<td>data_编译类型</td>
<td>niel 新增，<a href="http://www.ibm.com/developerworks/cn/linux/l-makefile/">引用来源</a></td>
</tr>
<tr>
<td>sysconfdir</td>
<td>$(prefix)/etc</td>
<td></td>
<td>niel 新增，引用来源同上</td>
</tr>
</tbody></table>
<p>除了常用的缺省目录外，有时候我们还需要自定义目录，例如我们希望安装完成后安装目录下有一个配置文件目录 config，同时将指定的 test.ini 拷贝到 config 目录，则 config 目录需要通过自定义目录方式定义，然后按照缺省目录的使用方式使用。例如：</p>
<p>在根目录下的 Makefile.am 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个自定义的目录名称 config,注意 dir 后缀是固定的</span><br><span class="line">configdir&#x3D;$&#123;prefix&#125;&#x2F;config </span><br><span class="line"># 使用自定义的目录 config，必须要有这句，否则目录不会创建，</span><br><span class="line">config_DATA&#x3D;</span><br><span class="line"># &#x3D;等号后面如果有对应的文件，安装时会将对应的文件拷贝到config目录下。</span><br><span class="line">config_DATA&#x3D;config&#x2F;test.ini</span><br></pre></td></tr></table></figure>
<h4 id="编译类型"><a href="#编译类型" class="headerlink" title="编译类型"></a>编译类型</h4><p>常见编译类型如下，没有自定义编译类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>使用方式</th>
</tr>
</thead>
<tbody><tr>
<td>PROGRAMS</td>
<td>可执行程序</td>
<td>bin_PROGRAMS</td>
</tr>
<tr>
<td>LIBRARIES</td>
<td>库文件</td>
<td>lib_LIBRARIES</td>
</tr>
<tr>
<td>LTLIBRARIES (Libtool libraries)</td>
<td>libtool库文件</td>
<td>lib_LTLIBRARIES</td>
</tr>
<tr>
<td>HEADERS</td>
<td>头文件</td>
<td>include_HEADERS</td>
</tr>
<tr>
<td>SCRIPTS</td>
<td>脚本文件，有可执行权限</td>
<td>test_SCRIPTS（需要自定义test目录）</td>
</tr>
<tr>
<td>DATA</td>
<td>数据文件，无可执行权限</td>
<td>conf_DATA(需要自定义conf目录)</td>
</tr>
</tbody></table>
<h4 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h4><p>译目标其实就是编译类型对应的具体文件，其中需要 make 生成的文件主要有如下几个：可执行程序_PROGRAMS，普通库文件_LIBRARIES，libtool 库文件_LTLIBRARIES,其它类型对应的编译目标不需要编译，源文件就是目标文件。</p>
<p><strong>标准的编译配置</strong></p>
<p>如果你熟悉 gcc 的编译命令写法，那么 Automake 的 Makefile.am 编译过程就很好写了。因为 Automake 只是将写在一行 gcc 命令里的各个不同部分的信息分开定义而已。我们来看具体是如何定义的：</p>
<ul>
<li>target_SOURCES：对应 gcc 命令中的源代码文件</li>
<li>target_LIBADD：编译链接库时需要链接的其它库，对应 gcc 命令中的 *.a 等文件</li>
<li>target_LDADD：编译链接程序时需要链接的其他库，对应 gcc 命令中的 *.a 等文件</li>
<li>target_LDFLAGS：链接选项，对应 gcc 命令中的 -L, -l, -shared, -fpic 等选项</li>
<li>target_LIBTOOLFLAGS：libtool 编译时的选项</li>
<li>target_**FLAGS(例如 _CFLAGS/_CXXFLAGS)：编译选项，对应 gcc 命令中的 -O2, -g, -I 等选项</li>
</ul>
<blockquote>
<p>niel 补充 <del>【TODO】- xxx_LDADD：为链接器增加参数，一般用于第三方库的引用。比如-L -l；xxx_LIBADD：声明库文件引用，一般对于本项目中的库文件引用采用这种形式。<a href="http://www.pchou.info/linux/2016/09/24/gnu-build-system-2.html">引用来源</a></del></p>
<p>Use the <code>LIBADD</code> primary for libraries, and <code>LDADD</code> for executables. <a href="https://stackoverflow.com/questions/23685981/what-is-the-difference-between-ldadd-and-libadd">引用来源</a><br>ps 相比国内博客，我更倾向于 StackOverflow 上的答案。</p>
</blockquote>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#不同的编译类型只是第一句不一样，后面的编译配置都是一样的</span><br><span class="line">bin_PROGRAMS&#x3D; myproject</span><br><span class="line">myproject_SOURCES &#x3D; main.c</span><br><span class="line">myproject_LDADD   &#x3D; .&#x2F;utils&#x2F;libutils.a .&#x2F;module1&#x2F;libmodule1.a .&#x2F;core1&#x2F;libcore.a</span><br><span class="line">myproject_LDFLAGS &#x3D; -L&#x2F;home&#x2F;test&#x2F;local -lmemcached</span><br><span class="line">myproject_CFLAGS  &#x3D; -I.&#x2F;core1&#x2F; -I.&#x2F;module1&#x2F; -I.&#x2F;utils&#x2F; -O2 -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>niel 补充 - 可以参考 <a href="/2017/08/24/automake4th/">Makefile 自动生成 - 渣滓</a>，其中提到的全局变量及个别编译配置此文未涉及。</p>
</blockquote>
<p><strong>如何编译可执行程序</strong></p>
<p>对于大型项目来说，代码基本上都是分目录存放的，如果是直接写 makefile 文件，一般都是将所有源文件首先编译成 <code>*.o</code> 的文件，再链接成最终的二进制文件。但在 Automake 里面这样是行不通的，因为你只要仔细看编译类型表格就会发现，并没有一种编译类型能够编译 <code>*.o</code> 文件，无法像常规 makefile 那样来编写，所以就需要采取一些技巧。</p>
<p>其实这个技巧也很简单：将非 main 函数所在目录的文件编译成静态链接库，然后采用链接静态库的方式编译可执行程序。样例如下：</p>
<p>=================根目录Makefile.am======================</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对应Makefile.am原则2</span><br><span class="line">SUBDIRS &#x3D; tools common worker</span><br></pre></td></tr></table></figure>
<p>=================tool目录Makefile.am======================</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只是为了编译而生成的.a库文件，没有必要安装, 所以是noinst</span><br><span class="line">noinst_LIBRARIES&#x3D;libtools.a </span><br><span class="line">libtools_a_SOURCES&#x3D;.&#x2F;urlcode.h \</span><br><span class="line">                   .&#x2F;stringtools.cpp \</span><br><span class="line">                   .&#x2F;stringtools.h \</span><br><span class="line">                   .&#x2F;urlcode.c</span><br></pre></td></tr></table></figure>
<p>===============common目录Makefile.am======================</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只是为了编译而生成的.a库文件，没有必要安装, 所以是noinst</span><br><span class="line">noinst_LIBRARIES&#x3D;libcommon.a</span><br><span class="line">libcommon_a_SOURCES&#x3D;.&#x2F;iniparser.c \</span><br><span class="line">                    (省略很多文件, 实际使用时要一一填写)</span><br><span class="line">                    .&#x2F;exception.h \</span><br></pre></td></tr></table></figure>
<p>==============worker目录Makefile.am============================</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin_PROGRAMS&#x3D;worker</span><br><span class="line">worker_SOURCES&#x3D;.&#x2F;workeralgorithm.cpp \</span><br><span class="line">                .&#x2F;worker.cpp \</span><br><span class="line">                (省略很多文件, 实际使用时要一一填写)</span><br><span class="line">               .&#x2F;worker.h</span><br><span class="line">#通过_LDADD告诉Automake需要链接哪些库</span><br><span class="line">worker_LDADD&#x3D;..&#x2F;tools&#x2F;libtools.a ..&#x2F;common&#x2F;libcommon.a</span><br></pre></td></tr></table></figure>
<p><strong>如何编译静态库</strong></p>
<p>Automake 天然支持编译静态库，只需要将编译类型指定为 _LIBRARIES 即可。</p>
<p><strong>如何编译动态库</strong></p>
<p>需要注意的是：_LIBRARIES 只支持静态库(即 <code>*.a</code> 文件),而不支持编译动态库(<code>*.so</code>)文件，要编译动态链接库,需要使用_PROGRAMS。除此之外，还需要采用自定义目录的方式避开 Automake 的两个隐含的限制：</p>
<ul>
<li>如果使用 bin_PROGRAMS, 则库文件会安装到 bin 目录下，这个不符合我们对动态库的要求；</li>
<li>automake 不允许用 <code>lib_ PROGRAMS</code></li>
</ul>
<p>下面假设将 utils 编译成 so，采用自定义目录的方式，修改 Makefile.am 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mylibdir&#x3D;$libdir         #$libdir其实就是lib目录，请参考【安装目录】表格</span><br><span class="line">mylib_PROGRAMS&#x3D; libutils.so</span><br><span class="line">libutils_so_SOURCES &#x3D; utils.c utils.h</span><br><span class="line">libutils_so_LDFLAGS &#x3D; -shared –fpic  #这个就是gcc编译动态库的选项</span><br></pre></td></tr></table></figure>
<p><strong>如何编译libtool库</strong></p>
<p>对于跨平台可移植的库来说，推荐使用 libtool 编译，而且 Automake 内置了 libtool 的支持，只需要将编译类型修改为 <code>_LTLIBRARIES</code> 即可。</p>
<p>需要注意的是：如果要使用 libtool 编译，需要在 configure.ac 中添加 <code>LT_INIT</code> 宏，同时注释掉 <code>AC_PROG_RANLIB</code>，因为使用了 <code>LT_INIT</code> 后，<code>AC_PROG_RANLIB</code> 就没有作用了。</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>Automake 缺省情况下会自动打包，自动打包包含如下内容：</p>
<ol>
<li>所有源文件</li>
<li>所有 Makefile.am/Makefile.in 文件</li>
<li>configure 读取的文件</li>
<li>Makefile.am’s (using include) 和 configure.ac’ (using m4_include)包含的文件</li>
<li>缺省的文件，例如 README, ChangeLog, NEWS, AUTHORS</li>
</ol>
<p>如果除了这些缺省的文件外，你还想将其它文件打包(一般包括静态库、头文件、配置文件、帮助文件)，有如下两种方法：</p>
<ul>
<li><p>粗粒度方式：通过 EXTRA_DIST 来指定，指定文件就打包文件，指定目录就打包目录，例如：</p>
<p>  <code>EXTRA_DIST=conf/config.ini  test  tools/initialize.sh</code><br>  如果 test 是目录，那么会将 test 目录下所有的文件和目录都打包。</p>
</li>
<li><p>细粒度方式：在“安装目录_编译类型=编译目标”前添加 dist(表示需要打包), 或者 nodist(不需要打包)，例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将data_DATA&#x3D; distribute-this打包</span><br><span class="line">dist_data_DATA &#x3D; distribute-this</span><br><span class="line"></span><br><span class="line">#foo_ SOURCES不打包</span><br><span class="line">bin_PROGRAMS &#x3D; foo</span><br><span class="line">nodist_foo_SOURCES &#x3D; do-not-distribute.c</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1></li>
</ul>
<p>GNU Autotool 工具博大精深，我也是结合项目的实际应用来使用的，并没有完整的研究所有的工具，因此难免存在瑕疵和纰漏，如果大家发现有疑问或者问题的地方，欢迎大家指正。当然，GNU 自己的手册是最权威的，如果你有疑问的话，参考手册，以手册为准。</p>
<p>如果想了解 autotools 的工作原理和流程以及更高级的技巧，请参考胡华强写的《autoconf and automake介绍与典型应用.doc》。</p>
<blockquote>
<p>niel 补充 - 这篇 doc 在网上找不到，困惑。如何使用产生的 Makefile 文件，以及 ./configure 的一些参数可以参考 <a href="/2017/08/24/automake3rd/">Makefile 自动生成 - configure &amp; make</a></p>
<p>niel 补充 - 我读了好多篇帖子之后才反应过来 <code>AC_</code> 开头的宏是 autoconf 的宏，<code>AM_</code> 开头的宏是 automake 的宏。这个理解没错吧？</p>
</blockquote>
<h1 id="常见操作对应的宏"><a href="#常见操作对应的宏" class="headerlink" title="常见操作对应的宏"></a>常见操作对应的宏</h1><ul>
<li><p>给 <code>./configure</code> 添加 <code>--with-package</code> 参数，例如：<code>./configure  --with-libmemcached</code></p>
<p>  <code>AC_ARG_WITH</code>，具体如何写请参考 <a href="https://www.gnu.org/software/autoconf/manual/autoconf.html#External-Software">autoconf 手册 15.2 章节</a>，里面给了一个完整的样例。</p>
</li>
<li><p>给 <code>./configure</code> 添加 <code>–enable-feature</code> 参数，例如：<code>./configure –enable-multithread</code></p>
<p>  <code>AC_ARG_ENABLE</code>，顾名思义，这个宏的意思就是打开开关，这个开关可以是编译开关，也可以是代码功能开关。a) 如果是编译开关，则要配合 <code>AM_CONDITIONAL</code> 宏来使用（样例请看 <a href="https://www.gnu.org/software/automake/manual/html_node/Usage-of-Conditionals.html">automake 手册 20.1 章节</a> 的 <code>AM_CONDITIONAL</code> 宏说明）；b) 如果是代码功能开关，则要配合 <code>AC_DEFINE</code> 宏来使用（请参考 <a href="https://www.gnu.org/software/autoconf/manual/autoconf.html#External-Software">autoconf 手册 15.2 章节</a> 的 <code>AC_ARG_WITH</code> 宏的样例）</p>
</li>
<li><p>在 <code>./configure</code> 的时候检查头文件</p>
<p>  <code>AC_CHECK_HEADER</code>: 检查一个头文件；<code>AC_CHECK_HEADERS</code>：检查一批头文件</p>
</li>
<li><p>在 <code>./configure</code>时检查库文件</p>
<p>  <code>AC_CHECK_LIB</code>：样例请参考 autoconf 手册 15.2 章节的 AC_ARG_WITH 宏的样例</p>
</li>
<li><p>修改 make 行为</p>
<p>  如果你想修改默认的make行为，可以先使用AC_ARG_WITH或者AC_ARG_ENABLE添加./configure参数，再结合如下两个宏来完成：</p>
<p>  <code>AM_CONDITIONAL</code>：在 ./configure.ac 中增加一个 automake 宏，在 Makefile.am 中使用 if-else-endif 来使用宏；<br>  <code>AC_SUBST</code>：在 ./configure.a c中直接修改 automake 的变量，例如 <code>AM_CXXFLAGS</code>，<code>AM_CFLAGS</code> 等编译链接。</p>
</li>
</ul>
<h1 id="完整样例"><a href="#完整样例" class="headerlink" title="完整样例"></a>完整样例</h1><p><a href="https://github.com/tnie/MarkdownPhotos/blob/master/autotools/GNU%20Autotools%E6%A0%B7%E4%BE%8B.rar?raw=true">GNU Atuotools 样例.rar</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>   入门材料：<a href="http://sources.redhat.com/autobook/autobook/autobook_toc.html">http://sources.redhat.com/autobook/autobook/autobook_toc.html</a> 。</li>
<li>   autoconf手册：<a href="http://www.gnu.org/software/autoconf/manual/autoconf.html">http://www.gnu.org/software/autoconf/manual/autoconf.html</a> 。</li>
<li>   automake手册：<a href="http://sources.redhat.com/automake/automake.html">http://sources.redhat.com/automake/automake.html</a> 。</li>
<li>   libtool手册：<a href="http://www.gnu.org/software/libtool/manual/libtool.html">http://www.gnu.org/software/libtool/manual/libtool.html</a> </li>
<li>   tutorial：<a href="http://www.lrde.epita.fr/~adl/dl/autotools.pdf">http://www.lrde.epita.fr/~adl/dl/autotools.pdf</a> 。</li>
</ol>
]]></content>
      <categories>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>两个仓库之间的联系</title>
    <url>/2017/02/08/git-clone/</url>
    <content><![CDATA[<p>在之前的笔记中讲过 Git 的分支操作，无论简单还是深奥，那些都是一个仓库内的事情。今天这篇笔记重点描述两个仓库之间的联系，涉及到的 git 命令有 pull、push、clone 等，难点围绕着两个概念： remote-tracking branch 和 tracing branch。</p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>如果接触过 github，或者国内的 OSChina，那么必然用过 git clone 命令。我一般是这么用的：</p>
<ol>
<li>先在 github 上创建一个仓库（有时候还会捎带着使用 README.md 文件）；</li>
<li>然后使用 git clone 克隆到本地；</li>
<li>在本地进行文件添加、修改等操作后 commit；</li>
<li>在本地执行 push 推送到远程仓库（有时候还会将本地新增的 branch 也 push 上去）。</li>
</ol>
<a id="more"></a>

<p>针对本地原本存在的仓库，如何上传到远程版本仓库？——这是我一直摸索的，至今也没有弄明白的事情。好在我确定等我整理完这篇笔记，我就会有答案了！结论见第 5 章。</p>
<p>要解开上述问题，我们需要先弄清楚两个问题：</p>
<ul>
<li>在 github（还有 OSChina）上创建仓库时做了哪些工作？</li>
<li>git clone 究竟做了哪些工作？</li>
</ul>
<h1 id="OSChina-新建项目"><a href="#OSChina-新建项目" class="headerlink" title="OSChina 新建项目"></a>OSChina 新建项目</h1><p>我们新建项目时对话框如下，我在图中共标注了 6 个序号：</p>
<p><img src="https://raw.githubusercontent.com/nielong0610/MarkdownPhotos/master/oschina%20new%20proj.png" alt="OSChina new proj"></p>
<ol>
<li>默认为空，不选择任何语言；我一般都是选择 C++。</li>
<li>默认为空，不添加 .gitignore 文件；可选条目很丰富，后期只需要我们自己微调。</li>
<li>默认为空，不添加任何许可证；我貌似一直没用过。</li>
</ol>
<p>这六个选项中只有第一个不影响仓库本身，也就是除此之外的五个选项，只要你选择了任意一个——或者你添加了 .gitignore 文件，或者你添加了许可证，或者你使用了 Readme 文件，或者你使用了模板——那么仓库都不再是一个空仓库，会默认生成 master 分支，并产生第一次提交！</p>
<p>如果你想创建一个<strong>空仓库</strong>，2、3 选项需要保持默认，4、5、6 选项去掉勾选复选框。</p>
<p>如果你创建了一个空仓库，就会看到“快速设置——xxxx”的页面，其中会提到“强烈建议所有的git仓库都有一个README, LICENSE, .gitignore文件”，并且会给出简易的命令行入门教程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;git.oschina.net&#x2F;mazha&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>如果不是空仓库，那么你就会看到 master 分支，看到首次 commit 记录，看到你让 OSChina 自动生成的那些文件。</p>
<p>空仓库和非空仓库有什么影响呢？稍后就会看到，我们先认识一下入门教程中提到的两个命令。</p>
<h1 id="git-remote-amp-amp-git-push"><a href="#git-remote-amp-amp-git-push" class="headerlink" title="git remote &amp;&amp; git push"></a>git remote &amp;&amp; git push</h1><p>即便是在 OSChina 的 <a href="http://git.mydoc.io/?t=154701">新手帮助手册</a> 中，我们看到出现频率更多的是 <code>git push</code>，而非 <code>git clone</code>。看来 <code>git clone</code> 真不是一个好命令……</p>
<p>我们将 A 仓库的修改推送到 B 仓库，首先得建立两者之间的联系。通过在 A 仓库添加远程仓库实现：</p>
<blockquote>
<p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写。</p>
</blockquote>
<p>执行 git remote 可以查看已经配置的远程仓库服务器，也可以指定选项 <code>-v</code>，看到略微详细一些的内容。</p>
<blockquote>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote-name&gt;</code> 命令</p>
</blockquote>
<p>添加远程仓库之后，就可以从远程仓库拉取数据（这个稍后介绍），也可以推送数据到远程仓库。</p>
<p>执行 <code>git push &lt;remote-name&gt; &lt;branch-name&gt;:&lt;remote-branch-name&gt;</code> 会将本地 <code>&lt;branch-name&gt;</code> 分支的数据推送到 <code>&lt;remote-name&gt;</code> 服务器的 <code>&lt;remote-branch-name&gt;</code> 分支。</p>
<h2 id="git-push-的默认行为"><a href="#git-push-的默认行为" class="headerlink" title="git push 的默认行为"></a>git push 的默认行为</h2><p>我们一般不会使用上述命令的完整形式，在实际业务中多见到省略远程分支名、省略远程分支名 &amp; 本地分支名、省略远程分支名 &amp; 本地分支名 &amp; 省略远程主机名的形式。我曾误以为：</p>
<ol>
<li><del>省略远程分支名，默认与本地分支名相同；</del></li>
<li><del>在省略远程分支名的前提下，省略本地分支名，默认为当前分支；</del></li>
<li><del>在省略远程分支名、本地分支名的前提下，省略远程主机名：如果只存在唯一远程主机，则使用；否则报错；</del></li>
</ol>
<p>反复阅读 <a href="https://git-scm.com/docs/git-push">git-push</a> 的英文手册之后，发现事实要复杂得多，上述的理解根本就是错的。</p>
<p><code>git push [&lt;repository&gt; [&lt;refspec&gt;…​]]</code></p>
<blockquote>
<p>When the command line does not specify what to push with <code>&lt;refspec&gt;...</code> arguments, the command finds the default <code>&lt;refspec&gt;</code> by consulting <a href="https://git-scm.com/docs/git-config#git-config-remoteltnamegtpush"><code>remote.*.push</code> configuration</a>, and if it is not found, honors <a href="https://git-scm.com/docs/git-config#git-config-pushdefault"><code>push.default</code> configuration</a> to decide what to push.</p>
<p>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the <code>simple</code> value for <code>push.default</code>: the current branch is pushed to the corresponding <strong>upstream branch</strong>, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</p>
</blockquote>
<p>ps：Git 1.x 的默认策略（即 push.default 属性）是 matching；在Git 2.0 之后 simple 成为新的默认策略。simple 策略要求存在上游分支 &amp;&amp; 本地分支和上游分支同名。<a href="http://ybin.cc/git/git-default-push-option-explanation/">引用来源</a></p>
<p><code>&lt;refspec&gt;…​</code> <a href="https://git-scm.com/docs/git-push#git-push-ltrefspecgt82308203">引用来源</a></p>
<blockquote>
<p>Specify what destination ref to update with what source object. The format of a <code>&lt;refspec&gt;</code> parameter is an <strong>optional</strong> plus +, followed by the source object <code>&lt;src&gt;</code>, followed by a colon <code>:</code>, followed by the destination ref <code>&lt;dst&gt;</code>.</p>
</blockquote>
<p><strong>疑问</strong>：上述文件中只提到了省略远程分支名 &amp; 本地分支名时的行为，但只省略远程分支名时的行为呢？省略远程分支名 &amp; 本地分支名 &amp; 省略远程主机名的行为呢？</p>
<p>我只找到这样一句：</p>
<blockquote>
<p><code>$ git push origin serverfix</code> - This is a bit of a shortcut. Git automatically expands the <code>serverfix</code> branchname out to <code>refs/heads/serverfix:refs/heads/serverfix</code>, which means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” <a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">引用来源</a></p>
</blockquote>
<h2 id="尽信书不如无书"><a href="#尽信书不如无书" class="headerlink" title="尽信书不如无书"></a>尽信书不如无书</h2><p>关于 Git 远程操作的命令的具体用法，可以去官网查阅，如果觉得手册中的内容细致得太花费精力，可以学习阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">Git远程操作详解</a>，其中对于 git clone、git remote、git fetch、git pull 和 git push 的介绍完全能够满足我们的日常使用。ps：有些地方，因为翻译不恰当（其实很不负责）的问题很是头疼，花费了一下午时间。</p>
<p>阮老师在介绍 git push 命令的时候提到：</p>
<blockquote>
<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。<code>$ git push &lt;remote-name&gt;</code>（我反复读了 git push 的英文手册，此“追踪关系”是从 <code>remote.&lt;repository&gt;.push</code> configuration variable 来的，不是下文中提到的 tracking）</p>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。<code>$ git push</code> （<del>想来此处的“追踪分支”也是指 <code>remote.&lt;repository&gt;.push</code> configuration variable，或者是指只有一个远程仓库</del>见鬼，这个“追踪分支”指的是什么？如果不加任何参数使用 <code>$ git push</code> 似乎只有下面一种情况：指定了上游分支）</p>
<p>如果当前分支与多个主机存在追踪关系（1），则可以使用 <code>[-u | --set-upstream]</code> 选项指定一个默认主机（2），这样后面就可以不加任何参数使用 <code>git push</code>（3）。（1. “多个”到底指的是什么？什么时候会存在多个？<code>remote.&lt;repository&gt;.push</code> configuration variable 2.“默认主机”的表述明面上似乎更容易理解，但本质上是错的：此选项就是指定 upstream branches，建立追踪关系 3. 事实：存在 <code>remote.&lt;repository&gt;.push</code> 时不会使用 <code>push.default</code>，所以也就不会解析上游分支……）</p>
</blockquote>
<p>类似观点见博客评论 <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html#comment-347602">过客 说</a>，上述引用文字本身一团糟，我备注的文字也是一团糟，官方手册中我也没找到任何依据。</p>
<h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><p><code>remote.&lt;repository&gt;.push</code> configuration variable 可以通过 <code>$ git config --add remote.origin.push fixbug</code> 设置。 </p>
<ul>
<li>查看仓库级的 config，命令：<code>git config –local -l</code></li>
<li>查看全局级的 config，命令：<code>git config –global -l</code></li>
<li>查看系统级的 config，命令：<code>git config –system -l</code></li>
<li>查看当前生效的配置，  命令：<code>git config -l</code></li>
</ul>
<p>命令参考来源 <a href="https://cnbin.github.io/blog/2015/06/19/git-config-ming-ling-cha-kan-pei-zhi-wen-jian/">Git Config 命令查看配置文件</a></p>
<h1 id="追踪（tracking）关系"><a href="#追踪（tracking）关系" class="headerlink" title="追踪（tracking）关系"></a>追踪（tracking）关系</h1><p>我们先来区分三个概念：remote branches、 remote-tracking branches、 tracking branches</p>
<p>remote branches 远程分支：远程仓库中的分支</p>
<p>remote-tracking branches 远程跟踪分支：</p>
<blockquote>
<p>Remote-tracking branches are references to the state of remote branches. <strong>They’re local references</strong> that you can’t move; they’re moved automatically for you whenever you do any network communication. Remote-tracking branches act as bookmarks to remind you where the branches in your remote repositories were the last time you connected to them. <a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">引用来源</a></p>
<p>远程跟踪分支，但真实的意思应该是，远程分支在本地仓库的缓存，不执行git fetch命令，不会获取到远程分支的更新。千万不要将这些分支当做远程分支，以为是它们是自动更新的。<a href="https://higoge.github.io/2015/07/06/git-remote02/">引用来源</a></p>
</blockquote>
<p>tracking branches 跟踪分支：</p>
<blockquote>
<p>Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch” (and the branch it tracks is called an “upstream branch”). Tracking branches are local branches that have a direct relationship to a remote branch. </p>
<p>When you clone a repository, it generally automatically creates a master branch that tracks origin/master.</p>
</blockquote>
<p>综上：</p>
<ol>
<li><p>remote-tracking branches 和 tracking branches 都是本地分支，可以认为 remote-tracking branches 是 remote branches 在本地的镜像，在这个“镜像”上不能进行修改。</p>
<p> 这个镜像 tracks 远程分支，所以称为 remote-tracking branches。</p>
</li>
<li><p>分支的概念本质上是指向某次 commit 的指针，remote-tracking branches 指针是死的，不能移动的；好在我们可以以它为基础建立 tracking branches，检出到工作区进行工作。</p>
<p> tracking branches 追踪 remote-tracking branches。在这个子场景里，后者又称为前者的 upstream branch。</p>
</li>
</ol>
<p>参考 <a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">Git Branching - Remote Branches</a></p>
<h2 id="指定上游分支"><a href="#指定上游分支" class="headerlink" title="指定上游分支"></a>指定上游分支</h2><p>remote-tracking branches 对 remote branches 的跟踪是固定的。和 git 操作有紧密联系的是另外一个 tracking！本节也只讨论这个 tracking。</p>
<p>通过上面几个概念，我们知道了 tracking 关系的存在，那么我们怎么查看分支之间的追踪关系呢？怎么建立分支之间的追踪关系呢？</p>
<p>查看 <code> $ git branch -vv</code>。ps 啰里啰嗦多说点：参数 <code>-vv</code> 用来查看追踪关系/上游分支的，如果只是单纯的用 <code>$ git push &lt;remote-name&gt; &lt;branch-name&gt;[:&lt;remote-branch-name&gt;]</code> 推送过，或者在设置了 <code>remote.&lt;repository&gt;.push</code> configuration variable 的基础上使用 <code>$ git push &lt;remote-name&gt; [&lt;branch-name&gt;[:&lt;remote-branch-name&gt;]]</code> 推送过，而未设置 upstream branch，这个命令是看不到多余信息的，毕竟它本意也就是用来查看 upstream branch 而已。</p>
<p>从上文中，我们知道将 remote-tracking branches 检出 <code>git checkout -b &lt;branch-name&gt; &lt;remote-tracking branches&gt;</code> 时会建立追踪关系，其他的情况呢？</p>
<p>将本地分支与远程某分支建立追踪关系分为几种情况：</p>
<ol>
<li><p><code>git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</code></p>
<blockquote>
<p>Set up <code>&lt;branchname&gt;</code>‘s tracking information so <code>&lt;upstream&gt;</code> is considered <code>&lt;branchname&gt;</code>‘s upstream branch. If no <code>&lt;branchname&gt;</code> is specified, then it defaults to the current branch.</p>
</blockquote>
<p> 此命令用于给<strong>已存在的分支</strong>指定上游分支。一般使用 remote-tracking branches 作为 <code>&lt;upstream&gt;</code>，但也可以指定本地的其他分支作 <code>[&lt;branchname&gt;]</code> 的 <code>&lt;upstream&gt;</code>——语法上允许这么操作，但这么配置没有意义，两个完全相同的本地分支。</p>
<p> 相关命令：<code>git branch --unset-upstream [&lt;branchname&gt;]</code></p>
</li>
<li><p><code>git branch [--set-upstream | --track] &lt;branchname&gt; [&lt;start-point&gt;]</code></p>
<blockquote>
<p>When creating a new branch, set up <code>branch.&lt;name&gt;.remote</code> and <code>branch.&lt;name&gt;.merge</code> configuration entries to mark the start-point branch as “upstream” from the new branch. <a href="https://git-scm.com/docs/git-branch#git-branch---track">引用来源</a></p>
</blockquote>
<p> 此命令为<strong>创建分支</strong>命令，在创建新分支的同时指定上游分支。如果未指定 <code>&lt;start-point&gt;</code> 值，默认为当前分支。</p>
</li>
<li><p><code>git push  [-u | --set-upstream] [&lt;repository&gt; [&lt;refspec&gt;…​]]</code></p>
<blockquote>
<p>For every branch that is up to date or successfully pushed, add upstream (tracking) reference,……<a href="https://git-scm.com/docs/git-push#git-push---set-upstream">引用来源</a></p>
</blockquote>
</li>
<li><p><a href="https://git-scm.com/docs/git-clone">git clone</a></p>
</li>
</ol>
<p>我目前习惯使用的 git pull、git push 其实都是使用了很多默认参数的，而我却忽视了默认参数的存在。</p>
<p><strong>结论</strong>：追踪关系的本质是 remote-tracking branches 和 local branches 的映射（前者成为后者的 upstream branch），建立映射后的 local branches 称为 tracking branches。</p>
<p>上游分支相关的两个变量：<a href="https://git-scm.com/docs/git-config#git-config-branchltnamegtremote"><code>branch.&lt;name&gt;.remote</code> 配置项</a>、<a href="https://git-scm.com/docs/git-config#git-config-branchltnamegtmerge"><code>branch.&lt;name&gt;.merge</code> 配置项</a></p>
<h1 id="本地仓库与远程仓库建立联系"><a href="#本地仓库与远程仓库建立联系" class="headerlink" title="本地仓库与远程仓库建立联系"></a>本地仓库与远程仓库建立联系</h1><p>远程仓库如果是空的，可以直接向其 push 任意分支；</p>
<p>如果不是空的，就不能（在已存在分支上）直接向其 push 内容，需要先 pull 合并后再进行 push 操作（pull 有限制条件：要么本地仓库为空，要么两者有共同祖先）。</p>
<h2 id="OSChina-空仓库"><a href="#OSChina-空仓库" class="headerlink" title="OSChina 空仓库"></a>OSChina 空仓库</h2><ol>
<li>本地无仓库，git init 建立仓库，一般来说也会进行 git commit 提交；</li>
<li>本地存在仓库，git remote add 添加远程仓库后，使用 <code>git push -u &lt;remote-name&gt; &lt;branch-name&gt;</code> 在远程仓库创建分支、建立追踪关系、并将本地分支数据推送到远程仓库；</li>
<li>拉取怎么做呢？</li>
</ol>
<h2 id="OSChina-存在初始提交"><a href="#OSChina-存在初始提交" class="headerlink" title="OSChina 存在初始提交"></a>OSChina 存在初始提交</h2><p>本地无仓库，使用 git clone 简单省事；本地存在仓库，一般来说远程仓库的初始提交默认都是 mater 分支，所以：</p>
<ul>
<li>如果本地分支不是和远程仓库 master 分支（或已存在的其他分支）建立追踪关系，直接使用 <code>git push -u &lt;remote-name&gt; &lt;branch-name&gt;</code> 即可；</li>
<li>如果本地分支要与远程仓库已存在的分支建立追踪关系，<del>首先使用 git branch –set-upstream 建立追踪关系，然后 git pull 拉取远程分支数据，再将本地更新推送上去；</del>这是错误的，拉取时会直接报错 “fatal: refusing to merge unrelated histories”</li>
</ul>
<p><strong>强调</strong>：两个没有任何关系的分支（即，没有共同祖先）无论在理论还是实际操作上都是不可以进行合并的。所以，在远程仓库存在数据且保有本地仓库的前提下，在两者之间强加联系，只能在远程仓库另建分支（此分支和远程仓库原有数据无关），远程仓库会存在两个毫无关系的、相互独立的分支！还不如在最初直接使用空的远程仓库！</p>
<h2 id="如果远程仓库存在工作区？"><a href="#如果远程仓库存在工作区？" class="headerlink" title="如果远程仓库存在工作区？"></a>如果远程仓库存在工作区？</h2><p>这一小节描述的是一个问题，此问题出现在向远程仓库推送的过程中。当远程仓库由 git init 创建（无 <code>--bare</code> 参数），远程仓库存在工作区，且 push 的目的分支恰好是远程仓库的检出分支时，就会报错！</p>
<p>我们使用 OSChina、github 等版本库服务时不会出现这个错误，我们自己搭建 git 服务器（使用 git init –bare）时一般也会不会出现这个问题。出现此问题最普遍的场景是，我们 clone 电脑上版本库作为 bak，在 bak 中修改后 push 回原仓库。</p>
<ul>
<li><a href="http://www.cnblogs.com/abeen/archive/2010/06/17/1759496.html">Git: push 出错的解决 master -&gt; master (branch is currently checked out)</a></li>
<li><a href="http://stackoverflow.com/questions/11117823/git-push-error-refusing-to-update-checked-out-branch">http://www.cnblogs.com/abeen/archive/2010/06/17/1759496.html</a></li>
</ul>
<h1 id="git-clone-做了哪些工作？"><a href="#git-clone-做了哪些工作？" class="headerlink" title="git clone 做了哪些工作？"></a>git clone 做了哪些工作？</h1><p>我们看官方文档的描述：</p>
<ol>
<li>Clones a repository into a newly created directory, </li>
<li>creates remote-tracking branches for each branch in the cloned repository (visible using <code>git branch -r</code>), </li>
<li>and creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.</li>
<li>After the clone, a plain <code>git fetch</code> without arguments will update all the remote-tracking branches, </li>
<li>and a <code>git pull</code> without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when “–single-branch” is given; see below).</li>
<li>This default configuration is achieved by creating references to the remote branch heads under <code>refs/remotes/origin</code> and by initializing <code>remote.origin.url</code> and <code>remote.origin.fetch</code> configuration variables.</li>
</ol>
<p>参考链接：<a href="https://higoge.github.io/2015/07/06/git-remote02/">Git远程02：git clone都做了什么</a></p>
<p>如果有更多疑惑，请参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">Git 分支 - 远程分支</a>，查看英文原著更容易理解 <a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">Git Branching - Remote Branches</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《嗨翻C语言》（上）</title>
    <url>/2016/11/03/headFirstC-note1/</url>
    <content><![CDATA[<p>2016/2/23 14:41:06 </p>
<p>嗨翻C语言》，本书分为三个部分。</p>
<blockquote>
<p>本书分为三个部分：第1章到第4章是基础知识，包括基本语法、指针、字符串、小工具和源文件；第5章到第8章为进阶内容，有结构、联合、数据结构、<strong>堆、函数指针、动/静态链接；最后四章是高级主题，内容涵盖了系统调用、进程间通信、网络编程和多线程</strong>。（加粗部分的笔记在下篇）</p>
</blockquote>
<p>以下笔记没有严格按照章节进行整理，因为书中在多个章节可能提到同一类知识点，比如（略）</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>在此笔记中，不记录不同C标准的差异，具体细节查看原书；不记录不同OS下编写C时的差异，具体细节查看原书或者google。笔记中只对不同标准、不同OS下共性的语言原理、语法细节做出整理。</p>
<p>此上篇整理了1-190项标注和笔记。</p>
<h1 id="课外"><a href="#课外" class="headerlink" title="课外"></a>课外</h1><h2 id="三种C标准"><a href="#三种C标准" class="headerlink" title="三种C标准"></a>三种C标准</h2><p><a href="https://zh.wikipedia.org/wiki/ANSI_C">ANSI C</a> 始于20世纪80年代后期，适用于最古老的代码；1999年开始的C99标准有了很大的改进；在2011年发布的最新标准C11中……想知道编译器支持哪种标准，可以查看编译器的文档。</p>
<blockquote>
<p>“指定初始化器”按名设置结构和联合字段，它属于C99标准;</p>
<p>C99标准支持“指定初始化器”，C++不支持。</p>
<p>在代码中间的位置声明新变量，只有C99和C11标准才允许这样做，在ANSI C（在此特指 C89）中，必须在函数的顶部声明局部变量；</p>
</blockquote>
<p>更多的区别：1. 在早期的ANSI C标准中，main()函数可以是void 类型。但是在C99中main函数的返回类型必须是int。2. ANSI C标准没有用来表示真和假的值，C语言把0这个值当做假处理，把非0的任何值当做真处理。C99标准则允许在程序中使用true和false关键字。但编译器还是会把他们当做1和0这两个值来处理。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/18731707/why-does-c11-not-support-designated-initializer-list-as-c99">Why does C++11 not support designated initializer list as C99?</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-6.1.0/gcc/Standards.html#Standards">Language Standards Supported by GCC</a></li>
</ul>
<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc 是 *inux 下的一款编译器，上述三种标准它都支持。</p>
<p>ps 这种说法太笼统，请阅读 <a href="http://www.cnblogs.com/emituofo/archive/2012/07/20/2600995.html">GCC对C标准的支持</a>、<a href="http://blog.csdn.net/njnu_mjn/article/details/8629739">GCC的默认C标准</a>、<a href="http://www.crifan.com/figure_out_which_version_gcc_support_c11/">哪个版本的gcc才支持c11</a>、<a href="https://www.zhihu.com/question/33209351?sort=created">有哪些支持C11标准的编译器</a>）</p>
<ul>
<li>在不指定C标准的情况下，GCC默认使用GNU C，所以如果你想让编译器遵循C99标准，需要使用 -std=99 选项。</li>
<li>gcc是到了4.7，才真正支持c11的。</li>
</ul>
<h2 id="windows下使用gcc"><a href="#windows下使用gcc" class="headerlink" title="windows下使用gcc"></a>windows下使用gcc</h2><p>虽然在本书中作者提供了以下两种方法，但是在后续的介绍中也多有提及其不足之处。而且在接触之后，我还是放弃了 Cygwin，转而在虚拟机上安装了 debian。</p>
<blockquote>
<p>如在Windows操作系统上使用gcc（GNU编译器套装），有两种选择：一种是 <a href="http://www.cygwin.com/">Cygwin</a>，它可以完全模拟UNIX环境，自然也就包括了gcc；如果你只是想创建能够在Windows下运行的程序，<a href="http://www.mingw.org/">MinGW</a> 可能更符合你的需要。</p>
</blockquote>
<p>摘两条在书中描述的 Cygwin 项目不完美的地方：</p>
<blockquote>
<p>一些Cygwin的gcc版本允许修改字符串字面值，不会报错，但这样做常常是错的。</p>
<p>Cygwin的很多版本中，在多个信号的发送顺序和接收顺序问题上，做了不恰当的假设。</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>面向对象是一种对抗软件复杂性的技术。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li><p>在C语言中，几乎每样东西都有返回值：表达式 <code>x = 4</code> 本身也有一个值，这个值是4，即赋给x的值。</p>
<p>  Q1：这个赋值表达式能否进行<strong>再次赋值</strong>？例如 <code>(x=3)=4</code></p>
<p>  A1：在C中编译无法通过，类似<code>3=4</code>；在C++中正常编译，运行，类似<code>x=4</code>。</p>
<p>  注意：以下这种再次赋值是成立的。因为无论 <code>y=4</code>（C语言） 还是 <code>y=x</code>（C++） 都是成立的。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    y = x = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// or 两者意义相同</span></span><br><span class="line">    <span class="comment">// y = (x = 4);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %d, y is %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  关键是理解 <a href="http://www.caole.net/diary/lvalue.html">C/C++中左值</a> 的概念，而且 C 和 C++ 中是不一样的。</p>
</li>
<li><p>使用switch语句的好处之一是，可以用<strong>下落逻辑</strong>在不同的分支之间复用代码。</p>
</li>
</ul>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>如果真的想玩转C语言，就需要理解C语言如何操纵存储器。掌握指针和存储器寻址对成为一名地道的C程序员很重要。</p>
<blockquote>
<p>函数（例如 main() 函数）中声明变量，计算机会把它保存在一个叫栈（Stack）的存储器区段中；函数以外的地方声明变量，计算机则会把它保存在存储器的全局量段（Globals）；堆用于动态存储。</p>
</blockquote>
<p>存储器的分布图：参考位置#1022、位置#1322、位置#1448</p>
<ul>
<li>存储器是进程的</li>
<li><code>sizeof</code> 是运算符，好比<code>+</code>、<code>&amp;</code>，它不是库函数。程序是在编译期间计算 <code>sizeof</code> 的。<code>sizeof</code> 运算告知某样东西在存储器中占多少字节，既可以对数据类型使用，也可以对某条数据使用。</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>指针就是存储器中某条数据的地址</li>
<li>指针做了两件事：避免副本和共享数据。</li>
<li>指针是一种<strong>间接形式</strong>的地址（怎么理解？）</li>
<li><code>*</code> 运算符可以读取存储器地址中的内容。<code>*</code> 运算符还可以设置存储器地址中的内容。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>指向字符串字面值（string literal）的指针变量不能用来修改字符串的内容</p>
<ul>
<li>在存储器的非只读区域创建了字符串的副本，就可以修改它的字母</li>
<li>如果你想把指针设成字符串字面值，必须确保使用了 <code>const</code> 关键字：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bus error 运行时崩溃</span></span><br><span class="line"><span class="keyword">char</span> *card = <span class="string">&quot;JQK&quot;</span>;</span><br><span class="line">card[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
  编译错误，比在运行时崩溃好太多了！  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译不通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>加不加 <code>const</code>，字符串字面值都是只读的，<code>const</code> 修饰符表示，一旦你试图用 <code>const</code> 修饰过的变量去修改数组，编译器就会报错      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过jimmy 修改内容就会报编译错误,</span></span><br><span class="line"><span class="comment">// 但是通过masked_raider 修改就可以成功。</span></span><br><span class="line"><span class="keyword">char</span> masked_raider[] = <span class="string">&quot;Alive&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *jimmy = masked_raider;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li>
</ul>
</li>
<li><p>数组的索引值是一个偏移量</p>
</li>
<li><p>数组变量好比指针……</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> quote[] = <span class="string">&quot;Cookies make you fat&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>  计算机为字符串的每一个字符以及结束字符 <code>\0</code> 在栈上分配空间，并把首字符的地址和 quote 变量关联起来。函数传参时传给函数的是指针。</p>
</li>
<li><p>数组变量与指针又不完全相同（区别：重点理解2、3点）</p>
<ol>
<li><code>sizeof(数组)</code> 是……数组的大小；<code>sizeof(指针)</code> 返回4或8。</li>
<li>数组的地址……是数组的地址；指针的地址是另一个地址。         <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;s == s;  <span class="comment">// 数组变量</span></span><br><span class="line">&amp;t != t;  <span class="comment">// 指针</span></span><br></pre></td></tr></table></figure></li>
<li>数组变量不能指向其他地方。<br> 计算机会为数组分配存储空间，但不会为数组变量分配任何空间。</li>
</ol>
</li>
<li><p>指针退化</p>
<p>  把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息。我们把这种信息的丢失称为退化。</p>
</li>
</ul>
<h2 id="结构（结构体）"><a href="#结构（结构体）" class="headerlink" title="结构（结构体）"></a>结构（结构体）</h2><ul>
<li><p>结构可以像数组那样在结构中保存字段，但读取时只能按名访问。</p>
<p>  Q1：数组变量就是一个指向数组的指针，那么结构变量是一个指向结构的指针吗？ </p>
<p>  A1：不是，结构变量是结构本身的名字。 数组变量的地址是数组变量自身；结构变量的地址是指针，不是自身。</p>
</li>
<li><p>为结构变量赋值相当于叫计算机复制数据。</p>
<blockquote>
<p>重点在<strong>函数传参时</strong>很可能浪费较多存储资源；而数组作为函数参数传的是指针。</p>
</blockquote>
</li>
<li><p>用 <code>typedef</code> 为结构创建别名。用 <code>typedef</code> 定义结构时可以省略结构名，只写类型名。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call_phone</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cell_no;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *wallpaper;</span><br><span class="line">    <span class="keyword">float</span> minutes_of_charge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">call_phone</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cell_no;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *wallpaper;</span><br><span class="line">    <span class="keyword">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line"><span class="comment">// 省略结构名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cell_no;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *wallpaper;</span><br><span class="line">    <span class="keyword">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br></pre></td></tr></table></figure></li>
<li><p>关于“对齐”，可以<strong>查看原文</strong>或者进一步从<strong>网上学习</strong></p>
</li>
<li><p>在C语言中，参数按值传递给函数。</p>
<p>  作者要表达的就是字面意思!@但这句话在国内出版物中经常作为前半句出现—“值传参和“指针传参”，以至于之前理解都有偏差。其实“指针传参”还是按值传递给函数的。</p>
</li>
</ul>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><ul>
<li><p>定义一种叫“量”的数据类型，然后根据特定的数据决定要保存个数、重量还是容积。</p>
</li>
<li><p>每次创建结构实例，计算机都会在存储器中相继摆放字段，联合则不同。当定义联合时，计算机以其中最大的字段分配空间，然后由你决定里面保存什么值。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> count;</span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure></li>
<li><p>指定初始化器（designated initializer）按名设置结构和联合字段，它属于C99标准</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">quantity q = &#123;.weight=<span class="number">1.5</span>&#125;;</span><br><span class="line">phone p= &#123;.cell_no=<span class="number">15210</span>, .minutes_of_charge=<span class="number">1.2</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>联合提供了一种让你创建<em>支持不同数据类型的变量</em>的方法。</p>
</blockquote>
</li>
<li><p>联合经常和结构一起用。创建联合相当于创建新的数据类型。</p>
</li>
<li><p>编译器不会记录你在联合中设置或读取过哪些字段。</p>
<p>  Q1：可以在 <code>union</code> 中保存任何字段（<code>count</code>、<code>weight</code> 或者 <code>volume</code>）的值，这些不同类型的值保存在存储器中相同的位置……既然如此，你怎么知道我保存的是 <code>float</code> 还是 <code>short</code>？要是我保存了 <code>float</code> 字段，却读取了 <code>short</code> 字段呢？</p>
<p>  A1：解决方法：只要用枚举或其他东西记录一下就行了。</p>
</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>（略）</p>
<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><ul>
<li><p>位字段（bitfield）的初衷是节省存储器空间：真/假的值只需要一位就能表示；月份等小范围的数字……</p>
</li>
<li><p>只有当多个位字段出现在同一个结构中，才能节省空间。</p>
<blockquote>
<p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起。</p>
</blockquote>
</li>
<li><p>可以用位字段指定一个字段有多少位。位字段应当声明为 <code>unsigned int</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 是否第一次参观？</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> first_visit:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 还会再来吗？</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> come_agin:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 被咬掉了几根手指？</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fingers_lost:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 被鲨鱼袭击过吗？</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shark_attack:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 一周来几天？</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> days_a_week:<span class="number">3</span>;</span><br><span class="line">&#125; survey;</span><br></pre></td></tr></table></figure>
<p>Q1：为什么C语言不支持二进制字面值？ </p>
</li>
</ul>
<p>A1：因为二进制字面值占了很大空间（<strong>质疑？</strong>），而且十六进制通常写起来更快。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li><p>为了保存可变数量的数据，需要一样比数组更灵活的东西，即链表。</p>
<blockquote>
<p>链表是一种抽象数据结构。链表是通用的，可以用来保存很多不同类型的数据，所以被称之为抽象数据结构。</p>
</blockquote>
</li>
<li><p>与数组相比，链表还有一个优点：插入数据非常快。</p>
<p>  Q1：如何在C语言中创建链表？</p>
<p>  A1：通过创建递归结构实现。</p>
</li>
<li><p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构。</p>
<blockquote>
<p>在递归结构中，需要包含一个相同类型的指针，C语言的语法不允许用typedef别名来声明它。<em>个人猜测，应该和声明顺序有关。毕竟如果 <code>typedef 新类型 newtype</code>，然后 <code>newtype * pointer</code> 创建指针，是可行的。</em></p>
</blockquote>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在递归结构中，必须为结构体命名。别名可选</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">island</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> *opens;</span><br><span class="line">    <span class="keyword">char</span> *closes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">island</span> *<span class="title">next</span>;</span>  <span class="comment">// 此处不允许使用别名来声明</span></span><br><span class="line">&#125; island;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C语言需要知道结构在存储器中占的具体大小，如果在结构中递归地复制它自己，那么两条数据就会不一样大。指针的大小是确定的。</p>
</blockquote>
</li>
<li><p>在C语言中，<code>NULL</code> 的值实际上为0</p>
</li>
</ul>
<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h2><p>问：什么是小工具？——其实就是其字面意思，重点是要有这个概念。</p>
<blockquote>
<p>操作系统都有小工具。类Unix的操作系统为完成工作会大量使用工具，Windows用的少一些。</p>
<p>C语言小工具执行特定的小任务，例如读写文件、过滤数据。如果要完成更复杂的任务，可以把多个工具链接在一起。</p>
<p>小工具是一个C程序，它做一件事情并把它做好。</p>
<p>当你想解决一个大问题时，可以把它分解成一连串的小问题，然后针对每个小问题写一个小工具。</p>
</blockquote>
<p>问：为什么小工具要使用标准输入和标准输出？ </p>
<blockquote>
<p>答：有了它们，就可以轻易用管道将小工具们串连起来。</p>
</blockquote>
<p>问：如果两个程序用管道相连，第二个程序要不要等第一个程序执行完后才能开始运行？</p>
<blockquote>
<p>答：不需要，两个程序可以同时运行，第一个程序一发出数据，第二个程序马上就可以处理。</p>
</blockquote>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul>
<li><p>使用 <code>scanf()</code> 时要小心：限制 <code>scanf()</code> 能读入的字符数</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意字符数组的长度,和scanf 读取的限制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> card_name[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;输入牌名：&quot;</span>)；</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%2s&quot;</span>, card_name);</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果忘了限制 <code>scanf()</code> 读取字符串的长度，用户就可以输入远远超出程序空间的数据，多余的数据会写到计算机还没有分配好的存储器中</p>
</blockquote>
</li>
<li><p>如果你要向 <code>fgets()</code> 函数传递数组变量，就用 <code>sizeof</code>；如果只是传指针，就应该输入你想要的长度。</p>
</li>
<li><p>操作系统控制数据如何进出标准输入、标准输出。</p>
</li>
<li><p><code>scanf()</code> 和 <code>printf()</code> 函数，只管从标准输入读数据，向标准输出写数据</p>
</li>
<li><p>进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p>
</li>
<li><p><code>printf()</code> 其实只是 <code>fprintf()</code> 函数的特例，</p>
</li>
<li><p>可以用 <code>&gt;</code> 重定向标准输出，<code>2&gt;</code> 重定向标准错误。</p>
</li>
<li><p>用管道连接输入与输出</p>
</li>
</ul>
<h2 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h2><ul>
<li><p>程序运行时，操作系统会为它创建三条数据流：标准输入、标准输出和标准错误。但有时你需要创建自己的数据流。</p>
<blockquote>
<p>每条数据流用一个指向文件的指针来表示，可以用 <code>fopen()</code> 函数创建新数据流。</p>
<p>创建数据流后，可以用 <code>fprintf()</code> 函数往数据流中打印数据;可以用 <code>fscanf()</code> 函数从数据流中读取数据。</p>
<p>当用完数据流，别忘了使用 <code>fclose()</code> 函数关闭它。</p>
</blockquote>
</li>
<li><p>虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们：</p>
</li>
</ul>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><ul>
<li><p>十个程序有九个需要选项。聊天程序有“系统设置”，游戏有调整难度的选项，而命令行工具需要有命令行选项。</p>
<blockquote>
<p>很多程序都会用到命令行选项，因此有一个专门的库函数，可以使用它来简化处理流程。这个库函数叫做 <code>getopt()</code>，每一次调用都会返回命令行中下一个参数。</p>
<p>有关函数的具体使用方法，翻阅原书或者 google 都行。</p>
</blockquote>
</li>
<li><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p>
</li>
</ul>
<h2 id="使用多个源文件"><a href="#使用多个源文件" class="headerlink" title="使用多个源文件"></a>使用多个源文件</h2><ul>
<li><p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件；用引号把文件名括起来，编译器就会在本地查找文件。</p>
</li>
<li><p>C语言是一种很小的语言，共有32+n个保留字。以下列出部分：</p>
<blockquote>
<p>auto register static extern typedef union volatile</p>
</blockquote>
</li>
<li><p>使用头文件</p>
<ul>
<li><p>（函数）声明与定义分离</p>
<blockquote>
<p>将声明和定义分离之后也不用再严格调整函数定义之间的顺序。</p>
<p>把声明放到一个独立的头文件中有两大优点，第一是主代码变短了，第二可以共享代码（被两个以上源文件 include 时）。</p>
</blockquote>
</li>
<li><p>如此，就可以在不同的文件之间共享函数了，但如果你想<strong>共享变量</strong>呢？</p>
<blockquote>
<p>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上 <code>extern</code> <strong>关键字</strong>（需要进一步的学习）：</p>
</blockquote>
<p>  ps：原文表述不太恰当。改为：</p>
<ol>
<li>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内——（这句话存在异议，使用 gcc 实际编译时不同文件使用同名变量会报错“重复定义”）。</li>
<li>如果你想共享变量，就应该在头文件中声明。——声明变量，即在变量名前使用 <code>extern</code> 关键字，不应该用“并”。</li>
<li>关于 <code>extern</code>，见《进一步学习extern》笔记。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h1><ul>
<li>——另起篇幅</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈初始化</title>
    <url>/2016/12/20/initialization2nd/</url>
    <content><![CDATA[<p>以前整理过一篇笔记 <a href="https://tnie.github.io/2016/11/03/initialization/">《初始化》</a>，前两天又翻出来浏览了一下，写得很烂。限于当时的水平，并未像现在这样透彻的理解“默认构造函数”、“拷贝构造函数”、“拷贝赋值运算符”等概念，读书《C++ Primer》时看到好多种“初始化”，整理出那一篇可能只是想罗列名字、定义，让自己知道哪个是哪个罢了，却并不深刻理解中间的关联与区别。我们从头再来。</p>
<p>讲 C++ 的初始化，我们有好几种切入的方式：</p>
<ul>
<li>可以从日常使用的形式，从我们惯用的代码讲起，引出相关的术语；</li>
<li>可以直接讲构造函数，构造函数是本质，初始化是呈现，理解了构造函数，也就理解了初始化；</li>
<li>可以罗列各种初始化的表现形式，然后归纳，总结出结论。</li>
</ul>
<p>前一篇笔记带有第三种切入方式的味道，罗列了很多“XX初始化”，却没有归纳总结，意义不大。这一篇笔记我想以前两种方式来写。</p>
<a id="more"></a>

<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>内置类型和用户自定义类型有些区别，比如内置类型很可能（原谅我，我并不百分百确定）没有构造函数，而对于类类型即便我们不定义构造函数，编译器一般也会默认给我们生成。总的来说，内置类型使用上比类类型简单，但同时也是类类型的基础。对于内置类型，比如 <code>int</code>，哪怕是新手也是很熟悉的。我们都会对 <code>int</code> 变量进行什么操作呢？我们会怎么写代码呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var1;</span><br><span class="line"><span class="comment">// some codes</span></span><br><span class="line">var1 = <span class="number">11</span>；</span><br></pre></td></tr></table></figure>
<p>这应该是最普遍的代码书写形式了。我们定义了一个 <code>int</code> 变量，没有明确地给出其初始值，在稍后使用时给它赋值。像 <code>T t;</code> 这种形式我们称为“默认初始化”，或者“缺省初始化”。都是从“default initialization” 翻译过来的。</p>
<blockquote>
<p>This is the initialization performed when a variable is constructed with no initializer. <a href="http://en.cppreference.com/w/cpp/language/default_initialization">引用来源-default initialization</a></p>
</blockquote>
<p>有些人烦恼上述代码执行效果的“不确定性”（后文详述），更喜欢在定义变量时明确地给出一个初始值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var2 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// other codes</span></span><br><span class="line">var2 = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>
<p>像 <code>T t = x;</code> 这种形式我们称为“拷贝初始化”，即术语“copy initialization”。</p>
<blockquote>
<p>Initializes an object from another object <a href="http://en.cppreference.com/w/cpp/language/copy_initialization">引用来源-copy initialization</a></p>
</blockquote>
<p>我们使用内置类型书写的形式一般就是上述两种，有时候我们写在函数里面，有时候写在函数外面（全局的）。至此，我们了解了两个术语：default initialization 和 copy initialization。</p>
<p>tip1：有时候潜意识会让我们写出这样的代码 <code>int var();</code>，类类型的话更形象 <code>MyClass obj();</code>，我们本意是想默认初始化一个变量 var 或 obj，但编译器的规则更倾向于将这行代码解析成函数声明。</p>
<p>tip2：<code>T t = x;</code>的形式有时会让菜鸟误以为是赋值操作。拷贝初始化还有一种不具迷惑性的书写形式：<code>T t(x);</code></p>
<p>tip3：内置类型的初始化和赋值成本一样。</p>
<h2 id="默认值是什么"><a href="#默认值是什么" class="headerlink" title="默认值是什么"></a>默认值是什么</h2><p>如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，如果是内置类型，<strong>定义变量的位置也会对此有影响</strong>。内置类型的变量未被显式初始化时：</p>
<ul>
<li>定义于任何函数体之外的变量被初始化为 <code>0</code>；</li>
<li>定义在函数体内部的内置类型变量将<strong>不被初始化</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_var1;</span><br><span class="line"><span class="keyword">int</span> global_var2 = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inner_var1;</span><br><span class="line">  <span class="keyword">int</span> inner_var2 = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global_var1: &quot;</span> &lt;&lt; global_var1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global_var2: &quot;</span> &lt;&lt; global_var2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inner_var1: &quot;</span> &lt;&lt; inner_var1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inner_var2: &quot;</span> &lt;&lt; inner_var2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/initializer_learn$ ./a.out </span><br><span class="line">global_var1: 0</span><br><span class="line">global_var2: 100</span><br><span class="line">inner_var1: 4196240</span><br><span class="line">inner_var2: 12</span><br></pre></td></tr></table></figure>
<p>这个现象源于，最初 C 语言诞生时机器硬件性能有限，对于节省资源做到了令人发指的地步。定义变量默认只分配内存块，但不对这块内存进行擦除（复位）操作，这种复位操作一般来说都是多余的。假设根据默认初始值 0 进行擦除操作，除非作者后续就是使用初值 0，否则赋值还会再次擦除内存块赋予别的值，初始化时的擦除是没有意义的。</p>
<p>C++ 最初由 C 扩展而来，为了向其兼容保留了这些特征。在性能不再是瓶颈的今天，反而由于程序员粗心使用了无初值且未赋值的变量而产生很多错误。</p>
<h2 id="在堆上创建变量"><a href="#在堆上创建变量" class="headerlink" title="在堆上创建变量"></a>在堆上创建变量</h2><p>除了在栈上定义变量，我们还会在堆上动态分配内存。这种情况下怎么初始化呢？</p>
<p>default initialization</p>
<ul>
<li><code>int i;</code> 可以对应 <code>int *p = new int;</code></li>
<li>还存在一种形式：<code>int *p = new int();</code>，虽然我们不能 <code>int i();</code> 来定义变量。这个其实是<strong>值初始化</strong>，后文会提到。</li>
</ul>
<p>copy initialization</p>
<ul>
<li><code>int i = 12;</code> 无法严格对应，但好在拷贝初始化还有更正统的写法</li>
<li><code>int i(12);</code> 可以对应 <code>int *p = new int(12);</code></li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>要讲构造函数，我们就得进入类类型（class type），我们无法使用内置类型来讲解构造函数。</p>
<p>从类类型的角度来说，所有的初始化都是匹配参数，找到与之对应的构造函数并执行。参考 <a href="http://www.cplusplus.com/reference/string/string/string/"><code>std::string</code> 类的构造</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default (1)	</span></span><br><span class="line"><span class="built_in">string</span>();</span><br><span class="line"><span class="comment">// copy (2)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);</span><br><span class="line"><span class="comment">// substring (3)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> len = npos);</span><br><span class="line"><span class="comment">// from c-string (4)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line"><span class="comment">// from buffer (5)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">// fill (6)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="keyword">size_t</span> n, <span class="keyword">char</span> c);</span><br><span class="line"><span class="comment">// range (7)	</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">string</span>  (InputIterator first, InputIterator last);</span><br><span class="line"><span class="comment">// initializer list (8)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="built_in">initializer_list</span>&lt;<span class="keyword">char</span>&gt; il);</span><br><span class="line"><span class="comment">// move (9)	</span></span><br><span class="line"><span class="built_in">string</span> (<span class="built_in">string</span>&amp;&amp; str) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的构造实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string constructor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s0</span> <span class="params">(<span class="string">&quot;Initial string&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s1;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span> <span class="params">(s0)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s3</span> <span class="params">(s0, <span class="number">8</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s4</span> <span class="params">(<span class="string">&quot;A character sequence&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s5</span> <span class="params">(<span class="string">&quot;Another character sequence&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6a</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s6b</span> <span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;      <span class="comment">// 42 is the ASCII code for &#x27;*&#x27;</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s7</span> <span class="params">(s0.begin(), s0.begin()+<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\ns2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\ns3: &quot;</span> &lt;&lt; s3;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\ns4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="string">&quot;\ns5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="string">&quot;\ns6a: &quot;</span> &lt;&lt; s6a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\ns6b: &quot;</span> &lt;&lt; s6b &lt;&lt; <span class="string">&quot;\ns7: &quot;</span> &lt;&lt; s7 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这么多构造函数每一个都有其特点。但其中 1、2、9是最具通用性的，是所有类的共性。因为其特殊性，所以也就值得拥有名字。</p>
<ul>
<li>1 默认构造函数，在默认初始化时执行；</li>
<li>2 拷贝构造函数，在拷贝初始化时执行；</li>
<li>9 移动拷贝构造函数，</li>
<li>其余的我们可以统称为“直接初始化”</li>
</ul>
<blockquote>
<p>Initializes an object from explicit set of constructor arguments. <a href="http://en.cppreference.com/w/cpp/language/direct_initialization">引用来源-direct initialization</a></p>
</blockquote>
<p>接下来“斤斤计较”一些，前文提到所有的初始化都是调用相应的构造函数而已（参数匹配），函数调用的形式就是使用括号 <code>()</code>，但除此之外，C++ 也提供了两种其他的形式调用构造函数：</p>
<ul>
<li>使用等号 <code>=</code></li>
<li>使用花括号 <code>&#123;&#125;</code></li>
</ul>
<p>恶心的是是这三种书写形式都不具有“全局适用性”——我自己造的词，三种书写形式都有广泛适用性，但又各有不足，不能调用 XXX 形式的构造函数——即便是使用 <code>()</code> 来调用构造函数也有其不能用的情况。接下里我们详细叙述：</p>
<h2 id="使用括号调用"><a href="#使用括号调用" class="headerlink" title="使用括号调用"></a>使用括号调用</h2><p>按道理来说，既然所有的函数调用都是使用 <code>()</code> 来完成，那么调用构造函数应该也没啥问题才对，囧。先说结论—— <code>()</code> 调用不能适用于默认构造函数。问题出现 C++ 的语法解析上，其优先解释成函数声明。如果我们这么写 <code> MyClass obj();</code> 表示调用 MyClass 的默认构造函数来初始化 obj 对象，那么我们怎么声明“返回 MyClass 类型的空参数函数”呢？或许可以这么写 <code>MyClass obj(void);</code>，我不确定是否是一种解决方案，即便可行，那么以前写的代码怎么办呢？解决方式就是我们这么多年一直写的 <code>MyClass obj;</code>，这样就调用默认构造函数了，囧。</p>
<p>有一种略显丑陋的写法，<del>似乎是</del>满足了使用圆括号调用默认构造函数 <code>MyClass obj = MyClass();</code>。</p>
<p>ps：它是“使用默认构造函数初始得到一临时变量，然后又使用这个临时变量调用拷贝构造函数初始化的 obj 对象”吗？no，使用 g++ 验证，只执行了默认构造函数，未执行拷贝构造函数，猜测是直接使用默认构造函数构建了 obj 对象。</p>
<h2 id="使用等号调用"><a href="#使用等号调用" class="headerlink" title="使用等号调用"></a>使用等号调用</h2><p>前文说 <code>=</code> 用来调用拷贝构造函数，严格来说并不准确。在 C++11 标准之前，<code>=</code> 可以用来调用所有【只有单独一个参数的】构造函数：</p>
<ol>
<li>一个参数，其余参数都有默认值的可以吗？ ok </li>
<li>怎么定义“copy initialization”这个概念，狭义的 or 广义的？ 我个人更倾向于限制性更强的定义，从相同类型的变量拷贝 </li>
<li>隐式类型转换）；</li>
</ol>
<p>在 C++11 之后，<code>=</code> 更是可以和 <code>&#123;&#125;</code> 组合用来调用所有的构造函数，但此种情形其实只是 <code>&#123;&#125;</code> 调用的变形。所以，如果使用 <code>=</code>（且不使用 <code>&#123;&#125;</code>）就不能调用多参数（<del>两个及其以上？</del> 两个及其以上无默认值）的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// other functions</span></span><br><span class="line">  Student(<span class="keyword">const</span> <span class="built_in">string</span> name, <span class="keyword">bool</span> gender = <span class="literal">true</span>, <span class="keyword">unsigned</span> age = <span class="number">20</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// some parameters</span></span><br><span class="line">  <span class="built_in">string</span> m_name;</span><br><span class="line">  <span class="keyword">bool</span> m_gender;</span><br><span class="line">  <span class="keyword">unsigned</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Student niel = <span class="string">&quot;niel&quot;</span>; <span class="comment">// it is wrong</span></span><br><span class="line">  Student <span class="keyword">long</span> = <span class="built_in">string</span>(<span class="string">&quot;long&quot;</span>);  <span class="comment">// it is OK.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《C++ Primer》第 263 页“隐式的类类型转化”中明确提到：只允许一步类类型转化。</p>
<h2 id="使用花括号调用"><a href="#使用花括号调用" class="headerlink" title="使用花括号调用"></a>使用花括号调用</h2><p>在 C++11 之前，容器类无法使用一个序列初始化。直到在 C++11 中新添了 <a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><code>initializer_list</code> 标准库类型</a>，其形式 <code>&#123;a,b,c&#125;;</code>，以此 <code>Container x = &#123;a,b,c&#125;;</code>。在此基础上，扩展 <code>&#123;&#125;</code> 的使用场景（依据？），不仅仅可以用在所有使用 <code>()</code> 的场景，还可以用来默认初始化 <code>MyClass obj&#123;&#125;;</code>，用来调用构造函数创建临时变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str&#123;&#125;;</span><br><span class="line"><span class="comment">// str = (&quot;abc&quot;, 2);</span></span><br><span class="line">str = &#123;<span class="string">&quot;abc&quot;</span>, <span class="number">2</span>&#125;;  <span class="comment">// it is OK.</span></span><br></pre></td></tr></table></figure>
<p>这种使用 <code>&#123;&#125;</code> 来初始化对象的形式被称为“列表初始化”，可以表现默认初始化、拷贝初始化、STL 容器的初始化等等。</p>
<blockquote>
<p>Initializes an object from braced-init-list <a href="http://en.cppreference.com/w/cpp/language/list_initialization">引用来源-list initialization</a></p>
</blockquote>
<h3 id="美中不足"><a href="#美中不足" class="headerlink" title="美中不足"></a>美中不足</h3><p>我原本以为 <code>&#123;&#125;</code> 是“全局适用”的，是可以用来调用所有构造函数的语法特性，囧，理论上应该是。问题是它有时候不会调用我们预期的构造函数，因为 <code>&#123;&#125;</code> 优先解析成 <code>initializer_list</code>。举例来说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 42 is the ASCII code for &#x27;*&#x27;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str0</span> <span class="params">(<span class="number">42</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;  <span class="comment">// 42 个 ‘x’ 的字符串</span></span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="number">42</span>, <span class="string">&#x27;x&#x27;</span>&#125;;    <span class="comment">// WOW，str 的值是 “*x”，而非我们更直观理解的“42 个 x”</span></span><br><span class="line">str = &#123;<span class="number">42</span>, <span class="string">&#x27;a&#x27;</span>&#125;;        <span class="comment">// 将 str 的值改为了 “*a”</span></span><br></pre></td></tr></table></figure>
<p>语法解析时更倾向于 <code>&#123;&#39;*&#39;, &#39;x&#39;&#125;</code> 的序列，而非等价于 <code>(42, &#39;x&#39;)</code>，使用 <code>&#123;&#125;</code> 应该怎么调用 <code>string(size_t n, char c);</code> 构造函数呢？ no idea。ps <code>string str(&#39;*&#39;, &#39;x&#39;)</code> 是 42 个 ‘x’ 的字符串。</p>
<blockquote>
<p>A <code>std::initializer_list</code> object is automatically constructed when:</p>
<ul>
<li>a braced-init-list is used in list-initialization, including function-call list initialization and assignment expressions</li>
<li>a braced-init-list is bound to auto, including in a ranged for loop</li>
</ul>
</blockquote>
<p>推荐 《Effective Modern C++》 Item 7: Distinguish between <code>()</code> and <code>&#123;&#125;</code> when creating objects.</p>
<p><strong>备忘：</strong>实际测试代码，见 Debian8Light 虚拟机 /home/vimer/see-the-world/code/initializer_learn/MyString 目录。后续修改时将 Demo 嵌到合适的位置。</p>
<h2 id="new-调用构造函数"><a href="#new-调用构造函数" class="headerlink" title="new 调用构造函数"></a>new 调用构造函数</h2><p>显然 <code>new</code> 操作不能通过 <code>=</code> 来匹配构造函数，它可以使用 <code>()</code> 和 <code>&#123;&#125;</code>，所受的限制和之前一致，唯一的不同之处是此时可以使用 <code>new MyClass();</code> 来调用默认构造函数。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>拷贝构造函数和拷贝赋值运算符</p>
<p> <code>=</code> 可以用来初始化，可以用来赋值。不同情况下调用的函数不同。强调一遍又一遍，有 <code>=</code> 不一定是赋值操作。</p>
</li>
<li><p><code>std::initializer_list</code> 和  <a href="http://en.cppreference.com/w/cpp/language/initializer_list">member initializer list</a></p>
<p> 前者是标准库类型，后者是在构造函数中初始化成员变量的。</p>
</li>
<li><p>关于 <code>std::initializer_list</code> 类型，推荐一篇帖子：<a href="http://www.cnblogs.com/lysuns/p/4278589.html">C++11中新特性之：initializer_list详解</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo">Is it better to use C void arguments “void foo(void)” or not “void foo()”?</a></p>
</li>
</ol>
<h1 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h1><p>值初始化到底是什么？对此一直都有困惑，和 <code>new Type；</code> <code>new Type();</code> 两者之间的区别有关系吗？和容器类初始化每个元素的“初始化器”有关系吗？</p>
<blockquote>
<p>This is the initialization performed when a variable is constructed with <strong>an empty initializer.</strong> <a href="http://en.cppreference.com/w/cpp/language/value_initialization">引用来源-value initialization</a></p>
</blockquote>
<p>我们来和“默认初始化”（或者叫做“缺省初始化”）的定义对比一下：</p>
<blockquote>
<p>This is the initialization performed when a variable is constructed with <strong>no initializer.</strong></p>
</blockquote>
<p>我们前面提到，以下形式都会调用默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj;                   <span class="comment">// (1)</span></span><br><span class="line">MyClass obj2 = MyClass();</span><br><span class="line">MyClass obj3&#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyClass *p = <span class="keyword">new</span> MyClass;      <span class="comment">// (4)</span></span><br><span class="line">MyClass *p = <span class="keyword">new</span> MyClass();</span><br><span class="line">MyClass *p = <span class="keyword">new</span> MyClass&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这要学究式地较真起来，1 和 4 是“no initializer”，所以是缺省初始化；其它 4 个是“empty initializer”，所以是值初始化。</p>
<p>这两者在初始化类类型的时候没有区别，都是调用默认构造函数。差别发生在初始化内置类型的时候，默认初始化是“向前看齐”（C 语言）妥协的结果，前面已经介绍过“默认值到底是什么”；值初始化是新时代的新态度，总是会有初值的。在 <a href="https://tnie.github.io/2016/12/15/POD/">《POD 类型》</a> 中有一个表格，执行 <code>new</code> 的结果表示了同样的结果。其参考来源于维基百科。</p>
<p>关于值初始化的更详细结果请移步 <a href="http://en.cppreference.com/w/cpp/language/value_initialization">The effects of value initialization</a> 一节：</p>
<ol>
<li><p>大括号的“意外”</p>
<blockquote>
<p>In all cases, if the empty pair of braces {} is used and T is an aggregate type, <a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization">aggregate-initialization</a> is performed instead of value-initialization.</p>
<p>If T is a class type that has no default constructor but has a constructor taking <code>std::initializer_list</code>, list-initialization is performed.</p>
</blockquote>
</li>
<li><p>数组类型</p>
<blockquote>
<p>if T is an array type, each element of the array is value-initialized;</p>
</blockquote>
</li>
</ol>
<p>何为 aggregate-initialization 呢？</p>
<blockquote>
<p>Initializes an aggregate from braced-init-list <a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization">引用来源-aggregate initialization</a></p>
<p>Aggregate initialization is a form of list-initialization, which initializes aggregates</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++ 中的初始化，经历了由少变多，由简入繁，让人不胜其烦；但从 C++11 开始，踏上了由繁入简的尝试。</p>
<p>有哪些 xxx-initialization 呢？除了上面提到的，其实还有一些概念……</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_initialization">copy initialization</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/direct_initialization">direct initialization</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization">aggregate initialization</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/list_initialization">list initialization</a></li>
<li>Dividing line</li>
<li><a href="http://en.cppreference.com/w/cpp/language/zero_initialization">zero initialization</a></li>
</ul>
<p>看完以上整理的内容，可以再看几篇问答：</p>
<ul>
<li><a href="https://www.zhihu.com/question/36735960/answer/68902926">C++值初始化，默认初始化，以及其他初始化类型的区别？</a></li>
<li><a href="http://stackoverflow.com/questions/29765961/default-value-and-zero-initialization-mess">Default, value and zero initialization mess</a></li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
  </entry>
  <entry>
    <title>共享库 &amp; 静态库</title>
    <url>/2016/12/09/library-static-dynamic/</url>
    <content><![CDATA[<p>2015年12月11日 14:53:34</p>
<p>通常情况下，对函数库的链接是放在编译时期（compile time）完成的，所有相关的对象文件（object file）与牵涉到的函数库（library）被链接合成一个可执行文件（executable file）。程序在运行时，与函数库再无瓜葛，因为所有需要的函数已拷贝到自己门下。所以这些函数库被成为静态库（static libaray），通常文件名为“libxxx.a”的形式。<br>其实，我们也可以把对一些库函数的链接载入推迟到程序运行的时期（runtime），这就是如雷贯耳的动态链接库（dynamic link library）技术。</p>
<h1 id="静态库概念"><a href="#静态库概念" class="headerlink" title="静态库概念"></a>静态库概念</h1><ol>
<li>库是预编译的目标文件（object  files）的集合，它们可以被链接进程序。静态库以后缀为“.a”的特殊的存档（archive file）存储。</li>
<li>标准系统库可在目录 <code>/usr/lib</code> 与 <code>/lib</code> 中找到。比如，在类 Unix 系统中 C 语言的数学库一般存储为文件 <code>/usr/lib/libm.a</code>。该库中函数的原型声明在头文件 <code>/usr/include/math.h</code> 中。</li>
<li>C 标准库本身存储为 <code>/usr/lib/libc.a</code>，它包含 ANSI/ISO 标准指定的函数，比如 <code>printf</code>。对每一个 C 程序来说，<code>libc.a</code> 都默认被链接。</li>
<li>静态库的优点是可以在不用重新<strong>编译</strong>程序<strong>库</strong>代码的情况下，进行程序的<strong>重新链接</strong>，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长的时间）。静态库的另一个优点是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。</li>
</ol>
<a id="more"></a>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在程序中调用数学库 <code>libm.a</code> 中 <code>sin</code> 函数，保存为 <code>main.c</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">sin</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the result:%f\n&quot;</span>,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接使用 <code>gcc main.c -o main</code>，则会出现错误：undefined  reference to ‘sin’。解释：</p>
<ol>
<li><p>函数 <code>sin()</code>，未在本程序中定义，也不在默认库’libc.a’中，除非被指定，编译器不会自主链接’libm.a’。</p>
</li>
<li><p>为使编译器能将 <code>sin()</code> 链接进主程序‘main.c’，需要提供数学库‘libm.a’.。</p>
</li>
<li><p>使用方法：<code>gcc  main.c -o main /usr/lib/libm.a</code> 或 <code>gcc  main.c -o main /usr/lib64/libm.a</code>（具体视操作系统而定） </p>
<p> 以上可以编译通过。为了避免在命令行中指定长的路径（其实有更深、更充分的原因，稍后讲解），编译器为链接函数库提供了快捷的选项 <code>-l</code>。因此可以使用下面的方法： <code>gcc  main.c -lm –o main</code>。略作说明：</p>
<ul>
<li><p>选项 <code>-lNAME</code> 使用连接器尝试链接系统库目录中的函数库文件 libNAME.a；</p>
</li>
<li><p>此实例使用 gcc 编译，如果使用 g++ 编译、链接，会成功生成可执行文件。</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/diff-g++-gcc-link.png"></p>
</li>
</ul>
</li>
</ol>
<h1 id="动态库概念"><a href="#动态库概念" class="headerlink" title="动态库概念"></a>动态库概念</h1><ol>
<li><p>动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。</p>
</li>
<li><p>动态链接库的名称有别名（soname）、真名（realname）和链接名（linker name）。别名由一个前缀 lib，然后是库的名字，再加上一个后缀“.so”构成。真名是动态链接库真实名称，一般总是在别名的基础加上一个小版本号，发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。（更详细的内容在第 6 章讲述共享库的版本时展开）</p>
</li>
<li><p>在动态链接库安装的时候，总是复制文件到某个目录下，然后用一个软连接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。</p>
</li>
<li><p>把库函数推迟到程序运行时期载入的好处：</p>
<ul>
<li>可以实现进程之间的资源共享；</li>
<li>将一些程序升级变得简单；</li>
<li>甚至可以真正做到链接载入完全由程序员在程序代码中控制；</li>
</ul>
</li>
</ol>
<h1 id="生成链接库"><a href="#生成链接库" class="headerlink" title="生成链接库"></a>生成链接库</h1><p>在具体讲解链接库的生成和使用之前，先创建以下程序文件。在 test 文件夹下创建 main.c \ add.c \ sub.c \ test.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add=:%d\n&quot;</span>,add(<span class="number">5</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sub=:%d\n&quot;</span>,sub(<span class="number">5</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* add.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sub.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* test.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TESTMATH__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TESTMATH__</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#enddif <span class="comment">//__TESTMATH__</span></span></span><br></pre></td></tr></table></figure>
<p>代码上两者没有区别，主要在于编译命令的不同。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>将目标文件用 <code>ar</code> 命令打包就可以：<code>ar</code> 是 archive 的缩写，也就是归档的意思，平时我们用得更多的是另一条归档命令 <code>tar</code>。<code>ar</code>和 <code>tar</code> 的功能其实比较类似，但 <code>ar</code> 命令做了一些额外的处理，它会为被归档的目标文件中的符号建立索引，当和应用程序链接时，建立的这些索引将回收链接过程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">ar -rcs libtest.a add.o sub.o</span><br></pre></td></tr></table></figure>
<h2 id="共享库-动态库"><a href="#共享库-动态库" class="headerlink" title="共享库/动态库"></a>共享库/动态库</h2><p>也是使用目标文件。但生成目标文件时要加编译器选项 <code>-fpic</code>；生成动态库时使用链接器选项 <code>-shared</code>。在编译的时候（即生成目标文件的时候），我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址不相关代码（Position Independent Code （PIC））； -shared：生成共享目标文件，通常用于建立共享库时使用。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -c add.c -o add.o</span><br><span class="line">gcc -fPIC -c sub.c -o sub.o</span><br><span class="line">gcc -shared –o libtest.so  add.o sub.o</span><br><span class="line"><span class="comment"># 以上两步也可以合成一步搞定：</span></span><br><span class="line">gcc  add.c sub.c -fPIC -shared -o libtest.so</span><br></pre></td></tr></table></figure>
<h1 id="使用链接库"><a href="#使用链接库" class="headerlink" title="使用链接库"></a>使用链接库</h1><p>静态库的名字形式为”libxxx.a”，后缀名为”.a”；共享库/动态库的名字形式为 “libxxx.so”，后缀名为 “.so”。</p>
<p>静态库和动态库的使用基本一样，用的是 <code>-Lpath</code> 和 <code>-lxxx</code> 标签。编译器会先在 path 文件夹下搜索 libxxx.so 文件，如果没有找到，继续搜索 libxxx.a（静态库）。当指定 <code>-static</code> 标签时，表示禁止使用共享库，则不会搜索 libxxx.so 文件，直接搜索 libxxx.a（静态库）。</p>
<p>动态库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main -ltest -L.</span><br></pre></td></tr></table></figure>
<p>静态链接库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main -ltest -L. -static    <span class="comment"># -static：禁止使用共享库。</span></span><br></pre></td></tr></table></figure>
<p>也可以这样使用链接库（不推荐，但适用于非规则命名的链接库 eg 无 lib 前缀的）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main libadd.a    <span class="comment">#使用gcc命令带上库文件就OK了</span></span><br><span class="line">gcc main.c -o main libadd.so</span><br></pre></td></tr></table></figure>
<h2 id="动态链接库-vs-静态链接库"><a href="#动态链接库-vs-静态链接库" class="headerlink" title="动态链接库 vs. 静态链接库"></a>动态链接库 vs. 静态链接库</h2><p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/shared-first-1.png"></p>
<p>通过上图的对比可以验证，链接程序在链接时是优先链接的动态库。如果打算使用静态库：情况一，指定目录下同时存在动态库、静态库，需用 <code>-static</code> 参数指定链接静态库；情况二，指定目录只有静态库，则可以不用 <code>-static</code>。</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/shared-first-2.png"></p>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>静态库的使用到这里已经结束了。这一节是要说使用动态库的主程序运行的问题。</p>
<p>看到这里，不知是否有注意到使用动态链接库生成可执行文件，执行 <code>./main</code> 时报错。这是因为程序运行时没有找到动态库造成的。程序编译时链接动态库和运行时使用动态库的概念是不同的，在运行时，程序链接的动态库需要在系统目录下才行。</p>
<p>我们可以通过 <code>ldd</code> 命令查看某程序当前对动态链接库的依赖情况：</p>
<p><img src="https://raw.githubusercontent.com/nielon/MarkdownPhotos/master/ldd.png"></p>
<p><code>ldd</code> 的结果表明了我们生成的 libtest.so 找不到。因为动态库是一个可以共享的文件，因此往往存放在一个公共的位置，在 Linux 系统中程序查找动态链接库的规则如下：</p>
<ol>
<li>首先在环境变量 LD_LIBRARY_PATH 所记录的路径中查找。</li>
<li>然后从缓存文件 /etc/ld.so.cache 中查找。</li>
<li>如果上述步骤都找不到，则到默认的系统路径（具体呢？）中查找，先是 /lib 然后是 /usr/lib。</li>
</ol>
<p>很明显，这几个路径都不包含当前路径。相应的，使用以下方法可以解决此问题：</p>
<ul>
<li><p>在 linux 下最方便的解决方案是拷贝 libtest.so 到绝对目录 /lib 下（需要 root 用户权限）；</p>
</li>
<li><p>将动态库的目录放到程序搜索路径中，可以通过定义名为 LD_LIBRARY_PATH 的环境变量来实现：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rmq@baba-db01:~/cts2/nielong/<span class="built_in">test</span>&gt; <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:~/cts2/nielong/<span class="built_in">test</span>/</span><br><span class="line">rmq@baba-db01:~/cts2/nielong/<span class="built_in">test</span>&gt; <span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">:/data/rmq/cts2/nielong/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h1 id="动态库的版本问题"><a href="#动态库的版本问题" class="headerlink" title="动态库的版本问题"></a>动态库的版本问题</h1></li>
</ul>
<p>前面章节介绍动态库时好些地方都做了简化，包括动态库的命名和生成、动态库的查找目录及查找顺序，动态库在编译环境和运行环境中的区别。</p>
<h2 id="版本及命名"><a href="#版本及命名" class="headerlink" title="版本及命名"></a>版本及命名</h2><p><a href="http://linux-wiki.cn/wiki/zh-hans/%E5%8A%A8%E6%80%81%E5%BA%93(.so)">参考链接</a></p>
<p>动态库的版本总是个问题，如果编译时链接的库和执行时提供的不一样，难免会导致程序的执行发生诡异的错误。为解决此问题，Linux系列的做法是这样的：</p>
<p>首先，每个so文件有一个文件名，如libABC.so.x.y.z，这里ABC是库名称，x.y.z是文件的版本号，一般来说：</p>
<ul>
<li>第一位x表示了兼容性，x不一样的so文件是不能兼容的。</li>
<li>第二位y的变化表示可能引入了新的特性（Feature），但总的来讲还是兼容的。</li>
<li>第三位z的变化一般表示仅是修正了Bug。</li>
<li>并非所有.so文件都遵循此规则，但其应用确实很普遍。</li>
</ul>
<p>在系统中，会存在一些符号链接， 如</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">libpam.so -&gt; libpam.so.0.83.0</span><br><span class="line">libpam.so.0 -&gt; libpam.so.0.83.0</span><br></pre></td></tr></table></figure>
<p>其中第一个（linker name）主要在使用该库<strong>开发</strong>其它程序时使用，比如gcc想连接PAM库，直接连libpam.so就行了，不必在链接时给出它的具体版本。第二个（soname）则主要用在<strong>运行</strong>时，因为前面说了第一位版本一样的库是互相兼容的，所以程序运行时只要试图连接libpam.so.0就够了，不必在意其具体的版本（在前面章节针对这两者是没有区分的）。ldconfig(8) 可以自动生成这些链接。</p>
<p>ldconfig 检查存在的 real name 文件，并且创建指向它的符号链接 soname 文件。ldconfig 还做一件事情就是建立 cache 文件 /etc/ld.so.cache。</p>
<p>那么编译程序时gcc在链接一个so文件（如libpam.so）时，如何知道该程序运行时链接哪个文件呢（上例中是libpam.so.0）？原来产生so文件时，可以指定一个soname，一般形如libABC.so.x。人们编译可执行文件时，如果链接了某个so，存在可执行文件里的.so文件名并不是其全名，而是这个soname。比如上例中，这个soname就是libpam.so.0。</p>
<h2 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h2><p><a href="http://littlewhite.us/archives/301">参考链接</a></p>
<p>更细致的生成动态库的操作为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc hello.c -fPIC -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0.1</span><br></pre></td></tr></table></figure>
<p>需要注意的参数是 <code>-Wl,-soname</code>（中间没有空格），<code>-Wl</code> 选项告诉编译器将后面的参数传递给链接器，<code>-soname</code> 则指定了动态库的 soname（简单共享名，Short for shared object name）。</p>
<p>现在我们生成了 libhello.so.0.0.1，当我们运行 <code>ldconfig -n .</code> 命令时，当前目录会多一个软连接（普通用户执行 <code>ldconfig</code> 时可能提示找不到命令，环境变量的问题，指明路径就可以了 <code>/sbin/ldconfig -n .</code>）。这个软链接是如何生成的呢，并不是截取 libhello.so.0.0.1 名字的前面部分，而是根据 libhello.so.0.0.1 编译时指定的 <code>-soname</code> 生成的。也就是说我们在编译动态库时通过 <code>-soname</code> 指定的名字，已经记载到了动态库的二进制数据里面。不管程序是否按 libxxx.so.a.b.c 格式命名，但 Linux 上几乎所有动态库在编译时都指定了 <code>-soname</code>，我们可以通过 <code>readelf</code> 工具查看 soname。</p>
<p>关键就是这个soname，它相当于一个中间者，当我们的动态库只是升级一个小版本时，我们可以让它的soname相同，而可执行程序只认soname指定的动态库，这样依赖这个动态库的可执行程序不需重新编译就能使用新版动态库的特性。</p>
<h3 id="库的放置"><a href="#库的放置" class="headerlink" title="库的放置"></a>库的放置</h3><p><a href="http://blog.csdn.net/ldong2007/article/details/3194187">参考链接</a></p>
<p>动态库必须放置在文件系统的指定位置。</p>
<ol>
<li>多数开源软件遵守GNU 标准：当分发源代码的时候，库默认安装在 /usr/local/lib，命令安装在 /usr/local/bin。该标准还定义了如何重写这些默认标准以及如何调用安装程序。</li>
<li>Filesystem Hierarchy Standard(FHS) 规定：多数库应安装在 /usr/lib，启动时需要的库安装在 /lib，非系统库应安装在 /usr/local/lib</li>
</ol>
<p>GNU 标准是针对开发人员的，FHS 是针对发行者的。</p>
<h2 id="使用动态库：可执行程序的编译"><a href="#使用动态库：可执行程序的编译" class="headerlink" title="使用动态库：可执行程序的编译"></a>使用动态库：可执行程序的编译</h2><p>在Linux下，编译时指定-lhello，链接器会去寻找 libhello.so 这样的文件，当前目录下没有这个文件，所以报错。一般通过建立这样一个软链接解决此问题。</p>
<p>生成可执行文件之后，使用 ldd 查看其依赖的动态库。发现main程序依赖的动态库名字是 libhello.so.0，既不是 libhello.so 也不是 libhello.so.0.0.1。其实在生成 main 程序的过程有如下几步：</p>
<ol>
<li>链接器通过编译命令 <code>-L. -lhello</code> 在当前目录查找 libhello.so 文件</li>
<li>读取 libhello.so 链接指向的实际文件，这里是 libhello.so.0.0.1</li>
<li>读取 libhello.so.0.0.1 中的 SONAME，这里是 libhello.so.0</li>
<li>将 libhello.so.0 记录到 main 程序的二进制数据里</li>
</ol>
<p>也就是说 libhello.so.0 是已经存储到 main 程序的二进制数据里的，不管这个程序在哪里，通过 ldd 查看它依赖的动态库都是 libhello.so.0</p>
<h2 id="使用动态库：可执行程序的运行"><a href="#使用动态库：可执行程序的运行" class="headerlink" title="使用动态库：可执行程序的运行"></a>使用动态库：可执行程序的运行</h2><p>至此，我们知道了<strong>程序运行时需要寻找的动态库文件名其实是动态库编译时指定的SONAME</strong>，即 libhello.so.0，但它会去哪里找这个文件呢？</p>
<p><del>参考另一篇笔记《build.md》（还在整理中，未发布），其中详细介绍了程序执行时动态库的查找路径及查找顺序。</del>尴了个尬，那篇笔记里只描述了预处理阶段查找头文件的路径及其查找顺序。</p>
<p>需要强调的是，当出现共享库找不到时，并 <a href="http://xahlee.info/UnixResource_dir/_/ldpath.html">不推荐设置 LD_LIBRARY_PATH 变量</a>。而应该在生成可执行文件时做出修改，不单单使用 <code>-L</code> 指定编译时链接路径，也要使用 <code>-R</code>（<code>-rpath</code>） 指定运行时查找路径。<code>-Wl,-rpath</code> 举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔</span><br><span class="line">gcc -Wl,-rpath,libPath -L libPath -ltest hello.c</span><br></pre></td></tr></table></figure>
<p>将搜索路径信息写入可执行文件（rpath 代表 runtime path）。这样就不需要设置环境变量。坏处是，如果库文件移动位置，我们需要重新编译test。</p>
<h3 id="Wl-rpath"><a href="#Wl-rpath" class="headerlink" title="-Wl,-rpath"></a>-Wl,-rpath</h3><p><a href="http://stackoverflow.com/questions/6562403/i-dont-understand-wl-rpath-wl">参考链接</a></p>
<p>man gcc:</p>
<blockquote>
<p>-Wl,option</p>
<p>Pass option as an option to the linker. If option contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example, <code>-Wl,-Map,output.map</code> passes <code>-Map output.map</code> to the linker. When using the GNU linker, you can also get the same effect with `-Wl,-Map=output.map’.</p>
</blockquote>
<p>man ld:</p>
<blockquote>
<p>-rpath=dir</p>
<p>Add a directory to the runtime library search path. This is used when linking an ELF executable with shared objects. All -rpath arguments are concatenated and passed to the runtime linker, which uses them to locate shared objects at runtime. The -rpath option is also used when locating shared objects which are needed by shared objects explicitly included in the link;</p>
</blockquote>
<p><code>-Wl</code> 是 gcc 的参数，用来将后续的内容传给连接器；<br><code>-rpath</code> 是 ld 的参数，用来指定运行时库的查找路径；其<strong>并非 gcc</strong> 的参数。</p>
<p>指定多个动态库搜索路径的写法：（严格控制空格的存在）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ $^ -o $@ $&#123;LDFLAGS&#125; $&#123;LDLIBS&#125; -Wl,-rpath -Wl,$&#123;LD_RUN_PATH1&#125; -Wl,-rpath -Wl,$&#123;LD_RUN_PATH2&#125;</span><br><span class="line"># or</span><br><span class="line">g++ $^ -o $@ $&#123;LDFLAGS&#125; $&#123;LDLIBS&#125; -Wl,-rpath -Wl,$&#123;LD_RUN_PATH1&#125;:$&#123;LD_RUN_PATH2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库是如何被使用的"><a href="#库是如何被使用的" class="headerlink" title="库是如何被使用的"></a>库是如何被使用的</h3><p><a href="http://blog.csdn.net/ldong2007/article/details/3194187">参考链接</a></p>
<p>在基于 GNU glibc 的系统上，包括所有 linux 系统，ELF 可执行二进制文件的运行自动导致程序加载器被加载并且运行。在 linux 下，加载器是 /lib/ld-linux.so.X（X是版本号）。然后加载器搜索、加载程序所要使用的动态链接库。</p>
<p>被搜索的文件夹列表保存在文件 /etc/ld.so.conf 里。</p>
<p>在程序启动的时候搜索这些文件夹是很没有效率的，所以实际上使用缓存。ldconfig(8) 默认读取 /etc/ld.so.conf 文件，在 DLL 文件夹里创建合适的符号链接，在 /etc/ld.so.cache 里写入一个缓存。缓存大大加速了库的读取。所以，当一个 DLL 被添加、删除时，或DLL文件夹被改变时都需要运行 ldconfig 程序，当安装了一个新的 DLL 时，由软件包管理器自动运行 ldconfig。当程序启动时，装载器实际使用的是缓存。</p>
<h2 id="动态库版本更新"><a href="#动态库版本更新" class="headerlink" title="动态库版本更新"></a>动态库版本更新</h2><p>看懂了以上内容，动态库怎么进行版本更新就只是上述原理的应用而已。如果还有疑惑，见 <a href="http://littlewhite.us/archives/301">参考链接</a></p>
<h1 id="动态库的显示调用"><a href="#动态库的显示调用" class="headerlink" title="动态库的显示调用"></a>动态库的显示调用</h1><p>以上使用动态链接库的方式可以称为隐式调用，相对应的显式调用是使用 linux 提供 <code>dlopen</code>、<code>dlsym</code>、<code>dlerror</code> 和 <code>dlcolose</code> 函数获取动态链接库。</p>
<p>关于显式调用，可以参考：<a href="http://www.cnblogs.com/Xiao_bird/archive/2010/03/01/1675821.html">Linux下动态链接库的使用</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>静态绑定 &amp; 动态绑定</title>
    <url>/2016/11/30/statically-bound-And-dynamically-bound/</url>
    <content><![CDATA[<p>从理解静态绑定 &amp; 动态绑定开始，没想到又扯出静态类型 &amp; 动态类型，编译期多态 &amp; 运行期多态。但这些本来就是一体的。</p>
<h1 id="静态绑定-amp-动态绑定"><a href="#静态绑定-amp-动态绑定" class="headerlink" title="静态绑定 &amp; 动态绑定"></a>静态绑定 &amp; 动态绑定</h1><p>刚开始只是看完网上的几篇帖子啰嗦几句心得，落笔时什么都没参考。重新整理笔记时硬是把以前保存在 chrome 书签中帖子给塞进来，也是够难受的。<a href="http://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<ul>
<li>静态绑定（statically bound），又名前期绑定（early binding）；</li>
<li>动态绑定（dynamically bound），又名延期绑定（late binding）。</li>
</ul>
<p><em>ps 英文名称摘自《Effective C++》 条款37。此条款中有关于“静态类型、动态类型”的描述。</em></p>
<p>在 C 语言中并没有“静态绑定”、“动态绑定”的概念（至少我没有查到）。</p>
<a id="more"></a>

<p>我理解的 C++ 类的内存模型其实就是 C 语言中的 struct 结构体。但成员函数又是归属于类所有的，所以就存在函数到类的绑定。</p>
<ul>
<li>静态绑定指的就是这种绑定关系（映射关系）是在编译期间确定的；</li>
<li>动态绑定指的就是这种绑定关系（映射关系）在编译期间确定不了，得等到程序运行、执行期间才能最终确定。</li>
</ul>
<h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>有这样一个现象：空指针调用【无需解引用 *this 指针的】非虚函数，是可以正确执行的。<a href="http://blog.5ibc.net/p/60929.html">参考</a></p>
<p>对于初学者来说，可以以这个为契机去掌握“静态绑定”。参见 <a href="http://blog.csdn.net/yusiguyuan/article/details/38555435">为什么通过空指针（NULL）可以正确调用类的部分成员函数 - csdn - 鱼思故渊的专栏</a>，作者在文章开头言简意赅的介绍了这种现象为什么会出现，后面通过“将对象指针作为参数，以 non-member 函数的形式使用成员函数 + 汇编代码”进行了更深入的讲解，值得好好学习。</p>
<p><strong>课外阅读：</strong>如果看完上一篇帖子意犹未尽，可以继续看 <a href="http://kelvinh.github.io/blog/2014/03/27/cpp-tutorial-pointer-to-member-function/">C++教程：指向成员函数的指针</a>，在项目开发中基本不会用到成员函数指针，但了解这些有助于我们理解 C++ 的底层机制。阅读过程会比较吃力（关于虚函数的部分可以放到掌握继承、多态之后再学习），进度可能缓慢，但没有难点。如果寸步难行，那说明你对于 C、C++ 的底层毫无概念，真的还是个新手——很新的新手。</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>虚函数是动态绑定的基础；动态绑定是实现<strong>运行时多态</strong>的基础。<a href="http://blog.csdn.net/iicy266/article/details/11906509">五星-请阅读原文</a></p>
<p>要触发动态绑定，需满足两个条件：</p>
<ol>
<li>只有虚函数才能进行动态绑定，非虚函数不进行动态绑定。</li>
<li>必须通过基类类型的引用或指针进行函数调用。</li>
</ol>
<p>虚函数动态绑定发生在运行时，源于其设计理念、其出发点就是为了让一指针变量（或引用）根据指向的对象的实际类型（动态类型）来选择函数以实现多态性。这种选择（即动态绑定）肯定只能发生在指针变量指向某块内存（初始化）之后，同时继承体系的存在允许我们切换基类指针指向基类对象或派生类对象（赋值）。因为初始化（或者赋值）发生于运行期间，所以动态绑定也只能发生在运行期间。</p>
<p>反过来，如果不需要进行这种选择，使用哪个函数根据变量声明时的类型（静态类型）就能确定的话，那我们就可以把这个绑定往前放，因为静态类型在编译时是已知的了。</p>
<h2 id="朴素观点"><a href="#朴素观点" class="headerlink" title="朴素观点"></a>朴素观点</h2><p>我们朴素地分析一下静态绑定、动态绑定。函数都有其地址，函数调用翻译成汇编代码其实就是直接用地址，很明显在汇编代码这个层次（甚至不用这么底层，C语言层次就行）不同的函数实现有不同的地址（使用C 语言的话，就有不同的函数名），但在 C++、Java 高级语言这个层次，不同的实现可能有相同的函数名（有很多种情况：重载、不同类里面相同名称、模板、继承体系中的重写），在 C++ 代码中出现一个函数调用（函数名），怎么正确地找到对应的实现（地址）呢？</p>
<ol>
<li>重载：因为参数类型或者个数不同其实是有区分的，直接在高级语言下一个层次（比如C语言层面）使用不同的命名重新包装就可以了。调用时根据传参的情况，再映射就可以了。</li>
<li>不同的 class 里面相同名称：编译器实现这个完全可以和重载情形使用同样的方案。维护一个映射表就可以。</li>
<li>模板：暂时不了解</li>
<li>继承体系的重写：</li>
</ol>
<p>我们都知道 override 函数时，两个函数的声明式肯定是一模一样的，如果不考虑 override 的概念（具体到代码中就是不使用 <code>virtual</code> 关键字），那么其场景和上述第 2 中就是一样的——如果是 base 类型（即便是指针）就调用 base class 的函数，如果是 derived 类型就调用 derived class 的函数。事实上都是编译期间根据维护的映射表“偷梁换柱”（映射是在声明的类型（函数声明式、类类型）-具体的函数实现之间），直接把对应的地址拿过来，ok，汇编代码完成了。</p>
<p>继承体系中允许 base 指针是可以指向 derived 对象，但编译器依旧是根据声明指针时的类型去映射具体的函数实现的，所以会出现一些变态的现象：</p>
<ul>
<li>class Base 无 void func()，class Derived 有 void func()，我们执行 <code>Base *p=new Derived(); p-&gt;func();</code> 会报错找不到</li>
<li>class Base 的 void func() 打印 base，class Derived 的 void func() 打印 derived，我们执行 <code>Base *p=new Derived(); p-&gt;func();</code> 会打印出 base 纳尼</li>
<li>class myclass 有函数 simple()，函数实现中没有对 this 解引用的操作（不管是显式的还是隐在的），我们执行 <code>myclass *p=NULL； p-&gt;simple()；</code> 能够正确执行</li>
</ul>
<p>so，正如我们看到的，这就是静态绑定。</p>
<p>随着 OO 越来与流行，为了获得多态性，我们想要打破这种规则——继承体系中允许基类指针指向派生类对象，在此基础上我们想让基类指针可以调用派生类的函数，我们要让例二 <code>p-&gt;func()</code> 打印 derive 怎么办？</p>
<p>好吧，增添新的语言特性，使用关键词 <code>virtual</code>，用来表明碰到这个类的指针（或引用）调用此函数时不要根据静态类型（声明指针的类型）映射具体实现，你们要根据这个指针指向的对象的实际类型来映射具体实现（即动态绑定）。编译器说，纳尼，我靠，我哪知道啊？我只解析 declaration，只分析了变量声明的类型，内存的初始化、赋值在运行期才发生呢……好吧，编译器感觉为难做不了这个事情，只能把这个找到（绑定）函数具体实现的步骤放到运行期间了，可是效率会低一些呢。如果你要多态性，只能接受了。</p>
<p>具体实现中通过 <code>virtual</code> 关键词标记延迟绑定，然后在运行过程中，根据对象内存中的虚函数表指针获得函数地址。</p>
<p>如果不是通过指针或引用调用虚函数，也是在编译期间就绑定的【作业一？】；而没有 <code>virtual</code> 修饰的函数根据调用者的静态类型在编译期间直接绑定。</p>
<h1 id="静态类型-amp-动态类型"><a href="#静态类型-amp-动态类型" class="headerlink" title="静态类型 &amp; 动态类型"></a>静态类型 &amp; 动态类型</h1><ul>
<li>静态类型（static type）：静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。</li>
<li>动态类型（dynamic type）：动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。</li>
</ul>
<p>以上概念可以去翻书《C++ Primer》第 534 页，也可以查阅《Effective C++》的条款37。</p>
<blockquote>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
</blockquote>
<blockquote>
<p>动态类型一如其名称所示，可在程序执行过程中改变（通常是经由赋值动作）。</p>
</blockquote>
<p>动态绑定和动态类型一体两面，息息相关。在继承体系使用引用和指针，就会涉及动态类型；进一步如果继承体系中涉及虚函数（事实上必然会涉及，考虑虚析构函数），就会发生动态绑定。</p>
<h1 id="编译器多态-amp-运行期多态"><a href="#编译器多态-amp-运行期多态" class="headerlink" title="编译器多态 &amp; 运行期多态"></a>编译器多态 &amp; 运行期多态</h1><p>在 <a href="http://www.cnblogs.com/QG-whz/p/5132745.html">C++编译期多态与运行期多态</a> 开篇写到：</p>
<blockquote>
<p>在面向对象C++编程中，多态是OO三大特性之一，这种多态称为运行期多态，也称为动态多态；在泛型编程中，多态基于template(模板)的具现化与函数的重载解析，这种多态在编译期进行，因此称为编译期多态或静态多态。</p>
</blockquote>
<p>进入正文作者总结到：</p>
<blockquote>
<p>运行期多态的设计思想要归结到类继承体系的设计上去。运行期多态的实现依赖于虚函数机制。</p>
<p>对模板参数而言，多态是通过模板具现化和函数重载解析实现的。以不同的模板参数具现化导致调用不同的函数，这就是所谓的编译期多态。</p>
</blockquote>
<p>在 <a href="http://blog.csdn.net/dan15188387481/article/details/49667389">多态性之编译期多态和运行期多态(C++版)</a> 则重点强调了</p>
<blockquote>
<p>需要注意的是函数重载和多态无关，很多地方把函数重载也误认为是编译期多态，这是错误的。</p>
<p>当说到多态性的时候一般都默认指运行期多态。</p>
</blockquote>
<p>作为小人物，真心不想扯“函数重载到底算不算编译器多态？”这种问题。</p>
<h1 id="编译器-amp-运行期"><a href="#编译器-amp-运行期" class="headerlink" title="编译器 &amp; 运行期"></a>编译器 &amp; 运行期</h1><p>为什么变量的初始化（或者赋值）只能发生在运行时，而不能在编译时呢？因为分配内存发生在运行时，包括 const 常量（下文详细描述）。</p>
<p>此处有一个容易混淆的概念，我们经常区分“编译器分配内存”和“动态分配内存”，但“编译器分配内存”<strong>不是</strong>“编译期分配内存”。编译器分配内存，是说内存的分配和回收的<strong>指令（命令、函数或操作符等）</strong>不用我们这些 coder 去手工写明，当数据类型（非容器）确定时，编译器能够为我们做这些繁琐、重复且容易出错的内存分配工作，它会在汇编代码中生成内存分配和回收的<strong>命令</strong>。但编译器也只能做“确定性”的工作，不确定的或者会动态改变的情形还是需要我们 coder 使用高级语言“下指令”（动态分配内存），<del>好在可以封装</del>，比如 STL 的容器类，shared_pointer 智能指针等等。</p>
<p>内存的管理工作编译器承担了大部分，我们得以从“埋头和机器交流”中解放出来，有更多的时间关注业务。但无论是否需要我们手工“下指令”，程序向系统要内存（获取/分配），用完了把内存还给系统（释放/回收）都是发生在运行期间。</p>
<blockquote>
<p>编译期分配内存并不是说在编译期就把程序所需要的空间在内存里面分配好，而是说在程序生成的代码里面产生一些指令，由这些指令控制程序在运行的时候把内存分配好。不过分配的大小在编译的时候就是知道的，并且这些存贮单元的位置也是知道的。</p>
<p>而运行期分配内存则是说在运行期确定分配的大小，存放的位置也是在运行期才知道的。<a href="http://bbs.csdn.net/topics/60053885">引用来源</a></p>
</blockquote>
<h2 id="直观感受和理性分析"><a href="#直观感受和理性分析" class="headerlink" title="直观感受和理性分析"></a>直观感受和理性分析</h2><p>logical，就是因为变量需要内存，分配内存发生于运行时。</p>
<p>如果我们把普通 <code>const</code> 常量认为和宏一样（事实上只限于 C++编译器，且要求是直接定义的 <code>const</code> 常量），那么其编译过程我们可以这样理解：<code>const</code> 属性的变量在编译时就确定，即编译器会将这个变量出现的所有位置直接替换成值，在编译器生成的汇编代码中不会出现这个变量名称。</p>
<p>很显然 non-const 变量不可以这么做，因为它在后面的逻辑中会有更改，甚至于其初始化（或者赋值）完全依赖运行过程中的用户输入 <code>int j = atoi(argv[1]) </code>。所以在编译器生成的汇编代码中必须保留有这个变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base 类有虚函数 func()</span></span><br><span class="line"><span class="comment">// Derived 继承自 Base，且 override 了 func()</span></span><br><span class="line">Base *p=<span class="keyword">new</span> Derived(); </span><br><span class="line">p-&gt;func();</span><br></pre></td></tr></table></figure>
<p>再来回顾一下上述代码，我们觉得一目了然的事情，比如编译器汇编时直接把 <code>p-&gt;func()</code> 调用换成 <code>derived::func(p)</code> 不就好了吗，实现起来很难吗？事实上编译器是卡在它只知道 p 是 <code>base *</code> 类型，它并不知晓 p 被初始化（赋值）了什么，它只生成“得到一个地址，把这个地址赋给 base 指针 p；根据 p 指明的地址调用 func()” 的指令，至于前一条“分配内存，初始化 derived 对象”的指令，现在是前后相邻紧挨着，其他场景可能这两条指令相差十万八千里呢。事实上我们只会在测试时写 <code>Base *p=new Derived(); p-&gt;func();</code> 这样的例子，在真实的业务场景中为了效率至少应该写成 <code>Derived derived; derived.func();</code>，在能够确定类型的时候使用静态绑定效率更高。实际上真实的业务场景多是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func(base *p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// some codes</span></span><br><span class="line">  p-&gt;func();</span><br><span class="line">  <span class="comment">// other codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base *p = onePointer;</span><br><span class="line">func(p);</span><br></pre></td></tr></table></figure>
<p>正如这段代码，<strong>跨越</strong>上下文的事情，我们能轻易理解是发生在运行期，是动态绑定。我们只会困惑于上下文紧邻的情形，比如例二，比如 <code>const int i=1; const int j = i+1;</code> 后者编译器可以（但不是必须的，术语称为“优化”）帮忙处理，但例二就不行。编译器会优化吗？或许应该做个测试。</p>
<h2 id="普通-const-常量分不分配内存？"><a href="#普通-const-常量分不分配内存？" class="headerlink" title="普通 const 常量分不分配内存？"></a>普通 const 常量分不分配内存？</h2><p>帖子 <a href="http://blog.csdn.net/eric_jo/article/details/4138548">关于C++ const 的全面总结</a> 正如其标题一样，总结得非常全。其中提到一句：</p>
<blockquote>
<p> const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。</p>
<p> 编译器<strong>通常</strong>不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p>
</blockquote>
<p>刨根问底，那什么时候会分配内存呢？在 <a href="http://blog.csdn.net/eric_jo/article/details/4537694">关于Const常量内存使用</a> 一文中可以找到答案。</p>
<blockquote>
<p>C++编译器对除了直接定义的Const常量外，都是分配内存的。</p>
</blockquote>
<p>也就是声明和定义（初始化分配内存）分开的 const 常量，这种情况下编译器无法获知常量的值。关于“const 修饰类内成员变量”，除了遵循这个原则外，还有更复杂的使用限制，详情请翻书《Effective C++》条款2、条款3 和条款4。</p>
<blockquote>
<p>如果成员变量是 const 或 reference，它们就一定需要初值，不能被赋值。</p>
</blockquote>
<h1 id="写代码注意事项"><a href="#写代码注意事项" class="headerlink" title="写代码注意事项"></a>写代码注意事项</h1><ol>
<li><p>不要重新定义继承而来的非虚函数。参考《Effective C++》条款36</p>
<p> 如果基类中某个函数没有被声明为虚函数，派生类中也定义了同原型的函数的话，通过基类指针访问派生类定义的对象，调用的函数是基类中的定义，而不是派生类中的定义。</p>
<p> 这也是增加一个 virtual 关键字的意义。</p>
<blockquote>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。摘抄自《C++ Primer》第547页。</p>
</blockquote>
</li>
<li><p>不要重新定义继承而来的虚函数的缺省参数值，缺省参数值是静态绑定的。参考《Effective C++》条款37</p>
</li>
</ol>
<p>参考链接：<a href="https://www.oschina.net/question/54100_20313">a</a>、<a href="http://notes.maxwi.com/2016/08/19/static-dynamic-binding/">b</a>、</p>
<h2 id="（成员函数的）重载、覆盖与隐藏"><a href="#（成员函数的）重载、覆盖与隐藏" class="headerlink" title="（成员函数的）重载、覆盖与隐藏"></a>（成员函数的）重载、覆盖与隐藏</h2><p>覆盖，和隐藏是很不一样的两个概念，要重点区分。<a href="http://blog.csdn.net/sendy888/article/details/1739113">五星-请阅读原文</a></p>
<p>重载（overload）：同名函数变量，但属于不同的函数类型。发生在同一个作用域内，即在同一个类中。如果跨类，在父类、子类当中存在同名的函数变量（即便是不同的函数类型），如果是 virtual 性质的，就是重载（也叫继承，函数层面的继承），如果是 non-virtual 性质的，（只要子类中有一个同名函数变量没有用 virtual 修饰）就会发生隐藏——这个坑应该绕道走。</p>
<p>覆盖（override）：派生类函数覆盖基类函数，必须有 virtual 关键字修饰，且函数类型相同，函数变量命名相同。</p>
<p>隐藏（hide）：有些笔记中会写作“overwrite”，但这个词不是 C++ 中的术语，是<a href="http://stackoverflow.com/questions/4738315/c-overriding-overwriting">不规范的写法</a>。在代码层面上，隐藏很容易让人困扰，但其本质上只是嵌套作用域中命名隐藏问题。和以下代码同理。</p>
<p>ps 即便函数变量的类型不同，但编译器只关注变量的命名。如果还是似懂非懂，感到困惑，可以去翻书《C++ Primer》第 547 页。</p>
<blockquote>
<p>一如往常，名字查找先于类型检查。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">10</span>;   <span class="comment">// 调用 Print() 时，外层作用域的同名变量已经被隐藏</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">float</span> var = <span class="number">11.1</span>;</span><br><span class="line">    Print(var);   <span class="comment">// float 隐式转换成 int，打印 11</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在《Effective C++》一书条款 36 提到“绝不重新定义继承而来的 non-virtual 函数”，就是为了避免隐藏带来的问题。</p>
<p>参考书籍：<a href="https://book.douban.com/subject/25708312/">《C++ Primer》</a>、<a href="https://book.douban.com/subject/5387403/">《Effective C++》</a></p>
<p>—–以下暂时弃用<br>[08]:<a href="http://blog.csdn.net/ygzhong000/article/details/42034279">http://blog.csdn.net/ygzhong000/article/details/42034279</a><br>[09]:<a href="http://blog.csdn.net/dongpy/article/details/1118658">http://blog.csdn.net/dongpy/article/details/1118658</a><br>[07]:<a href="http://www.cnblogs.com/ztteng/p/3419843.html">http://www.cnblogs.com/ztteng/p/3419843.html</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-concept</category>
      </categories>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2016/11/03/typeConversion/</url>
    <content><![CDATA[<p>在《Effective C++》条款 27 强调<strong>尽量少做转型动作</strong>，参考此条款中的内容整理笔记。</p>
<blockquote>
<p>在 C++ 中转型是一个你会想带着极大尊重去亲近的一个特性。</p>
</blockquote>
<p>我们先回顾转型的语法，然后回过头再看怎么赋予类型转型的能力。</p>
<h1 id="隐式转型"><a href="#隐式转型" class="headerlink" title="隐式转型"></a>隐式转型</h1><p>我们经常接触的隐式转换发生于内置类型中的数值类型之间。但往往因为过于自然，反而忽略了转型动作的存在。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> dou = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// conversation happenning...</span></span><br><span class="line"><span class="keyword">double</span> sum1 = num + dou;</span><br><span class="line"><span class="keyword">int</span> sum2 = num + dou;</span><br></pre></td></tr></table></figure>
<p>隐式转换不涉及书写形式（语法），是编译器完成的自动转换。期间发生的转换大概和下面的代码等价：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> sum1 = (<span class="keyword">double</span>)num + dou;</span><br><span class="line"><span class="keyword">int</span> sum2 = (<span class="keyword">int</span>)((<span class="keyword">double</span>)num + dou);</span><br></pre></td></tr></table></figure>
<p>对于内置的数值类型来说，隐式转换使得大部分数值之间的运算符合日常习惯，但也不全是。比如，<code>doubel</code> 向 <code>int</code> 转型时发生的截断，比如除法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> dou = num / num1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, dou);</span><br></pre></td></tr></table></figure>
<p>输出 2.00000，此时隐式转换不能满足我们的需求。</p>
<p>ps：后文中会提到对于涉及类类型的隐式转换只能够进行一步。我想对于内置类型同样适用，不过话说回来，内置类型之间的转换往往都是一步到位，似乎不存在 A 转 B 再转 C 的情况。</p>
<p>关于隐式转换，更多请参考 <a href="http://www.cnblogs.com/solidblog/p/3381628.html">C++ 隐式类型转换</a>，其中提到隐式转换的必要性和隐式转换发生的条件，也讲到了其中的风险。<code>static_cast</code> 的存在就是为了把隐式转换显现出来。 </p>
<h1 id="显式转型"><a href="#显式转型" class="headerlink" title="显式转型"></a>显式转型</h1><h2 id="old-style-casts"><a href="#old-style-casts" class="headerlink" title="old-style casts"></a>old-style casts</h2><p>C 风格的转型动作看起来像这样：<code>TYPE b = (TYPE)ａ;</code>。</p>
<p>在《EC++》中还提到了函数风格的转型动作 <code>Type(a);</code>，但这限于 C++ 的语法（g++ 可以正常编译），此种形式使用 gcc 编译无法通过。</p>
<h2 id="new-style-casts"><a href="#new-style-casts" class="headerlink" title="new-style casts"></a>new-style casts</h2><p>C++ 提供了四种新式转型：<code>const_cast</code>、<code>reinterpret_cast</code>、<code>dynamic_cast</code> 以及 <code>static_cast</code>。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><code>const_cast&lt;T&gt;(expression)</code> 可去除对象的常量性（const），它还可以去除对象的易变性（volatile）。<code>const_cast</code> 的唯一职责就在于此，若将 <code>const_cast</code> 用于其他转型将会报错。</p>
<p>例子一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * c = <span class="string">&quot; http://www.cppblog.com/kesalin/&quot;</span>;</span><br><span class="line">   print ( <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt; (c) );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子二</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> SA ra;</span><br><span class="line"><span class="comment">//ra.i = 10; //直接修改const类型，编译错误</span></span><br><span class="line">SA &amp;rb = <span class="keyword">const_cast</span>&lt;SA&amp;&gt;(ra);   <span class="comment">// 将 const 转为 non-const</span></span><br><span class="line">rb.i =<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>ps：这篇笔记不再针对 <code>const_cast</code> 做更进一步的讲解，需要认识到：</p>
<blockquote>
<p><code>const_cast</code> 转换符不该用在对象数据上，而应该用在其指针（或引用）上。</p>
<p>修改 <code>const</code> 变量的数据不是 C++ 去 <code>const</code> 的目的！即，使用 <code>const_cast</code> 去 <code>const</code> 属性不是为了修改 const 变量的数据。</p>
</blockquote>
<p>更多内容请移步：<a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part2.html">C++标准转换运算符const_cast</a></p>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p><code>reinterpret_cast&lt;T&gt;(expression)</code> 只用于底层代码，一般我们都用不到它，如果你的代码中使用到这种转型，务必明白自己在干什么。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *pI = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">void</span> *pV = pI;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *pD = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pV);  <span class="comment">// 将 void* 指针转为 typed 指针</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pI is: &quot;</span> &lt;&lt; pI &lt;&lt;</span><br><span class="line">   <span class="string">&quot; And pV is: &quot;</span> &lt;&lt; pV &lt;&lt;</span><br><span class="line">   <span class="string">&quot; And pD is: &quot;</span> &lt;&lt; pD &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; (*pD) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><code>dynamic_cast&lt;T&gt;(expression)</code> 主要用来在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//基类必须有虚函数。保持多态特性才能使用 dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Derived():Base(), m_str(<span class="string">&quot;Derived&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo() &quot;</span> &lt;&lt; m_str &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">// 派生类独有</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_dynamic</span><span class="params">(Base* pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before cast, address is: &quot;</span> &lt;&lt; pb &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  Derived *pd = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(pb);   <span class="comment">// 将 pointer-to-base 转为 pointer-to-derived</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After dynamic_cast, address is: &quot;</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> (pd)</span><br><span class="line">    pd-&gt;foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_static</span><span class="params">(Base* pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before cast, address is: &quot;</span> &lt;&lt; pb &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  Derived *pd = <span class="keyword">static_cast</span>&lt;Derived*&gt;(pb);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After static_cast, address is: &quot;</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(pd)</span><br><span class="line">    pd-&gt;foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *pb1 = <span class="keyword">new</span> Derived();</span><br><span class="line">    Base *pb2 = <span class="keyword">new</span> Base();</span><br><span class="line">    Print_dynamic(pb1);  </span><br><span class="line">    Print_dynamic(pb2);  <span class="comment">// 安全的，转型结果为 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Print_static(pb1);   <span class="comment">// 能够运行下去。只是钻了个空子</span></span><br><span class="line">    Print_static(pb2);   <span class="comment">// 转型结果不为空，但也算不得有效值！访问子类成员崩溃</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>强调几点：</p>
<ul>
<li>基类必须有虚函数。保持多态特性才能使用 <code>dynamic_cast</code></li>
<li>基类指针转子类，使用 <code>dynamic_cast</code> 是正确且安全的，在基类指针指向基类对象（或其它子类对象）时转型失败，结果为空，做出及时终止，未使得程序带错运行下去。</li>
<li>基类指针转子类，使用 <code>static_cast</code> 可能会出现严重问题，尤其是基类指针实际指向基类对象时，<code>static_cast</code> 并不能做出识别，采取有效措施，使程序带错运行。</li>
</ul>
<p>上述代码执行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">vimer@debian8light:~/see-the-world/code/type-conversation$ g++ dynamic.cpp &amp;&amp; ./a.out </span><br><span class="line">Before cast, address is: 0x2439010</span><br><span class="line">After dynamic_cast, address is: 0x2439010</span><br><span class="line">foo() Derived</span><br><span class="line">Before cast, address is: 0x2439060</span><br><span class="line">After dynamic_cast, address is: 0</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">Before cast, address is: 0x2439010</span><br><span class="line">After static_cast, address is: 0x2439010</span><br><span class="line">foo() Derived</span><br><span class="line">Before cast, address is: 0x2439060</span><br><span class="line">After static_cast, address is: 0x2439060</span><br><span class="line">段错误</span><br><span class="line">vimer@debian8light:~/see-the-world/code/type-conversation$ </span><br></pre></td></tr></table></figure>
<p>《EC++》中强调：（详情请翻书）</p>
<blockquote>
<p>它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</p>
</blockquote>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p><code>static_cast&lt;T&gt;(expression)</code> 很像 C 语言中旧式的强制转换。《EC++》中提到：</p>
<blockquote>
<p><code>static_cast</code> 用来强迫<strong>隐式转换</strong>（implicit conversions），例如将 non-cast 对象转为 const 对象，或将 <code>int</code> 转为 <code>double</code> 等等。</p>
</blockquote>
<p>在此特别陈述一下，<code>static_cast</code> 可以用来执行上述多种转换的反向转换。这些反向转换如果不使用 <code>static_cast</code>，都是可以隐式转换的。</p>
<table>
<thead>
<tr>
<th>转型操作符</th>
<th>使用场景</th>
<th>反向转换</th>
<th>隐式转换举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>const_cast</code></td>
<td>可以将 const 转为 non-const</td>
<td>将 non-const 转为 const</td>
<td><code>string str; const string cstr = str;</code></td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>可以将 <code>void*</code> 指针转为 typed 指针</td>
<td>将 typed 指针转为 <code>void*</code> 指针</td>
<td><code>int *pI = new int(5); void *pV = pI;</code></td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>可以将 pointer-to-base 转为 pointer-to-derived</td>
<td>将 pointer-to-derived 转为 pointer-to-base</td>
<td><code>Derived *pD = new Derived(); Base *pB = pD;</code></td>
</tr>
</tbody></table>
<p>注意：<code>static_cast</code> 转换时并不进行运行时安全检查，所以是非安全的，很容易出问题。因此 C++ 引入 <code>dynamic_cast</code> 来处理安全转型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于类型转换，想要在代码中正确地使用还是比较简单的（想要完完全全掌握来龙去脉，掌握原理及所有使用场景还是很难的）。重点理解 <code>static_cast</code> 和 <code>dynamic_cast</code> 的应用场景及两者之间的区别</p>
<ul>
<li><a href="http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html">C++类型转换总结</a>，讲解恰到好处</li>
<li><a href="http://www.cnblogs.com/TenosDoIt/p/3175217.html">下行转换 &amp; 上行转换</a>，区分下行、上行</li>
<li><a href="http://www.cppblog.com/kesalin/archive/2012/10/28/type_cast.html">类型转换（Type Casting）</a>，事儿不大，啰嗦的废话挺多</li>
</ul>
<p><strong>思考一</strong>：<code>reinterpret_cast</code> 和 <code>dynamic_cast</code> 的某些使用场景很相似，可以类比一下。参考前文的代码，前者用于内置类型从 <code>void*</code> 向各种数值类型 <code>int*</code> <code>double*</code> <code>char*</code> 的转换，后者用于自定义类类型从基类类型 <code>Base*</code> 向其子类类型 <code>DerivedA*</code> <code>DerivedB*</code> <code>DerivedC*</code> 的转换。</p>
<p><strong>思考二</strong>：我们在谈及自定义类类型继承体系中的转型时，都是在用指针。但是否可以像 <code>int</code> 转 <code>double</code> 那样，从 <code>Derived</code> 转 <code>Base</code>（不是 <code>Derived*</code> 转 <code>Base*</code>），从 <code>Base</code> 转 <code>Derived</code> ？</p>
<p><strong>总结 &amp;&amp; 推荐</strong>：在整理笔记的时候肯定会从网上查找资料，每个知识点肯定都会碰到一篇帖子让自己感慨“哇，总结得好好，娓娓道来，该讲的都讲到了，却也不多一句废话”，每每到此刻都觉得自己整理的笔记就是一坨垃圾，用词不当，表述不清晰，上下文转接不流畅，有的重点落下没讲，废话说太多……可这就是<strong>成长必经的过程</strong>，如果不是整理这个知识点，就不会一板一眼、较真地去查阅好多资料，线上的博客、线下的书，随手 google 来的终究只是编码过程中的 code demo，而非知识，只有当你读了很多篇笔记，看过了很多风景，才能有足够的理解，才能通过已经掌握的，通过对比，认识到某一篇是够精彩的。 </p>
<blockquote>
<ul>
<li><p><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part6.html">C++类型转换方式总结</a></p>
<ul>
<li><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part1.html">C++用户自定义转换（User-Defined Conversion）</a></li>
<li><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part2.html">C++标准转换运算符const_cast</a></li>
<li><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part3.html">C++标准转换运算符reinterpret_cast</a></li>
<li><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part4.html">C++标准转换运算符static_cast</a></li>
<li><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part5.html">C++标准转换运算符dynamic_cast</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>如果因为总结的笔记太烂而气馁，放弃整理，那么就不会查阅足够的资料，就不会见到那篇“哇，精彩”的帖子！整理出来的笔记是结果，整理过程中见到的风景也是结果！</p>
<h1 id="变量转型的能力怎么来的"><a href="#变量转型的能力怎么来的" class="headerlink" title="变量转型的能力怎么来的"></a>变量转型的能力怎么来的</h1><p>上文提到的都是转型的语法，即如果从 A 类型到 B 类型可以转型，那么针对不同的转型情形应该怎么书写以达到转型的目的。但如果两者根本不存在任何的转型可能，比如，无关类型之间的转换（从 <code>ClassA</code> 到 <code>ClassB</code>），无关类型指针之间的转换（从 <code>int*</code> 到 <code>double*</code>，从 <code>ClassA*</code> 到 <code>ClassB*</code>），那么……</p>
<p>“两者根本不存在任何的转型可能”分为两种：转型是无任何意义、无价值的；有转型的意义，但未实现转型的定义。如果坚持使用转型操作（无论是隐式的还是显式），后者肯定会报错；显式转型之 new-style casts 的意义就体现在意义界定上，通过对转型分门别类，对转型的意义做了进一步的限定，相比 old-style casts 可以发现更多的错误情况。</p>
<p>无意义主要针对内置类型、指针；无定义主要针对自定义类型。</p>
<p>如果某种转型是无意义的，比如 <code>int*</code> 到 <code>double*</code>，旧式强制转型是可以编译通过的？新式转型编译无法通过？</p>
<p><strong>思考</strong>：新式转型为什么比旧式强制转型好？通过明确的声明“我要进行 XX 转型”，让编译器帮我做进一步检查，防止出现实际代码和编码意图相悖的情况，类似 override 关键词的作用？</p>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>这个就是“天生授予”的，随着编程语言标准（standard）的更迭换代，哪些类型能够转换是有调整的。</p>
<ul>
<li>数值类型之间的转型（！数值类型指针之间不存在转型）</li>
<li>内置类型的指针与空指针之间的转型</li>
</ul>
<h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p>了解多态，我们都知道从基类指针可以指向派生类对象，即可以将派生类指针赋值给基类指针。可以隐式转型，也可以使用 static_cast。</p>
<p>反向的，如果要将基类指针赋给派生类指针，需要判断 pB 指向的对象到底是 D1、D2、D3 哪种类型，这种时候需要使用 dynamic_cast。</p>
<p>如果不是指针（或引用）呢？</p>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>《C++ Primer》P263 提到</p>
<blockquote>
<p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。</p>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<p>需要强调的是，这种隐式转换只允许一步类类型转换。我们知晓 <code>string (const char* s);</code> 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">  MyString(<span class="built_in">string</span> str, <span class="keyword">int</span> num = <span class="number">23</span>) &#123;&#125;;</span><br><span class="line">  <span class="comment">//...other mems</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(MyString ms)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整的</span></span><br><span class="line">func(MyString(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="comment">// 省略一步</span></span><br><span class="line">func(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));    <span class="comment">// 显式转换成（构造） string，隐式转换成 MyString</span></span><br><span class="line">func(MyString(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 隐式转换成 string，显式转换成（构造） MyString</span></span><br><span class="line"><span class="comment">// 省略两步——这是错误的</span></span><br><span class="line">func(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">MyString ms(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 直接初始化</span></span><br><span class="line">MyString ms = MyString(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 与上述等价</span></span><br><span class="line">MyString ms = <span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// it&#x27;s ok  隐式转换，然后执行拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">MyString ms(<span class="string">&quot;abc&quot;</span>);          <span class="comment">// 隐式转换成 string，然后直接初始化</span></span><br><span class="line">MyString ms = MyString(<span class="string">&quot;abc&quot;</span>);   <span class="comment">// 与上述等价</span></span><br><span class="line">MyString ms = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// sorry, it&#x27;s wrong ???????????  无法进行两步隐式转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>我们可以通过将构造函数声明为 <code>explicit</code> 以阻止这种隐式转换。（这种隐式转换存在什么风险呢？ 参考 <a href="http://www.cnblogs.com/bastard/archive/2012/02/09/2344425.html">Explicit——谨慎定义隐式类型转换函数</a>，感觉有些乱）</p>
<p>显式转型中旧式转型形式 <code>MyString(str);</code> 直接理解为构造更直观、合适；<code>(MyString)str;</code> 形式更容易理解为转型。显式转型中新式转型不存在异议 <code>static_cast&lt;MyString&gt;(str);</code>。</p>
<blockquote>
<p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用 =）。进行拷贝形式的初始化时（使用 =）我们不能使用 explicit 构造函数。</p>
<p>当我们使用 explicit 关键字声明构造函数时，它将只能以直接初始化的形式使用。编译器将不会在自动转换过程中使用该构造函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> num = <span class="number">23</span>)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">//...other mems</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(MyString ms)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整的 </span></span><br><span class="line">func(MyString(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="comment">// 省略构造 MyString 的一步——这是错误的</span></span><br><span class="line">func(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));    <span class="comment">// 显式转换成（构造） string，无法隐式转换成 MyString</span></span><br><span class="line"><span class="comment">// 省略构造string 的一步—— it&#x27;s ok</span></span><br><span class="line">func(MyString(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 隐式转换成 string，显式转换成（构造） MyString</span></span><br><span class="line">func(<span class="keyword">static_cast</span>&lt;MyString&gt;(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 隐式转换成 string，显式转换成 MyString</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">MyString ms(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 直接初始化</span></span><br><span class="line">MyString ms = MyString(<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// 与上述等价</span></span><br><span class="line">MyString ms = <span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// it&#x27;s wrong!!!!!!  无法进行隐式转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此种情形下的转型（包括隐式转型、显式之旧式转型、显式之新式转型）都是调用的转换构造函数。其中显式之旧式转型，直接理解为构造更自然、直观。</p>
<h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><p>《C++ Primer》P514</p>
<p>类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换为其他类型。类型转换函数的一般形式如下所示：<code>operator type() const;</code></p>
<p>类型转换运算符既没有显式的返回类型，而没有形参，而且必须定义成类的成员函数。通常不应该改变待转换对象的内容，因此，一般被定义成 const 成员。</p>
<p>避免过度使用类型转换函数！如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。此时不定义该类型转换运算符也许会更好。作为替代的手段，类可以定义一个或多个普通的成员函数以从各种不同形式中提取所需的信息。</p>
<h3 id="explicit-1"><a href="#explicit-1" class="headerlink" title="explicit"></a>explicit</h3><p>《C++ Primer》P516</p>
<p>C++11 新标准引入了显式的类型转换运算符（explicit conversion operator）。和显式的构造函数一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换。</p>
<p>该规定各有一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp-code</category>
      </categories>
  </entry>
  <entry>
    <title>Git Submoudle使用完整教程</title>
    <url>/2018/04/02/git_submodule/</url>
    <content><![CDATA[<p>自从看了蒋鑫的《Git权威指南》之后就开始使用Git Submodule功能，团队也都熟悉了怎么使用，多个子系统（模块）都能及时更新到最新的公共资源，把使用的过程以及经验和容易遇到的问题分享给大家。</p>
<p>Git Submodule功能刚刚开始学习可能觉得有点怪异，所以本教程把每一步的操作的命令和结果都用代码的形式展现给大家，以便更好的理解。</p>
<p><strong>对于公共资源各种程序员的处理方式</strong>：</p>
<p>每个公司的系统都会有一套统一的系统风格，或者针对某一个大客户的多个系统风格保持统一，而且如果风格改动后要同步到多个系统中；这样的需求几乎每个开发人员都遇到，下面看看各个层次的程序员怎么处理：</p>
<p>假如对于系统的风格需要几个目录：css、images、js。</p>
<p>普通程序员，把最新版本的代码逐个复制到每个项目中，如果有N个项目，那就是要复制N x 3次；如果漏掉了某个文件夹没有复制…@（&amp;#@#。</p>
<p>文艺程序员，使用Git Submodule功能，执行：git submodule update，然后冲一杯咖啡悠哉的享受着。</p>
<a id="more"></a>

<p>引用一段《Git权威指南》的话： 项目的版本库在某些情况虾需要引用其他版本库中的文件，例如公司积累了一套常用的函数库，被多个项目调用，显然这个函数库的代码不能直接放到某个项目的代码中，而是要独立为一个代码库，那么其他项目要调用公共函数库该如何处理呢？分别把公共函数库的文件拷贝到各自的项目中会造成冗余，丢弃了公共函数库的维护历史，这显然不是好的方法。</p>
<h1 id="开始学习Git-Submodule"><a href="#开始学习Git-Submodule" class="headerlink" title="开始学习Git Submodule"></a>开始学习Git Submodule</h1><p>“工欲善其事，必先利其器”！</p>
<p>既然文艺程序员那么轻松就搞定了，那我们就把过程一一道来。</p>
<p>说明：本例采用两个项目以及两个公共类库演示对submodule的操作。因为在一写资料或者书上的例子都是一个项目对应1～N个lib，但是实际应用往往并不是这么简单。</p>
<h2 id="创建Git-Submodule测试项目"><a href="#创建Git-Submodule测试项目" class="headerlink" title="创建Git Submodule测试项目"></a>创建Git Submodule测试项目</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~  pwd</span><br><span class="line">/home/henryyan</span><br><span class="line">mkdir -p submd/repos</span><br></pre></td></tr></table></figure>
<p>创建需要的本地仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/submd/repos</span><br><span class="line">git --git-dir=lib1.git init --bare</span><br><span class="line">git --git-dir=lib2.git init --bare</span><br><span class="line">git --git-dir=project1.git init --bare</span><br><span class="line">git --git-dir=project2.git init --bare</span><br></pre></td></tr></table></figure>
<p>初始化工作区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/submd/ws</span><br><span class="line">cd ~/submd/ws</span><br></pre></td></tr></table></figure>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>初始化project1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone ../repos/project1.git </span><br><span class="line">Cloning into project1...</span><br><span class="line">done.</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd project1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) echo &quot;project1&quot; &gt; project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ ls</span><br><span class="line">project-infos.txt</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git add project-infos.txt </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Initial commit</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   new file:   project-infos.txt</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git commit -m <span class="string">&quot;init project1&quot;</span></span></span><br><span class="line">[master (root-commit) 473a2e2] init project1</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 232 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>

<p>初始化project2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 cd ..</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone ../repos/project2.git </span><br><span class="line">Cloning into project2...</span><br><span class="line">done.</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd project2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) echo &quot;project2&quot; &gt; project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ ls</span><br><span class="line">project-infos.txt</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git add project-infos.txt </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Initial commit</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   new file:   project-infos.txt</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git commit -m <span class="string">&quot;init project2&quot;</span></span></span><br><span class="line">[master (root-commit) 473a2e2] init project2</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 232 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project2.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>

<h3 id="初始化公共类库"><a href="#初始化公共类库" class="headerlink" title="初始化公共类库"></a>初始化公共类库</h3><p>初始化公共类库lib1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone ../repos/lib1.git </span><br><span class="line">Cloning into lib1...</span><br><span class="line">done.</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd lib1 </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib1 git:(master) echo &quot;I&#x27;m lib1.&quot; &gt; lib1-features</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib1 git:(master) ✗ git add lib1-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib1 git:(master) ✗ git commit -m &quot;init lib1&quot;</span><br><span class="line">[master (root-commit) c22aff8] init lib1</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 lib1-features</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib1 git:(master) git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 227 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/lib1.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>

<p>初始化公共类库lib2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib1 git:(master) cd ..</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone ../repos/lib2.git </span><br><span class="line">Cloning into lib2...</span><br><span class="line">done.</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd lib2 </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib2 git:(master) echo &quot;I&#x27;m lib2.&quot; &gt; lib2-features</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib2 git:(master) ✗ git add lib2-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib2 git:(master) ✗ git commit -m &quot;init lib2&quot;</span><br><span class="line">[master (root-commit) c22aff8] init lib2</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 lib2-features</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib2 git:(master) git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 227 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/lib2.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="为主项目添加Submodules"><a href="#为主项目添加Submodules" class="headerlink" title="为主项目添加Submodules"></a>为主项目添加Submodules</h2><h3 id="为project1添加lib1和lib2"><a href="#为project1添加lib1和lib2" class="headerlink" title="为project1添加lib1和lib2"></a>为project1添加lib1和lib2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/lib2 git:(master) cd ../project1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ls</span><br><span class="line">project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git submodule add ~/submd/repos/lib1.git libs/lib1</span><br><span class="line">Cloning into libs/lib1...</span><br><span class="line">done.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git submodule add ~/submd/repos/lib2.git libs/lib2</span><br><span class="line">Cloning into libs/lib2...</span><br><span class="line">done.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ ls</span><br><span class="line">libs  project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ ls libs </span><br><span class="line">lib1  lib2</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   new file:   .gitmodules</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   new file:   libs/lib1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   new file:   libs/lib2</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下公共类库的内容</span></span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cat libs/lib1/lib1-features</span><br><span class="line">I&#x27;m lib1.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cat libs/lib2/lib2-features</span><br><span class="line">I&#x27;m lib2.</span><br></pre></td></tr></table></figure>
<p>好了，到目前为止我们已经使用<strong>git submodule add</strong>命令为<strong>project1</strong>成功添加了两个公共类库（lib1、lib2），查看了当前的状态发现添加了一个新文件(<strong>.gitmodules</strong>)和两个文件夹(libs/lib1、libs/lib2)；那么新增的**.gitmodules**文件是做什么用的呢？我们查看一下文件内容便知晓了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n@hy-hp  ~/submd/ws/project1 git:(master) ✗ cat .gitmodules </span><br><span class="line">[submodule &quot;libs/lib1&quot;]</span><br><span class="line">    path = libs/lib1</span><br><span class="line">    url = /home/henryyan/submd/repos/lib1.git</span><br><span class="line">[submodule &quot;libs/lib2&quot;]</span><br><span class="line">    path = libs/lib2</span><br><span class="line">    url = /home/henryyan/submd/repos/lib2.git</span><br></pre></td></tr></table></figure>
<p>原来如此，**.gitmodules**记录了每个submodule的引用信息，知道在当前项目的位置以及仓库的所在。</p>
<p>好的，我们现在把更改提交到仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git commit -a -m &quot;add submodules[lib1,lib2] to project1&quot;</span><br><span class="line">[master 7157977] add submodules[lib1,lib2] to project1</span><br><span class="line"> 3 files changed, 8 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 libs/lib1</span><br><span class="line"> create mode 160000 libs/lib2</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (4/4), 491 bytes, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">   45cbbcb..7157977  master -&gt; master</span><br></pre></td></tr></table></figure>

<pre><code>假如你是第一次引入公共类库的开发人员，那么项目组的其他成员怎么Clone带有Submodule的项目呢，下面我们再clone一个项目讲解如何操作。</code></pre>
<h2 id="Clone带有Submodule的仓库"><a href="#Clone带有Submodule的仓库" class="headerlink" title="Clone带有Submodule的仓库"></a>Clone带有Submodule的仓库</h2><p>模拟开发人员B……</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cd ~/submd/ws</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone ../repos/project1.git project1-b</span><br><span class="line">Cloning into project1-b...</span><br><span class="line">done.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd project1-b </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git submodule </span><br><span class="line">-c22aff85be91eca442734dcb07115ffe526b13a1 libs/lib1</span><br><span class="line">-7290dce0062bd77df1d83b27dd3fa3f25a836b54 libs/lib2</span><br></pre></td></tr></table></figure>
<p>看到submodules的状态是hash码和文件目录，但是注意前面有一个减号：**-**，含义是该子模块还没有检出。</p>
<p>OK，检出project1-b的submodules……</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git submodule init</span><br><span class="line">Submodule &#x27;libs/lib1&#x27; (/home/henryyan/submd/repos/lib1.git) registered for path &#x27;libs/lib1&#x27;</span><br><span class="line">Submodule &#x27;libs/lib2&#x27; (/home/henryyan/submd/repos/lib2.git) registered for path &#x27;libs/lib2&#x27;</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git submodule update</span><br><span class="line">Cloning into libs/lib1...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib1&#x27;: checked out &#x27;c22aff85be91eca442734dcb07115ffe526b13a1&#x27;</span><br><span class="line">Cloning into libs/lib2...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib2&#x27;: checked out &#x27;7290dce0062bd77df1d83b27dd3fa3f25a836b54&#x27;</span><br></pre></td></tr></table></figure>

<pre><code>读者可以查看：.git/config文件的内容，最下面有submodule的注册信息！</code></pre>
<p>验证一下类库的文件是否存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) cat libs/lib1/lib1-features libs/lib2/lib2-features</span><br><span class="line">I&#x27;m lib1.</span><br><span class="line">I&#x27;m lib2.</span><br></pre></td></tr></table></figure>

<pre><code>上面的两个命令(git submodule init &amp; update)其实可以简化，后面会讲到！</code></pre>
<h2 id="修改Submodule"><a href="#修改Submodule" class="headerlink" title="修改Submodule"></a>修改Submodule</h2><p>我们在开发人员B的项目上修改Submodule的内容。</p>
<p>先看一下当前Submodule的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) cd libs/lib1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1  git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> Not currently on any branch.</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>为什么是<strong>Not currently on any branch</strong>呢？不是应该默认在<strong>master</strong>分支吗？别急，一一解答！</p>
<p>Git对于Submodule有特殊的处理方式，在一个主项目中引入了Submodule其实Git做了3件事情：</p>
<ul>
<li><p>记录引用的仓库</p>
</li>
<li><p>记录主项目中Submodules的目录位置</p>
</li>
<li><p>记录引用Submodule的<strong>commit id</strong></p>
</li>
</ul>
<p>在<strong>project1</strong>中push之后其实就是更新了引用的commit id，然后project1-b在clone的时候获取到了submodule的commit id，然后当执行<strong>git submodule update</strong>的时候git就根据<strong>gitlink</strong>获取submodule的commit id，最后获取submodule的文件，所以clone之后不在任何分支上；但是master分支的commit id和HEAD保持一致（why?）。</p>
<p>查看~/submd/ws/project1-b/libs/lib1的引用信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1  cat .git/HEAD</span><br><span class="line">c22aff85be91eca442734dcb07115ffe526b13a1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1  cat .git/refs/heads/master              </span><br><span class="line">c22aff85be91eca442734dcb07115ffe526b13a1</span><br></pre></td></tr></table></figure>

<p>现在我们要修改lib1的文件需要先切换到<strong>master</strong>分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1  git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1 git:(master) echo &quot;add by developer B&quot; &gt;&gt; lib1-features</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1 git:(master) ✗ git commit -a -m &quot;update lib1-features by developer B&quot;</span><br><span class="line">[master 36ad12d] update lib1-features by developer B</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>在主项目中修改Submodule提交到仓库稍微繁琐一点，在<strong>git push</strong>之前我们先看看<strong>project1-b</strong>状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>libs/lib1 (new commits)**状态表示</strong>libs/lib1<strong>有新的提交，这个比较特殊，看看</strong>project1-b**的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git diff</span><br><span class="line">diff --git a/libs/lib1 b/libs/lib1</span><br><span class="line">index c22aff8..36ad12d 160000</span><br><span class="line">--- a/libs/lib1</span><br><span class="line">+++ b/libs/lib1</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit c22aff85be91eca442734dcb07115ffe526b13a1</span><br><span class="line">+Subproject commit 36ad12d40d8a41a4a88a64add27bd57cf56c9de2</span><br></pre></td></tr></table></figure>

<p>从状态中可以看出<strong>libs/lib1</strong>的commit id由原来的<strong>c22aff85be91eca442734dcb07115ffe526b13a1</strong>更改为<strong>36ad12d40d8a41a4a88a64add27bd57cf56c9de2</strong></p>
<p>注意：如果现在执行了git submodule update操作那么libs/lib1的commit id又会还原到c22aff85be91eca442734dcb07115ffe526b13a1，</p>
<p>这样的话刚刚的修改是不是就丢死了呢？不会，因为修改已经提交到了master分支，只要再git checkout master就可以了。</p>
<p>现在可以把<strong>libs/lib1</strong>的修改提交到仓库了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ cd libs/lib1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Writing objects: 100% (3/3), 300 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/repos/lib1.git</span><br><span class="line">   c22aff8..36ad12d  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>现在仅仅只完成了一步，下一步要提交<strong>project1-b</strong>引用submodule的commit id：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b/libs/lib1 git:(master) cd ~/submd/ws/project1-b</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git add -u</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git commit -m &quot;update libs/lib1 to lastest commit id&quot;</span><br><span class="line">[master c96838a] update libs/lib1 to lastest commit id</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 395 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">   7157977..c96838a  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>OK，大功高成，我们完成了Submodule的修改并把<strong>libs/lib1</strong>的最新commit id提交到了仓库。</p>
<p>接下来要看看<strong>project1</strong>怎么获取submodule了。</p>
<h2 id="更新主项目的Submodules"><a href="#更新主项目的Submodules" class="headerlink" title="更新主项目的Submodules"></a>更新主项目的Submodules</h2><p>好的，让我们先进入<strong>project1</strong>目录同步仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) cd ../project1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/ws/../repos/project1</span><br><span class="line">   7157977..c96838a  master     -&gt; origin/master</span><br><span class="line">Updating 7157977..c96838a</span><br><span class="line">Fast-forward</span><br><span class="line"> libs/lib1 |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>我们运行了<strong>git pull</strong>命令和<strong>git status</strong>获取了最新的仓库源码，然后看到了状态时<strong>modified</strong>，这是为什么呢？</p>
<p>我们用<strong>git diff</strong>比较一下不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git diff</span><br><span class="line">diff --git a/libs/lib1 b/libs/lib1</span><br><span class="line">index 36ad12d..c22aff8 160000</span><br><span class="line">--- a/libs/lib1</span><br><span class="line">+++ b/libs/lib1</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 36ad12d40d8a41a4a88a64add27bd57cf56c9de2</span><br><span class="line">+Subproject commit c22aff85be91eca442734dcb07115ffe526b13a1</span><br></pre></td></tr></table></figure>

<p>从diff的结果分析出来时因为submodule的commit id更改了，我们前面刚刚讲了要在主项目更新submodule的内容首先要提交submdoule的内容，然后再更新主项目中引用的submodulecommit id；现在我们看到的不同就是因为刚刚更改了project1-b的submodule commit id；好的，我来学习一下怎么更新<strong>project1</strong>的公共类库。</p>
<p>follow me……</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git submodule update</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>泥马，为什么没有更新？<strong>git submodule update</strong>命令不是更新子模块仓库的吗？</p>
<p>别急，先听我解释；因为子模块是在<strong>project1</strong>中引入的，<strong>git submodule add ~/submd/repos/lib1.git libs/lib1</strong>命令的结果，操作之后git只是把lib1的内容clone到了<strong>project1</strong>中，但是没有在仓库注册，证据如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd2/ws/project1 git:(master) ✗ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">    url = /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br></pre></td></tr></table></figure>

<p>我们说过<strong>git submodule init</strong>就是在**.git/config**中注册子模块的信息，下面我们试试注册之后再更新子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git submodule init</span><br><span class="line">Submodule &#x27;libs/lib1&#x27; (/home/henryyan/submd/repos/lib1.git) registered for path &#x27;libs/lib1&#x27;</span><br><span class="line">Submodule &#x27;libs/lib2&#x27; (/home/henryyan/submd/repos/lib2.git) registered for path &#x27;libs/lib2&#x27;</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git submodule update</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/repos/lib1</span><br><span class="line">   c22aff8..36ad12d  master     -&gt; origin/master</span><br><span class="line">Submodule path &#x27;libs/lib1&#x27;: checked out &#x27;36ad12d40d8a41a4a88a64add27bd57cf56c9de2&#x27;</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cat .git/config</span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">    url = /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[submodule &quot;libs/lib1&quot;]</span><br><span class="line">    url = /home/henryyan/submd/repos/lib1.git</span><br><span class="line">[submodule &quot;libs/lib2&quot;]</span><br><span class="line">    url = /home/henryyan/submd/repos/lib2.git</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cat libs/lib1/lib1-features</span><br><span class="line">I&#x27;m lib1.</span><br><span class="line">add by developer B</span><br></pre></td></tr></table></figure>

<p>上面的结果足以证明刚刚的推断，所以记得当需要更新子模块的内容时请先确保已经运行过<strong>git submodule init</strong>。</p>
<h2 id="为project2添加lib1和lib2"><a href="#为project2添加lib1和lib2" class="headerlink" title="为project2添加lib1和lib2"></a>为project2添加lib1和lib2</h2><p>这个操作对于读到这里的你来说应该是<strong>轻车熟路</strong>了，action：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cd ~/submd/ws/project2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git submodule add ~/submd/repos/lib1.git libs/lib1</span><br><span class="line">Cloning into libs/lib1...</span><br><span class="line">done.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git submodule add ~/submd/repos/lib2.git libs/lib2</span><br><span class="line">zsh: correct &#x27;libs/lib2&#x27; to &#x27;libs/lib1&#x27; [nyae]? n</span><br><span class="line">Cloning into libs/lib2...</span><br><span class="line">done.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ ls</span><br><span class="line">libs  project-infos.txt</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git submodule init</span><br><span class="line">Submodule &#x27;libs/lib1&#x27; (/home/henryyan/submd/repos/lib1.git) registered for path &#x27;libs/lib1&#x27;</span><br><span class="line">Submodule &#x27;libs/lib2&#x27; (/home/henryyan/submd/repos/lib2.git) registered for path &#x27;libs/lib2&#x27;</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   new file:   .gitmodules</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   new file:   libs/lib1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   new file:   libs/lib2</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git commit -a -m <span class="string">&quot;add lib1 and lib2&quot;</span></span></span><br><span class="line">[master 8dc697f] add lib1 and lib2</span><br><span class="line"> 3 files changed, 8 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 libs/lib1</span><br><span class="line"> create mode 160000 libs/lib2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (4/4), 471 bytes, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project2.git</span><br><span class="line">   6e15c68..8dc697f  master -&gt; master</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>我们依次执行了添加submodule并commit和push到仓库，此阶段任务完成。</p>
<h2 id="修改lib1和lib2并同步到project1和project2"><a href="#修改lib1和lib2并同步到project1和project2" class="headerlink" title="修改lib1和lib2并同步到project1和project2"></a>修改lib1和lib2并同步到project1和project2</h2><p>假如开发人员C同时负责<strong>project1</strong>和<strong>project2</strong>，有可能在修改<strong>project1</strong>的某个功能的时候发现lib1或者lib2的某个组件有bug需要修复，这个需求多模块和大型系统中经常遇到，我们应该怎么解决呢？</p>
<p>假如我的需求如下：</p>
<ul>
<li><p>在lib1中添加一个文件：README，用来描述lib1的功能</p>
</li>
<li><p>在lib2中的lib2-features文件中添加一写文字：学习Git submodule的修改并同步功能</p>
</li>
</ul>
<h3 id="在lib1中添加一个文件：README"><a href="#在lib1中添加一个文件：README" class="headerlink" title="在lib1中添加一个文件：README"></a>在lib1中添加一个文件：README</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) cd libs/lib1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib1 git:(master) echo &quot;lib1 readme contents&quot; &gt; README</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib1 git:(master) ✗ git add README </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib1 git:(master) ✗ git commit -m &quot;add file README&quot;</span><br><span class="line">[master 8c666d8] add file README</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib1 git:(master) git push</span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 310 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/repos/lib1.git</span><br><span class="line">   36ad12d..8c666d8  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>前面提到过现在仅仅只完成了一部分，我们需要在<strong>project2</strong>中再更新lib1的commit id：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git add libs/lib1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git commit -m &quot;update lib1 to lastest commit id&quot;</span><br><span class="line">[master ce1f3ba] update lib1 to lastest commit id</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<pre><code>我们暂时不push到仓库，等待和lib2的修改一起push。</code></pre>
<h3 id="在lib2中的lib2-features文件添加文字"><a href="#在lib2中的lib2-features文件添加文字" class="headerlink" title="在lib2中的lib2-features文件添加文字"></a>在lib2中的lib2-features文件添加文字</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) cd libs/lib2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) echo &quot;学习Git submodule的修改并同步功能&quot; &gt;&gt; lib2-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) ✗ git add lib2-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) ✗ git commit -m &quot;添加文字：学习Git submodule的修改并同步功能&quot;</span><br><span class="line">[master e372b21] 添加文字：学习Git submodule的修改并同步功能</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 376 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/repos/lib2.git</span><br><span class="line">   7290dce..e372b21  master -&gt; master</span><br><span class="line"> </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) echo &quot;学习Git submodule的修改并同步功能&quot; &gt;&gt; lib2-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) ✗ git add lib2-features </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) ✗ git commit -m &quot;添加文字：学习Git submodule的修改并同步功能&quot;</span><br><span class="line">[master e372b21] 添加文字：学习Git submodule的修改并同步功能</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 376 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/repos/lib2.git</span><br><span class="line">   7290dce..e372b21  master -&gt; master</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2/libs/lib2 git:(master) cd -</span><br><span class="line">~/submd/ws/project2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Changes not staged for commit:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib2 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git add libs/lib2 </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) ✗ git commit -m &quot;update lib2 to lastest commit id&quot;</span><br><span class="line">[master df344c5] update lib2 to lastest commit id</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">nothing to commit (working directory clean)</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git push</span><br><span class="line">Counting objects: 8, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (6/6), 776 bytes, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (6/6), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project2.git</span><br><span class="line">   8dc697f..df344c5  master -&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="同步project2的lib1和lib2的修改到project1"><a href="#同步project2的lib1和lib2的修改到project1" class="headerlink" title="同步project2的lib1和lib2的修改到project1"></a>同步project2的lib1和lib2的修改到project1</h2><p>现在project2已经享受到了最新的代码带来的<strong>快乐</strong>，那么既然project1和project2属于同一个风格，或者调用同一个功能，要让这两个(可能几十个)项目保持一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) cd ../project1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git pull</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>

<p>看看上面的结果对吗？为什么lib1和lib2更新了但是没有显示<strong>new commits</strong>呢？说到这里我记得刚刚开始学习的时候真得要晕死了，Git跟我玩捉迷藏游戏，为什么我明明提交了但是从<strong>project1</strong>更新不到任何改动呢？</p>
<p>帮大家分析一下问题，不过在分析之前先看看当前(project1和project2)的submodule状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> project2 的状态，也就是我们刚刚修改后的状态</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project2 git:(master) git submodule </span><br><span class="line"> 8c666d86531513dd1aebdf235f142adbac72c035 libs/lib1 (heads/master)</span><br><span class="line"> e372b21dffa611802c282278ec916b5418acebc2 libs/lib2 (heads/master)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> project1 的状态，等待更新submodules</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git submodule </span><br><span class="line"> 36ad12d40d8a41a4a88a64add27bd57cf56c9de2 libs/lib1 (remotes/origin/HEAD)</span><br><span class="line"> 7290dce0062bd77df1d83b27dd3fa3f25a836b54 libs/lib2 (heads/master)</span><br></pre></td></tr></table></figure>

<p>两个项目有两个区别：</p>
<ul>
<li><p>commit id各不相同</p>
</li>
<li><p><strong>libs/lib1</strong>所处的分支不同</p>
</li>
</ul>
<h3 id="更新project1的lib1和lib2改动"><a href="#更新project1的lib1和lib2改动" class="headerlink" title="更新project1的lib1和lib2改动"></a>更新project1的lib1和lib2改动</h3><p>我们还记得刚刚在<strong>project2</strong>中修改的时候把lib1和lib2都切换到了master分支，目前project1中的lib1不在任何分支，我们先切换到master分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) cd libs/lib1</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1/libs/lib1  git checkout master</span><br><span class="line">Previous HEAD position was 36ad12d... update lib1-features by developer B</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is behind &#x27;origin/master&#x27; by 1 commit, and can be fast-forwarded.</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1/libs/lib1 git:(master) git pull</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/repos/lib1</span><br><span class="line">   36ad12d..8c666d8  master     -&gt; origin/master</span><br><span class="line">Updating c22aff8..8c666d8</span><br><span class="line">Fast-forward</span><br><span class="line"> README        |    1 +</span><br><span class="line"> lib1-features |    1 +</span><br><span class="line"> 2 files changed, 2 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1/libs/lib1 git:(master) </span><br></pre></td></tr></table></figure>

<p>果不其然，我们看到了刚刚在project2中修改的内容，同步到了project1中，当然现在更新了<strong>project1</strong>的<strong>lib1</strong>，commit id也会随之变动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1/libs/lib1 git:(master) cd ../../</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git diff</span><br><span class="line">diff --git a/libs/lib1 b/libs/lib1</span><br><span class="line">index 36ad12d..8c666d8 160000</span><br><span class="line">--- a/libs/lib1</span><br><span class="line">+++ b/libs/lib1</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 36ad12d40d8a41a4a88a64add27bd57cf56c9de2</span><br><span class="line">+Subproject commit 8c666d86531513dd1aebdf235f142adbac72c035</span><br></pre></td></tr></table></figure>

<p>现在最新的commit id和project2目前的状态一致，说明真的同步了；好的，现在可以使用相同的办法更新<strong>lib2</strong>了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ cd libs/lib2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1/libs/lib2 git:(master) git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/repos/lib2</span><br><span class="line">   7290dce..e372b21  master     -&gt; origin/master</span><br><span class="line">Updating 7290dce..e372b21</span><br><span class="line">Fast-forward</span><br><span class="line"> lib2-features |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<h3 id="更新project1的submodule引用"><a href="#更新project1的submodule引用" class="headerlink" title="更新project1的submodule引用"></a>更新project1的submodule引用</h3><p>在<strong>2.7.1</strong>中我们更新了<strong>project1</strong>的<strong>lib1</strong>和<strong>lib2</strong>的最新版本，现在要把最新的commit id保存到<strong>project1</strong>中以保持最新的引用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   modified:   libs/lib2 (new commits)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) ✗ git commit -a -m &quot;update lib1 and lib2 commit id to new version&quot;</span><br><span class="line">[master 8fcca50] update lib1 and lib2 commit id to new version</span><br><span class="line"> 2 files changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1 git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 397 bytes, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">   c96838a..8fcca50  master -&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="更新project1-b项目的子模块-使用脚本"><a href="#更新project1-b项目的子模块-使用脚本" class="headerlink" title="更新project1-b项目的子模块(使用脚本)"></a>更新project1-b项目的子模块(使用脚本)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/ws/../repos/project1</span><br><span class="line">   c96838a..8fcca50  master     -&gt; origin/master</span><br><span class="line">Updating c96838a..8fcca50</span><br><span class="line">Fast-forward</span><br><span class="line"> libs/lib1 |    2 +-</span><br><span class="line"> libs/lib2 |    2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   modified:   libs/lib1 (new commits)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   modified:   libs/lib2 (new commits)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>Git提示lib1和lib2有更新内容，这个判断的依据来源于submodule commit id的引用。</p>
<p>现在怎么更新呢？难道还是像project1中那样进入子模块的目录然后<strong>git checkout master</strong>，接着<strong>git pull</strong>？</p>
<p>而且现在仅仅才两个子模块、两个项目，如果在真实的项目中使用的话可能几个到几十个不等，再加上N个submodule，自己算一下要怎么更新多少个submodules？</p>
<p>例如笔者现在做的一个项目有<strong>5</strong>个web模块，每个web模块引用公共的css、js、images、jsp资源，这样就有20个submodule需要更新！！！</p>
<p><strong>工欲善其事，必先利其器</strong>，写一个脚本代替手动任务。</p>
<h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ grep path .gitmodules | awk &#x27;&#123; print $3 &#125;&#x27; &gt; /tmp/study-git-submodule-dirs</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ cat /tmp/study-git-submodule-dirs</span><br><span class="line"> libs/lib1</span><br><span class="line"> libs/lib2</span><br></pre></td></tr></table></figure>

<p>我们通过分析**.gitmodules**文件得出子模块的路径，然后就可以根据这些路径进行更新。</p>
<h3 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ mkdir bin</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ vi bin/update-submodules.sh</span><br></pre></td></tr></table></figure>

<p>把下面的脚本复制到<strong>bin/update-submodules.sh</strong>中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">grep path .gitmodules | awk &#x27;&#123; print $3 &#125;&#x27; &gt; /tmp/study-git-submodule-dirs</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span></span></span><br><span class="line">while read LINE</span><br><span class="line">do</span><br><span class="line">    echo $LINE</span><br><span class="line">    (cd ./$LINE &amp;&amp; git checkout master &amp;&amp; git pull)</span><br><span class="line">done &lt; /tmp/study-git-submodule-dirs</span><br></pre></td></tr></table></figure>

<p>稍微解释一下上面的脚本执行过程：</p>
<ul>
<li><p>首先把子模块的路径写入到文件**/tmp/study-git-submodule-dirs**中；</p>
</li>
<li><p>然后读取文件中的子模块路径，依次切换到master分支(修改都是在master分支上进行的)，最后更新最近改动。</p>
</li>
</ul>
<h3 id="2013-01-19更新"><a href="#2013-01-19更新" class="headerlink" title="2013-01-19更新"></a><font color="red">2013-01-19更新</font></h3><p>网友**@紫煌<strong>给出了更好的办法，一个命令就可以代替上面的</strong>bin/update-submodules.sh**的功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>

<p>此命令也脚本一样，循环进入（enter）每个子模块的目录，然后执行<strong>foreach</strong>后面的命令。</p>
<blockquote>
<p>该后面的命令可以任意的，例如 git submodule foreach ls -l 可以列出每个子模块的文件列表</p>
</blockquote>
<h3 id="体验工具带来的便利"><a href="#体验工具带来的便利" class="headerlink" title="体验工具带来的便利"></a>体验工具带来的便利</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git submodule </span><br><span class="line">+36ad12d40d8a41a4a88a64add27bd57cf56c9de2 libs/lib1 (heads/master)</span><br><span class="line">+7290dce0062bd77df1d83b27dd3fa3f25a836b54 libs/lib2 (heads/master)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加执行权限</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ chmod +x ./bin/update-submodules.sh</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ ./bin/update-submodules.sh </span><br><span class="line">libs/lib1</span><br><span class="line">Already on &#x27;master&#x27;</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/repos/lib1</span><br><span class="line">   36ad12d..8c666d8  master     -&gt; origin/master</span><br><span class="line">Updating 36ad12d..8c666d8</span><br><span class="line">Fast-forward</span><br><span class="line"> README |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br><span class="line">libs/lib2</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From /home/henryyan/submd/repos/lib2</span><br><span class="line">   7290dce..e372b21  master     -&gt; origin/master</span><br><span class="line">Updating 7290dce..e372b21</span><br><span class="line">Fast-forward</span><br><span class="line"> lib2-features |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git submodule </span><br><span class="line"> 8c666d86531513dd1aebdf235f142adbac72c035 libs/lib1 (heads/master)</span><br><span class="line"> e372b21dffa611802c282278ec916b5418acebc2 libs/lib2 (heads/master)</span><br><span class="line"> </span><br><span class="line"> ➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   bin/</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>更新之后的两个变化：</p>
<ul>
<li><p>git submodule的结果和project2的submodule commit id保持一致；</p>
</li>
<li><p><strong>project1-b</strong>不再提示<strong>new commits</strong>了。</p>
</li>
</ul>
<p>现在可以把工具添加到仓库了，当然你可以很骄傲的分享给其他项目组的同事。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git add bin/update-submodules.sh </span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) ✗ git commit -m &quot;添加自动更新submodule的快捷脚本^_^&quot;</span><br><span class="line">[master 756e788] 添加自动更新submodule的快捷脚本^_^</span><br><span class="line"> 1 files changed, 9 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100755 bin/update-submodules.sh</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-b git:(master) git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (4/4), 625 bytes, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">   8fcca50..756e788  master -&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="新进员工加入团队，一次性Clone项目和Submodules"><a href="#新进员工加入团队，一次性Clone项目和Submodules" class="headerlink" title="新进员工加入团队，一次性Clone项目和Submodules"></a>新进员工加入团队，一次性Clone项目和Submodules</h2><p>一般人使用的时候都是使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone /path/to/repos/foo.git</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>

<pre><code>新员工不耐烦了，嘴上不说但是心里想：怎么那么麻烦？</code></pre>
<p>上面的命令简直弱暴了，直接一行命令搞定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recursive /path/to/repos/foo.git</span><br></pre></td></tr></table></figure>

<p>–<strong>recursive</strong>参数的含义：可以在clone项目时同时clone关联的submodules。</p>
<p>git help 对其解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--recursive, --recurse-submodules</span><br><span class="line">   After the clone is created, initialize all submodules within, using their default settings. This is equivalent to running git</span><br><span class="line">   submodule update --init --recursive immediately after the clone is finished. This option is ignored if the cloned repository</span><br><span class="line">   does not have a worktree&#x2F;checkout (i.e. if any of --no-checkout&#x2F;-n, --bare, or --mirror is given)</span><br></pre></td></tr></table></figure>

<h3 id="使用一键方式克隆project2"><a href="#使用一键方式克隆project2" class="headerlink" title="使用一键方式克隆project2"></a>使用一键方式克隆project2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone --recursive ../repos/project2.git project2-auto-clone-submodules</span><br><span class="line">Cloning into project2-auto-clone-submodules...</span><br><span class="line">done.</span><br><span class="line">Submodule &#x27;libs/lib1&#x27; (/home/henryyan/submd/repos/lib1.git) registered for path &#x27;libs/lib1&#x27;</span><br><span class="line">Submodule &#x27;libs/lib2&#x27; (/home/henryyan/submd/repos/lib2.git) registered for path &#x27;libs/lib2&#x27;</span><br><span class="line">Cloning into libs/lib1...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib1&#x27;: checked out &#x27;8c666d86531513dd1aebdf235f142adbac72c035&#x27;</span><br><span class="line">Cloning into libs/lib2...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib2&#x27;: checked out &#x27;e372b21dffa611802c282278ec916b5418acebc2&#x27;</span><br></pre></td></tr></table></figure>

<p>舒服……</p>
<h1 id="移除Submodule"><a href="#移除Submodule" class="headerlink" title="移除Submodule"></a>移除Submodule</h1><p><strong>牢骚</strong>：搞不明白为什么git不设计一个类似：git submodule remove的命令呢？</p>
<p>我们从project1.git克隆一个项目用来练习移除submodule：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws  git clone --recursive ../repos/project1.git project1-remove-submodules</span><br><span class="line">Cloning into project1-remove-submodules...</span><br><span class="line">done.</span><br><span class="line">Submodule &#x27;libs/lib1&#x27; (/home/henryyan/submd/repos/lib1.git) registered for path &#x27;libs/lib1&#x27;</span><br><span class="line">Submodule &#x27;libs/lib2&#x27; (/home/henryyan/submd/repos/lib2.git) registered for path &#x27;libs/lib2&#x27;</span><br><span class="line">Cloning into libs/lib1...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib1&#x27;: checked out &#x27;8c666d86531513dd1aebdf235f142adbac72c035&#x27;</span><br><span class="line">Cloning into libs/lib2...</span><br><span class="line">done.</span><br><span class="line">Submodule path &#x27;libs/lib2&#x27;: checked out &#x27;e372b21dffa611802c282278ec916b5418acebc2&#x27;</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd !$</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws  cd project1-remove-submodules</span><br></pre></td></tr></table></figure>

<h2 id="Step-by"><a href="#Step-by" class="headerlink" title="Step by"></a>Step by</h2><p>1、删除git cache和物理文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) git rm -r --cached libs/</span><br><span class="line">rm &#x27;libs/lib1&#x27;</span><br><span class="line">rm &#x27;libs/lib2&#x27;</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) ✗ rm -rf libs</span><br></pre></td></tr></table></figure>

<p>2、删除.gitmodules的内容（或者整个文件）<br>因为本例只有两个子模块，直接删除文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) ✗ rm .gitmodules</span><br></pre></td></tr></table></figure>

<pre><code>如果仅仅删除某一个submodule那么打开.gitmodules文件编辑，删除对应submodule配置即可。</code></pre>
<p>3、删除.git/config的submodule配置<br>源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0 </span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">    url &#x3D; &#x2F;home&#x2F;henryyan&#x2F;submd&#x2F;ws&#x2F;..&#x2F;repos&#x2F;project1.git</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[submodule &quot;libs&#x2F;lib1&quot;]</span><br><span class="line">    url &#x3D; &#x2F;home&#x2F;henryyan&#x2F;submd&#x2F;repos&#x2F;lib1.git</span><br><span class="line">[submodule &quot;libs&#x2F;lib2&quot;]</span><br><span class="line">    url &#x3D; &#x2F;home&#x2F;henryyan&#x2F;submd&#x2F;repos&#x2F;lib2.git</span><br></pre></td></tr></table></figure>

<p>删除后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0 </span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">    url &#x3D; &#x2F;home&#x2F;henryyan&#x2F;submd&#x2F;ws&#x2F;..&#x2F;repos&#x2F;project1.git</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure>

<p>4、提交更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) ✗ git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   deleted:    libs/lib1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   deleted:    libs/lib2</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Changes not staged for commit:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   deleted:    .gitmodules</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) ✗ git add .gitmodules</span></span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) ✗ git commit -m &quot;删除子模块lib1和lib2&quot;</span><br><span class="line">[master 5e2ee71] 删除子模块lib1和lib2</span><br><span class="line"> 3 files changed, 0 insertions(+), 8 deletions(-)</span><br><span class="line"> delete mode 100644 .gitmodules</span><br><span class="line"> delete mode 160000 libs/lib1</span><br><span class="line"> delete mode 160000 libs/lib2</span><br><span class="line">➜ henryyan@hy-hp  ~/submd/ws/project1-remove-submodules git:(master) git push</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (2/2), 302 bytes, done.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (2/2), done.</span><br><span class="line">To /home/henryyan/submd/ws/../repos/project1.git</span><br><span class="line">   756e788..5e2ee71  master -&gt; master</span><br></pre></td></tr></table></figure>

<h1 id="git-分离子目录并清理"><a href="#git-分离子目录并清理" class="headerlink" title="git 分离子目录并清理"></a>git 分离子目录并清理</h1><p>将现有 git 仓库中的子目录分离为独立仓库并保留其提交历史</p>
<p>参照 <a href="https://blessing.studio/splitting-a-subfolder-out-into-a-new-git-repository/">如何将现有 git 仓库中的子目录分离为独立仓库并保留其提交历史</a>，按照 0x01-0x02-0x03-0x05 按部就班操作即可。替代方案 0x04 对于了解 <code>git filter-branch</code> 命令大有帮助。</p>
<p>核心步骤 0x03 中，注意在 <code>git subtree</code> 之后，严格按照作者给出的新建空仓库 <code>git init</code>，然后拉取临时分支操作 <code>git pull</code>。由此得到 <code>.git</code> 是干净的。</p>
<ul>
<li>如果使用原仓库，清理其余分支，再重命名临时分支，<code>.git</code> 存在垃圾内容。</li>
</ul>
<p>如果本地仓库尚未推送由他人使用，我们还可以进一步把这个子目录从原 repo 中不留一丝痕迹地完全移除。此时可以参考 GitHub Help 文章 <a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">Removing sensitive data from a repository</a>。</p>
<p>使用 <a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG</a> 时，可以不带任何参数以查看帮助说明：</p>
<blockquote>
<p>For further command-line options, you can run the BFG without any arguments.</p>
</blockquote>
<p>注意 BFG 作者在说明以及示例中，全部是在 <code>git clone --mirror</code> 的仓库中操作的。</p>
<p>在使用 <code>java -jar ..\bfg-1.13.0.jar  --delete-folders DLModelingProject</code> 命令之后，StockDataLayerX.git 会将所有涉及此目录的 commit 置空，然后需要我们 <a href="https://stackoverflow.com/questions/28313664/remove-empty-commits-in-git">Remove empty commits in git</a> —— 还是需要接触 <a href="https://git-scm.com/docs/git-filter-branch">git-filter-branch</a>。</p>
<pre><code>git filter-branch --prune-empty --tag-name-filter cat -- --all</code></pre>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>对于Git Submodule来说在刚刚接触的时候多少会有点凌乱的赶紧，尤其是没有接触过<strong>svn:externals</strong>。</p>
<p>本文从开始创建项目到使用git submodule的每个步骤以及细节、原理逐一讲解，希望到此读者能驾驭它。</p>
<p>学会了Git submdoule你的项目中再也不会出现大量重复的资源文件、公共类库，更不会出现多个版本，甚至一个客户的多个项目风格存在各种差异。</p>
<p>本文的写作来源于工作中的实践，如果您对于某个做法有更好的办法还请赐教，希望能留下您宝贵的意见。</p>
<h2 id="转载声明"><a href="#转载声明" class="headerlink" title="转载声明"></a>转载声明</h2><p>在转载以下文章的前提下，规范目录分级，并增加“git 分离子目录并清理” 章节。</p>
<p>原创文章，转载请注明出处！<br><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html">Git Submoudle使用完整教程–咖啡兔</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
