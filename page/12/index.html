<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="不积小流，无以成江海" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'AWLTH1YPN5',
      apiKey: 'd9101fc28af07d0ea8ade8654c1dc48b',
      indexName: 'test_niel',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:type" content="website">
<meta property="og:title" content="不积小流，无以成江海">
<meta property="og:url" content="https://tnie.github.io/page/12/index.html">
<meta property="og:site_name" content="不积小流，无以成江海">
<meta property="og:description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tnie &amp; ilyw">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tnie.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>不积小流，无以成江海</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不积小流，无以成江海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">海纳百川，有容乃大</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/10/27/writing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/27/writing/" class="post-title-link" itemprop="url">码字，第一篇博客</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-27 18:10:05" itemprop="dateCreated datePublished" datetime="2016-10-27T18:10:05+08:00">2016-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-28 17:01:33" itemprop="dateModified" datetime="2021-01-28T17:01:33+08:00">2021-01-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>个人学习笔记，学习的总结，肯定是采用文字的形式记录。是以纸笔墨砚的形式，还是以更现代的码字的形式？上学的时候还固执于前者，写写画画了好几个本子，每个上面都有些文字，却也都不成系统，而且基本上全是个人日记，记录心情，发泄情绪。工作后渐渐放弃了纸笔间的习惯，喜欢在键盘上码字，整理的内容也由日记全部过渡成了技术帖。一开始在印象笔记中零零散散保存，后来同时使用为知笔记并逐渐过渡了日记使用前者，技术帖使用后者。因为基本不再写日记，印象笔记也就变成了存储记忆的空间，还是不翻书的那种。</p>
<p>后来迷上 markdown，有半个月打算放弃为知笔记，后来发现 markdown 只能替代为知笔记默认编辑器的位置，而个人知识管理的体系、框架的建立与维护还是得靠为知笔记。但两者的结合并不完美，核心问题在于技术人员（指我自己）使用 GFM，而为知笔记的 markdown 解释器并不能完全支持 GFM，尤其是语法高亮方面（主要使用 shell、vimL、console 的支持），GFM 不支持 <code>[TOC]</code> 标签。</p>
<p>使用 MarkdownPad 2 编辑文字很爽，但保存的 <code>.md</code> 文档在查阅时并不直接。将其拷贝到为知笔记中在首部添加 <code>[TOC]</code> 标签后发布，阅读时直观，查找时无论是根据多层级文件级树形查找还是直接使用内建的搜索框直接搜索都是很方便的，不足之处在于：</p>
<ul>
<li>一方面即便其支持 markdown 编辑，但并不友好，尤其是在使用 MarkdownPad 2 之后；</li>
<li>另一方面，使用 markdown 语法的前提下，无法实现在笔记中插入对另一篇笔记的引用（链接），这在整理系列笔记时尤其不能容忍。</li>
</ul>
<p>想通过搭建个人的博客网站来解决上述矛盾：保留使用 MarkdownPad 2 编辑文字的习惯，放弃为知笔记，将文字直接发布到外网上就可以解决无法链接、笔记之间相互跳转的问题。此种情况下带来一点点不便，如果帖子中涉及个人隐私、公司商业机密（我笑），需要仔细筛选。</p>
<p>在搭建个人博客的摸索阶段，从为知笔记到博客网站的过渡阶段，依然会使用为知笔记，并不在时间轴上一刀切，一下子将为知笔记中的内容全部拷贝到网站中，然后清空、销户。</p>
<p>使用 GitHub Pages 和 Hexo 搭建个人博客，静态网页会在 Github 中保留有版本记录，但源 <code>.md</code> 文件的存储（乃至版本控制）尚需考虑：</p>
<ul>
<li><p><del>对编辑的过程（版本控制）要求高，考虑</del> 在 <code>~\hexo\source</code> 创建版本库；2020/12/25，折腾一遭还是选择此方案</p>
</li>
<li><p><del>只要求结果（对版本控制要求低），有 <code>.md</code> 文件的备份即可，考虑整体迁移到 Dropbox 中；</del> </p>
<p>  <del>因为 <code>hexo\blog\source\_posts</code> 目录（<code>.md</code> 源）只能在 hexo 树形目录的固定节点，所以想将其备份到 dropbox 中，需要 trick / workaround，<a href="09">Windows下硬链接、软链接和快捷方式的区别</a></del></p>
</li>
<li><p>图片库的问题，考虑使用图床；2020/12/25，PicGo+GitHub，谁用谁知道</p>
</li>
<li><p>对目录有需求，使用哪种实现呢？<code>[TOC]</code> 不解析，使用支持目录的主题。</p>
</li>
</ul>
<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><p>阮一峰说喜欢写Blog的人，会经历三个阶段:</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>在网上查找两篇教程，按部就班的操作就能得到结果。目前对于博客没有任何复杂的要求，对评论、对布局、主题都没有挑选的欲望。博客只是用来将自己的整理的笔记、学习总结放到互联网上存储，查阅时不用再打开为知笔记，不用打开 MarkdownPad2 实时生成，带来查阅时的便利即可。</p>
<p>对于评论，教程中多提及中文用户推荐“多说”，起步阶段没有需求，加上暂时不想再多花时间在这些“边缘”上，所以未开启评论功能。总的来说，博客还是处于自我查阅阶段。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">hexo 官方站点</a> 的介绍，在 <a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">下载安装 Node.js</a> 之后，执行以下命令即可完成搭建。 </p>
<ul>
<li>下载 Node.js 时，不使用代理时下载飞快；</li>
<li>安装 Node.js 的过程会自动配置 Path，安装完毕使用 powershell 输入 <code>node</code> 验证</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog <span class="comment">#解释：初始化了一个文件夹叫做blog，如果不想叫blog可以改为别的名字</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 github 发布需要</span></span><br><span class="line">npm install hexo-deployer-git -S</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用本地搜索需要</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>拉取笔记仓库，并替换 source 目录：进入 <code>blog\</code> 目录，执行 <code>git clone git@github.com:tnie/notes.git</code>，然后 <code>rm source -rf &amp;&amp; move notes source</code></p>
<p>使用仓库中的配置文件，更新 blog 的配置项目。</p>
<p><strong>注意</strong>：绑定本地 hexo 和个人的 Github Pages 后（修改全局配置文件），执行 <code>hexo deploy</code> 命令部署时需要先安装  hexo-deployer-git. <code>npm install hexo-deployer-git -S</code></p>
<h1 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h1><p>整理完笔记之后，怎么发布到 github.io 上？在这里针对具体的步骤做一份备忘录，防止因为懒惰或其他原因较长时间不发博客，“回归”时还要再次花费时间查阅 Hexo + GitHub Pages 技术帖子。而且，技术相通，但每个人都会培养出属于自己的习惯，不想“回归”时再摸索。</p>
<ol>
<li><p>在 Git Shell 中打开至 hexo 目录。<code> cd hexo</code></p>
</li>
<li><p>敲入 <code>hexo new &quot;filename&quot;</code> 命令。此命令会在 source/_posts 目录下创建 filename.md 文件</p>
<ul>
<li>filename 建议使用英文，且不要存在空白字符。可以使用下划线 _ 连接两个单词。</li>
<li>用翻译工具查一查，起个好名字。</li>
</ul>
</li>
<li><p>打开 source/_posts 目录，使用 MarkdownPad2 编辑文字，修改 title tags categories 属性，保存。</p>
<ul>
<li>一般来说，都是将写好的笔记全文粘贴过来。记得删除源文件，在过一段时间之后维护多个相似文件是很痛苦的。</li>
<li>title 使用中文；tags categories 原则上一律小写。</li>
<li>tags 属性存在多个时，可以这样写 <code>tags: [make,makefile]</code>，但注意每一个 tag 中不能有空格，比如 <code>tags: design pattern</code> 这是错的</li>
</ul>
</li>
<li><p>敲入 <code>hexo generate</code> 生成静态网页。</p>
</li>
<li><p>敲入 <code>hexo server</code> 启动本地服务器，查看效果。</p>
</li>
<li><p>敲入 <code>hexo deploy</code> 发布到互联网。</p>
</li>
<li><p>迁移为知笔记中的内容。“迁移”顾名思义，要从为知笔记中删除。</p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>有讲述整体流程的，有着眼于模块的——描述主题的、强调分类和标签的、添加站内搜索、添加评论的……</p>
<ol start="3">
<li>其中，在 Debian8 上安装 Node.js 使用 <a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">其官方</a> 的 Linux Binaries (.tar.xz) 版本。解压之后直接配置系统 PATH 路径即可。<code>tar xJvf node-v4.4.7-linux-x64.tar.xz</code></li>
<li>如果有更换域名的需求，可以参考 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/05289a4bc8b2">简明Github Pages与Hexo教程</a>，而且作者是在 win7 环境下搭建的，同时文末给出了大量的参考资料。</li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>官方是有 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">辣么多的主题</a> 让我们选，挑花了眼。</p>
<p>2017/4/13，使用新的主题 <a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">NexT</a>。原因有二：</p>
<ul>
<li>Jacman 的搜索不能用。网上有很多其搭配 swiftype，但其他的第三方（比如谷歌）却怎么都调试不成功。</li>
<li>Jacman 作者自己貌似都放弃了，<a target="_blank" rel="noopener" href="http://wuchong.me/">作者自己的博客</a> 使用 NexT 主题是其一，不再维护 Jacman 是关键。</li>
</ul>
<p>使用 NexT 主题，碰到的问题 —— 其 404 页面的配置在使用 https 协议时有问题：</p>
<blockquote>
<p>Hexo NexT 主题给出的腾讯 404 公益页面的教程仅适用于非 HTTPS 站点，对于严格限制混合内容的 HTTPS 站点来说，腾讯 404 公益页面使用的 JS 文件是无法引入的。</p>
</blockquote>
<p>解决方案：<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues/2411">关于 Hexo 上传 404 页面的问题</a></p>
<h2 id="目录和标签"><a href="#目录和标签" class="headerlink" title="目录和标签"></a>目录和标签</h2><p><a target="_blank" rel="noopener" href="http://ijiaober.github.io/2014/08/05/hexo/hexo-04/">Hexo使用攻略：（四）Hexo的分类和标签设置</a></p>
<p>目录和标签有什么区别？关键词：一个目录，多个标签；树状结构，网状结构；</p>
<ol>
<li>怎么给文章添加合适的标签呢？</li>
<li>在目录上尽可能的粗放，再用标签进行管理</li>
<li>使用树状目录尽量不要超过3级。</li>
<li>树状目录应该是和标签系统互补的；</li>
<li>标签起一种聚合作用，将相关性很强的东西联系到一起；分类目录则是相当于存放同类文章的容器，里面的文章虽属同类，相关性却可能不太强。</li>
<li>多参考大牛们的网站</li>
</ol>
<p>不建议你“未雨绸缪”的打上标签。而是在有一定数量的笔记有大量相同性时，再打上标签，目录也是如此。</p>
<p>遵循这么一个原则：想一下读者看了这篇文章后，还会对哪些其他的文章感兴趣，然后这些文章就都添加上同一个标签。这样标签就可以实现目录交叉</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html">利用swiftype为hexo添加站内搜索v2.0</a></p>
<p>swiftype 试用结束后，只能付费。免费试用期到期后，官网登录之后无论点击哪里都是“Your Swiftype free trial has come to an end” 页面，猜测 swiftype 不再提供免费版本，<a target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next/issues/841">佐证</a>。需要寻找备案了……</p>
<p><a target="_blank" rel="noopener" href="https://www.sqlsec.com/2017/12/hexosearch.html">使用本地搜索</a>，安装插件（需要相应的配置项）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h1 id="过程也是结果"><a href="#过程也是结果" class="headerlink" title="过程也是结果"></a>过程也是结果</h1><p>在整理笔记的时候肯定会从网上查找资料，每个知识点肯定都会碰到一篇帖子让自己感慨“哇，总结得好好，娓娓道来，该讲的都讲到了，却也不多一句废话”，每每到此刻都觉得自己整理的笔记就是一坨垃圾，用词不当，表述不清晰，上下文转接不流畅，有的重点落下没讲，废话说太多……可这就是<strong>成长必经的过程</strong>，如果不是整理这个知识点，就不会一板一眼、较真地去查阅好多资料，线上的博客、线下的书，随手 google 来的终究只是编码过程中的 code demo，而非知识，只有当你读了很多篇笔记，看过了很多风景，才能有足够的理解，才能通过已经掌握的，通过对比，认识到某一篇是够精彩的。</p>
<p>如果因为总结的笔记太烂而气馁，放弃整理，那么就不会查阅足够的资料，就不会见到那篇“哇，精彩”的帖子！整理出来的笔记是结果，整理过程中见到的风景也是结果！</p>
<p><strong>ps：</strong>在 2017/4/28 10:13:43  之前的文章大多是从 <a target="_blank" rel="noopener" href="http://www.wiz.cn/">为知笔记</a> 中手动迁移出来的。</p>
<ul>
<li>源于为知笔记不支持账号销户，所以也就没有清空其中的内容，暂时保留一段时间还可以校正迁移过程中的失误；</li>
<li>但在文章全部迁移完毕之后也就不再使用为知笔记了，因为它 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53429669">变更服务策略</a> 太激进了。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/10/17/singleton2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/17/singleton2/" class="post-title-link" itemprop="url">设计模式之单例模式-作业</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-17 17:02:18" itemprop="dateCreated datePublished" datetime="2016-10-17T17:02:18+08:00">2016-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-11 18:12:14" itemprop="dateModified" datetime="2019-08-11T18:12:14+08:00">2019-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/cpp-idioms/" itemprop="url" rel="index">
                    <span itemprop="name">cpp-idioms</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单例模式</p>
<h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><p>实现一（指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton m_Instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_Instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Singleton();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回最好是返回引用，要不然用户会不小心删除掉指针的（如果非要返回指针，最好将析构函数声明为私有的）。</p>
<p>例外：在 DLL 中使用单例模式时，因为主函数结束后执行全局变量（或 <code>static</code> 变量）的析构会出现问题（比如线程无法退出）。此时提供 <code>shutdown()</code> 供用户显式调用，并不比直接暴露指针让用户 <code>delete sington_ptr</code> 高明。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/10/17/singleton2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/10/17/singleton1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/17/singleton1/" class="post-title-link" itemprop="url">设计模式之单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-17 16:58:00" itemprop="dateCreated datePublished" datetime="2016-10-17T16:58:00+08:00">2016-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-29 11:35:45" itemprop="dateModified" datetime="2021-01-29T11:35:45+08:00">2021-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/cpp-idioms/" itemprop="url" rel="index">
                    <span itemprop="name">cpp-idioms</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们从 GoF 说起，书中写到单例模式（Singleton）的意图是：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p>在什么时候会用到单例模式呢？开发过程中常见的应用举例：</p>
<ul>
<li>日志类，一个应用往往只对应一个日志实例：丑陋的写法是在每个场景都实例化一个日志对象使用。</li>
<li>配置类，应用的配置集中管理，并提供全局访问：丑陋的写法是在每次使用配置时都实例化一个配置对象，然后访问配置文件读取其中的配置项。</li>
<li>管理器，比如我们写了一个 windows 服务，然后我们要封装一个启停此服务的管理器。</li>
<li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。比如文件连接，数据库连接等</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/10/17/singleton1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/09/18/Makefile1st/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/18/Makefile1st/" class="post-title-link" itemprop="url">Makefile 入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-18 16:08:08" itemprop="dateCreated datePublished" datetime="2016-09-18T16:08:08+08:00">2016-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-04-26 14:50:54" itemprop="dateModified" datetime="2017-04-26T14:50:54+08:00">2017-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/make/" itemprop="url" rel="index">
                    <span itemprop="name">make</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原来的笔记写于 2015年11月23日，当时使用的是为知笔记默认编辑器。十个月过去了，对于 make &amp; Makefile 也有了更多的认识。今天重新整理一下，不过仍然定位在<strong>入门的帖子</strong>，所以不会添加新的内容，只是修改表述不当的地方，对原有内容作出删减，并用 markdown 格式重写。</p>
<p><strong>这篇本来是打算写成阅读笔记的。但是所知不多，刚开始学习应该博览，求入门，求上手使用。再加上看的东西越来愈多，单纯的记录一篇帖子中的重点、难点，较真于一处在实践中基本不会碰到的细节，格局太小，意义也不大。</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/09/18/Makefile1st/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/26/PKM%20&%20GTD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/26/PKM%20&%20GTD/" class="post-title-link" itemprop="url">PKM & GTD</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-26 17:51:31" itemprop="dateCreated datePublished" datetime="2016-08-26T17:51:31+08:00">2016-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 13:23:20" itemprop="dateModified" datetime="2019-11-19T13:23:20+08:00">2019-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>个人知识管理（PKM）和时间管理（GTD），是很重要的。日常生活学习中肯定有零散的涉及到，但并无系统性、条理性的认识。有关的概念也是近两年才接触到，网上能搜到的东西很多，但太知识性的、深度的“规范”针对普通人又不具有实用价值，即，适当的掌握概念，按照“规则”整理知识，规划时间做事是有价值的，提升会很明显，但对于普通人来说并无掌握其原理的必要，简单的拿来用就可以了。过犹不及。</p>
<p>最重要的是<strong>坚持</strong>。</p>
<p>无论用什么方式，纸笔也好，还是 APP 也好，重要的是坚持，养成习惯。不能三天打鱼两天晒网。</p>
<p>我自己使用过，或正在使用的工具：</p>
<ol>
<li><p>思维导图工具：<a target="_blank" rel="noopener" href="https://www.mindjet.com/mindmanager/">mindjet</a></p>
<p> 最初半年的使用频率非常高，慢慢地到现在一两个月甚至用不上一次。工作、生活过程中记录事情，现在更习惯用列表，是思维固化了？还是这半年涉及的场景不需要发散性的思维？</p>
</li>
<li><p>GTD 工具：<a target="_blank" rel="noopener" href="http://doit.im/cn/">doit.im</a>，到 <a target="_blank" rel="noopener" href="https://www.any.do/">any.do</a>，再到接触 <a target="_blank" rel="noopener" href="http://www.thefabulous.co/">Fabulous</a> 之后简单的使用纸笔记录</p>
<p> 挺好用。坚持得不够，买了一年的会员，高频率使用了半年，闲置了半年之后销户了。直到今天，在 Fabulous 中见到一段话，直戳痛点：</p>
<blockquote>
<p>别掉入<strong>无止境清单症候群</strong>的圈套。换句话说，当你加入太多待办事项，你只会完成最容易的几项。</p>
<p>（而）迅速完成容易的事项会让你有种虚假的成就感。你会发现忙碌了一整天以后，其实并没有在你的终极目标上取得多少进展。</p>
<p>必须养成专注的性格。选择最重要的几件事项，然后除掉其他（相对来说不重要的）。</p>
</blockquote>
<p> doit 我没能坚持下来就是因为错误的使用方式。每天罗列好多的内容，带来虚假的成就感；每天完成一些（大多是最容易的），看着任务打上对勾，被划掉，带来虚假的成就感。甚至为了“打对勾，划掉”写上已经完成的事项，写上不重要的、做不做并无关键区别、随手就能解决、非关键任务等等类似的内容。然后把上午、下午大块大块的完整时间用来处理这些个“自讨的”琐碎任务，以“划掉多少”等价“成就多少”。好脆弱的内心，好虚假的幻想！随着时间的积累（也就是半年），doit 列表中堆积了大量的待办事项，而且都是筛选之后需要花费一定时间、精力并且有意义的事情，积累的越多越是提醒着自己的失败。潜意识里回避真相，现实世界里就做出“不再使用这款工具”的决定。关键问题在于：</p>
<ul>
<li><p>罗列待办事项清单之后，安排事项处理顺序、处理日期不合理，对自身解决问题的能力没有清晰的认识，“拍脑袋”定日期；</p>
<ul>
<li>也就是：不抓重点，或者抓不住重点。精力有限，肯定要做取舍。</li>
</ul>
</li>
<li><p>（因此）计划制定完之后，并不能严格的执行，做不到日清月清，更谈不上总结；</p>
<p>这也是放弃 doit 使用 any.do 之后没多长时间，又放弃 any.do 而使用 Fabulous/纸笔的原因，如果纠正不了根本问题，依旧还会在工具之间跳来跳去，在一个工具上遗留大量的未完事务之后迁移到另一个工具，如此循环，一直得不到解脱。类似的应用层出不穷，上文提到的 3 个是非常棒的了，用好一个就能给生活带来质变，不要因为<strong>错误的习惯</strong>埋没、错过了。</p>
<p>收集任务是前提；<strong>安排任务是关键；</strong>完成任务是目的。不能把时间浪费在“前提”上，在<strong>对自身解决问题的能力有清晰的认识</strong>的基础上，以<strong>量力而行、轻重缓急</strong>为原则<strong>制定当日计划</strong>是重中之重。</p>
<p>制定计划，包含完成时间，还<strong>隐含完成的能力</strong>，而不单单是罗列待办事项，想到的就罗列出来，不管今天能不能完成，今天想到的就列到今天的待办事项里，没有这么无脑操作。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/13/build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/13/build/" class="post-title-link" itemprop="url">构建 build</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-13 19:27:22" itemprop="dateCreated datePublished" datetime="2016-08-13T19:27:22+08:00">2016-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-29 09:45:54" itemprop="dateModified" datetime="2021-01-29T09:45:54+08:00">2021-01-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整理为知笔记中和 make makefile automake 有关内容，成此篇。</p>
<h1 id="从-gcc-说起"><a href="#从-gcc-说起" class="headerlink" title="从 gcc 说起"></a>从 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/">gcc</a> 说起</h1><p>在介绍 make 之前，首先要保证你会使用 gcc/g++ 编译。了解 gcc 执行的四个阶段，知道预编译阶段、链接阶段需要什么，做什么操作；知道预编译时找不到头文件，链接时缺少库文件怎么处理；知道动态库、静态库的区别，怎么创建并使用它们。以上是必需的！只有掌握了上面的内容，才能保证面对一个简单的项目（可能包含头文件、源文件和链接库）知道怎么组织，最终得到可执行文件。</p>
<p>维基百科的描述：</p>
<blockquote>
<p>GNU编译器套装（英语：GNU Compiler Collection，缩写为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GCC">GCC</a>），一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p>
</blockquote>
<h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>预处理、编译、汇编和链接。学习 gcc，比较重要的是预处理和链接：</p>
<p>参考 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/youxin/p/3181214.html">gcc编译4个阶段</a></p>
<ol>
<li><p>预处理阶段</p>
<blockquote>
<p>预处理器（cpp）根据以字符#开头的命令（directives），修改原始的C程序。</p>
</blockquote>
<p> 也就是说预处理阶段，会查找并加载头文件生成一个新的C程序。</p>
</li>
<li><p>编译阶段</p>
<p> 编译阶段会将代码翻译成汇编语言。</p>
<blockquote>
<p>汇编语言是非常有用的，它为不同高级语言不同编译器提供了 通用的语言。如：C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
</blockquote>
</li>
<li><p>汇编阶段</p>
<p> 汇编阶段将汇编语言程序转换成为目标文件，也就是二进制机器码。</p>
</li>
<li><p>链接阶段</p>
<p> 该阶段将用到的一个或多个目标文件（库文件）链接生成可执行文件。</p>
<blockquote>
<p>在预编译阶段包含进来的“stdio.h”中只有“printf”函数的声明，而没有函数的实现，那么，是在哪里实现的“printf”函数呢？答案是：系统把这些函数实现都做到名为libc.so.6的库文件中去了，链接阶段gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf” 了，而这也就是链接的作用。</p>
</blockquote>
<p> 从上面可以看出，链接时需要目标文件的名称及其所在目录。</p>
</li>
</ol>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>知道了预处理器（cpp）要读取头文件，那么报错“xxx.h:No such file or directory”就需要确认我们是不是指定了查找目录，或者核对我们指定的路径是否包含该头文件；同样的道理，链接器（ld）需要链接目标文件，和前者稍有不用的地方在于：头文件一般都写在源代码中，我们只需要指定头文件路径；而链接目标文件时，既需要我们指出目标文件所在的目录，同时还需要我们指定使用目标路径下的哪个文件。</p>
<p>以上算是原理。知其所以然之后，我们来看工具具体的使用方法：</p>
<ol>
<li>头文件相关的： -I 后跟绝对路径或相对路径，例如 <code>-I ./include</code>。预处理器会优先在 @搜索路径</li>
<li>链接过程： -L 后跟绝对路径或相对路径，例如 <code> -L ./lib</code>， -l 后跟库名，例如 <code>-lmath</code>，对应库文件 libmath.a 或 libmath.so</li>
<li>-c：使用源文件生成对应的目标文件，而不进行链接，使用  ，例如 <code>g++ -c main.cpp -o main.o</code></li>
<li>-Wall：使 gcc 产生尽可能多的警告信息，并非全部。</li>
<li>-Werror：把警告当做错误处理，即产生 warning 时就停止编译操作。</li>
</ol>
<p>特殊的参数：</p>
<ol>
<li><p>-nostdinc：使编译器不在系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置。</p>
</li>
<li><p>-Wl,-rpath：在<strong>编译过程</strong>指定程序在<strong>运行时</strong>动态库的搜索路径，示例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔</span><br><span class="line">gcc -Wl,-rpath,libPath -L libPath -ltest hello.c</span><br></pre></td></tr></table></figure>
<p> 将搜索路径信息写入可执行文件(rpath代表runtime path)。这样就不需要设置环境变量。坏处是，如果库文件移动位置，我们需要重新编译test。</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>更多的参数，更详细的使用说明可以查看 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/6.1.0/">官方手册</a>，或者使用 man info –help 等方式获取。</p>
<h3 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h3><p>测试环境：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vimer@debian8light:~/code/test_search$ uname -a</span><br><span class="line">Linux debian8light 3.16.0-4-amd64 <span class="comment">#1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29) x86_64 GNU/Linux</span></span><br><span class="line">vimer@debian8light:~/code/test_search$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Debian</span><br><span class="line">Description:	Debian GNU/Linux 8.3 (jessie)</span><br><span class="line">Release:	8.3</span><br><span class="line">Codename:	jessie</span><br><span class="line">vimer@debian8light:~/code/test_search$ </span><br></pre></td></tr></table></figure>
<p>在 gcc version 4.9.2 (Debian 4.9.2-10) 环境下实际测试，linux 编译时头文件的搜索路径：</p>
<ol>
<li>搜索会从 -I 开始</li>
<li>再找 /usr/lib/gcc/x86_64-linux-gnu/4.9/include</li>
<li>再找 /usr/local/include/</li>
<li>查找 /usr/include/</li>
</ol>
<p>此测试只是确定以上 4 者相对的先后。测试时未包含更多的潜在的搜索路径，比如 gcc 的环境变量 C_INCLUDE_PATH、CPLUS_INCLUDE_PATH、OBJC_INCLUDE_PATH</p>
<p>两种不类型的头文件 <code>#include&lt;&gt;</code> 和 <code>#include&quot;&quot;</code> 搜索规则：</p>
<ol>
<li>使用&lt;&gt;包含的头文件一般会先搜索-I选项后的路径（即用gcc编译时的-I选项，注意是大写），之后就是标准的系统头文件路径。</li>
<li>而用””号包含的头文件会首先搜索当前的工作目录，之后的搜索路径才是和&lt;&gt;号包含的头文件所搜索的路径一样的路径。</li>
</ol>
<p><strong>事实上，知道上述提及的搜索路径即可。不必学究式地死记硬背之间的搜索顺序，能有多少意义呢？。</strong></p>
<p>更直接、简单的方式，确认查找头文件时的路径搜索顺序。参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/maximuszhou/article/details/38559963">使用gcc时头文件路径和动态链接库路径</a>， 通过使用 -v 参数看到：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;...&quot; search starts here:</span></span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> ./include</span><br><span class="line"> /usr/include/c++/4.9</span><br><span class="line"> /usr/include/x86_64-linux-gnu/c++/4.9</span><br><span class="line"> /usr/include/c++/4.9/backward</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include</span><br><span class="line"> /usr/<span class="built_in">local</span>/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>在此不再具体测试编译过程中链接库文件时的搜索顺序、运行时动态库的搜索顺序，真正需要用之间的搜索顺序时再写代码测试。</p>
<h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><p>在“链接阶段”一节中出现了库文件“libc.so.6”。@Linxu 中动态库</p>
<p>@引出静态库</p>
<p>@动态链接和静态链接</p>
<h1 id="make-和-Makefile"><a href="#make-和-Makefile" class="headerlink" title="make 和 Makefile"></a><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">make</a> 和 Makefile</h1><p>make 命令用来解释、执行 Makefile文件。针对开发 C++ 程序来说：Makefile 文件是对项目文件（以源文件、链接库为主，也包括头文件）依赖关系的描述，是对 gcc 命令的有效组织。抛开依赖关系，如果项目不复杂，你也可以用 shell 脚本来组织 gcc 命令，前提是根据依赖关系调整好编译命令的排序。虽然能够得到同样的结果，但是执行的效率不如前者，容错的能力不如前者，耗费的精力更是项目越大越难以承受。事实上：</p>
<blockquote>
<p>在make诞生之前，编译工作主要依赖于操作系统里面的类似于“make”、“install”功能的shell脚本。</p>
</blockquote>
<p>来看看维基百科中的描述：</p>
<blockquote>
<p>在软件开发中，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Make">make</a> 是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。</p>
<p>它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。</p>
<p>它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。</p>
</blockquote>
<p>需要注意的是我们在 Linux 上用的一般是 make 的重写/改写版本 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">GNU Make</a>，除此之外还有 BSD Make 等。</p>
<p>我们来看怎么写 Makefile 文件。</p>
<h1 id="automake"><a href="#automake" class="headerlink" title="automake"></a><a target="_blank" rel="noopener" href="https://www.gnu.org/software/automake/">automake</a></h1><p>人工写 Makefile 文件已经满足不了我们了。事实是人越来越懒，项目也越来越大，我们希望电脑帮我们做更多的工作。引用 Wikipedia 中的描述：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Automake">GNU Automake</a> 是一种编程工具，可以产生供 make 程式使用的 Makefile，用来编译程式。它是自由软件基金会发起的 GNU 计划的其中一项，作为 GNU 构建系统的一部分。automake 所产生的Makefile 符合 GNU 编程标准。</p>
<p>automake 是由 Perl 语言所写的，必须和 GNU autoconf 一并使用。</p>
</blockquote>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>以下概念当做扩展知识保留下来，如果有兴趣可以展开学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Portable_Executable">PE 文件</a> 和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F">ELF 文件</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/13/headfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/13/headfile/" class="post-title-link" itemprop="url">怎么写头文件：内部链接、外部链接</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-13 19:16:39" itemprop="dateCreated datePublished" datetime="2016-08-13T19:16:39+08:00">2016-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 18:32:28" itemprop="dateModified" datetime="2019-11-18T18:32:28+08:00">2019-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由内部链接、外部链接引出怎么写头文件。</p>
<p>我看了一下，这篇笔记最早是在六月二号创建的，可是现在 2016/8/13 16:12:05 ，呵呵。一方面是自己懒，另一方面，对于“内部链接、外部链接”的概念，不多了解一些，不敢随便整理啊。</p>
<p>我们先看看 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">维基百科- 头文件</a> 中说了什么：</p>
<blockquote>
<p>当一个子程序在定义的位置以外的地方被使用时，就需要进行<strong>前置声明</strong>，声明函数原型等。</p>
</blockquote>
<p>假设一个程序员不用“头文件”，那么他至少需要在两个地方维护函数的声明：一个是包含函数实现的的文件，以及使用该函数的文件。如果使用该函数的文件有很多个，那么对函数的定义进行更改时就是灾难。</p>
<p>从某个方面来说，头文件降低了这种场景中程序员手工操作的复杂度（解放双手，繁琐的工作交给机器/编译器）。更重要的是保证了编写大型项目的易用性，难以想象如果没有头文件，几十万行的代码全都在一个源文件中。</p>
<p>将函数原型移到 XXX 头文件中之后，我们可以在需要的地方通过 <code>#include &lt;XXX&gt;</code> <em>预处理器指令</em> 将其包含进来，这样每次编译时预处理阶段就会将 XXX 文件中的内容替换掉 <code>#include &lt;XXX&gt;</code> ，我们的函数原型也就被“前置声明”了。</p>
<p>阅读 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Include_directive">wikipedia - include derective</a>，我们可以从更高的层次考虑 Include 行为，想想 Makefile 中的 include，shell 脚本中的 include，表示类似甚至同样意义的关键字还有 import、copy。</p>
<p>在 C 语言中，什么内容需要放在头文件中，什么内容可以放在头文件中相对来说是比较容易区分的。接下来我们看看在 C++ 中，什么东西可以放在 .h 文件中，什么不能，什么东西又可以放在 .cpp 文件中。</p>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>首先需要区分开这两个概念，只是理解所有关键问题的前提。在笔记中暂时不展开说了，如果分不清楚，自行 Google。这里只备注几个容易混淆的条目：</p>
<ul>
<li><p>声明</p>
<ol>
<li><p>仅仅提供函数原型。类外面的，类里面的</p>
</li>
<li><p>class A；</p>
</li>
<li><p>typedef声明</p>
</li>
<li><p>在类中定义的静态数据成员的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义</p>
<ol>
<li><p>在类定义之外，定义并初始化一个静态数据成员。如 A::a=0;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A::a=<span class="number">0</span>；  <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li>
<li><p>在类外定义非内联成员函数</p>
</li>
</ol>
</li>
</ul>
<h1 id="内部链接和外部链接"><a href="#内部链接和外部链接" class="headerlink" title="内部链接和外部链接"></a>内部链接和外部链接</h1><p>参考自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/ithzhang/article/details/8119286">参考链接1</a>、<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">解析C++中的内部连接与外部连接</a></p>
<p>链接把不同编译单元产生的符号联系起来。有两种链接方式：内部链接和外部链接。</p>
<h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><p>如果一个符号名对于它的编译单元来说是局部的，并且在链接时不可能与其他编译单元中的同样的名称相冲突，那个这个符号就是内部链接。内部链接意味着对此符号的访问仅限于当前的编译单元中，对其他编译单元都是不可见的。</p>
<p>具有内部链接的符号无法作用于当前文件外部，要让其影响程序的其他部分，可以将其放在.h文件中。此时在所有包含此.h文件的源文件都有自己的定义且互不影响。</p>
<ol start="0">
<li><p>所有的声明，包括类的声明，比如：<code>class A;</code>；(有时也将声明看作是无连接的，这里我们统一看成是内部连接的)。</p>
<p> 由于声明只对当前编译单元有用，因此声明并不将任何东西写入.o文件。</p>
<p> 这些声明<strong>本身</strong>不会影响到.o文件的内容。在编译阶段（狭义的，从高级语言到汇编语言到二进制，从 main.i 到 main.o，预处理已过，尚未链接），编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会报错。链接阶段，声明已经没有用了。</p>
<p> 而函数调用会导致一个未定义的符号被写入到.o文件，此后此.o文件与定义此符号的.o文件被连接在一起，前面未定义的符号被解析。</p>
</li>
<li><p>局部变量肯定是内部链接性质的，更应该被看作无连接的；</p>
</li>
<li><p>全局变量，如果使用了 static、const 关键词修饰，其作用域仅仅在当前文件作用域内，其他文件中即使使用extern声明也是无法使用的。因此，带有 static、const 关键字的全局变量也是内部链接性质的；</p>
<p> static 和 const 还是有区别的。static 和 extern不能对同一个变量同时声明；但 const 和 extern 不是同一存储类别，可以同时用在同一个变量的声明。所以，我们可以用使用extern关键字修改const的连接属性。<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wangpei0522/p/4459624.html">更多详情</a>、<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiexievv/article/details/8491494">特别说明</a></p>
</li>
<li><p>枚举 enum、联合 union 类型是内部链接性质的；</p>
</li>
<li><p><strong>类的定义</strong>是内部链接性质的：</p>
<ul>
<li><p>定义，意味着在同一编译单元中不能重复出现；</p>
</li>
<li><p>内部链接性质，意味着如果需要在其他编译单元使用，类必须被定义在头文件且被其他文件包含。</p>
<p>  仅仅在其他文件中使用class a;声明是不行的，原因就是类的定义是内部链接，不会在目标文件导出符号。也就不会被其他单元解析它们的未定义符号。</p>
</li>
</ul>
</li>
<li><p>内联函数定义（包括自由函数和非自由函数）。</p>
<p> 内联函数之所有具有内部链接，因为编译器在可能的时候，会将所有 对函数的调用替换为函数体，不将任何符号写入.o文件。</p>
</li>
<li><p>名字空间(包括全局名字空间)中的静态自由函数、静态友元函数、静态变量的定义。<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
</li>
</ol>
<h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p>在一个多文件的程序中，如果一个符号在链接时可以和其他编译单元交互，那么这个名称就有外部链接。外部链接意味着该定义不仅仅局限在单个编译单元中。它可以在.o文件中产生外部符号。可以被其他编译单元访问用来解析它们未定义的符号。因此它们在整个程序中必须是唯一的，否则将会导致重复定义。</p>
<p><strong>区分：</strong>判断一个符号是内部链接还是外部链接的一个很好的方法就是看该符号是否被写入.o文件。</p>
<ol>
<li><p>类非内联成员函数，包括类成员函数和类静态成员函数</p>
</li>
<li><p>类的静态数据成员的定义具有外部链接性质</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 内部链接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::a = <span class="number">0</span>;  <span class="comment">// 外部链接</span></span><br></pre></td></tr></table></figure></li>
<li><p>非内联函数</p>
</li>
<li><p>名字空间(包括全局名字空间)中非静态自由函数、非静态友元函数及非静态变量。<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
<p> 前提是认为，类之外一般不存在使用 inline 修饰的函数。</p>
</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a target="_blank" rel="noopener" href="http://www.52rd.com/Blog/Detail_RD.Blog_imjacob_5682.html">摘抄来源</a></p>
<p>Linkage</p>
<p>To understand the behavior of C and C++ programs, you need to know about linkage. In an executing program, an identifier is represented by storage in memory that holds a variable or a compiled function body. Linkage describes this storage as it is seen by the linker. There are two types of linkage: internal linkage and external linkage.</p>
<p>Internal linkage means that storage is created to represent the identifier only for the file being compiled. Other files may use the same identifier name with internal linkage, or for a global variable, and no conflicts will be found by the linker – separate storage is created for each identifier. Internal linkage is specified by the keyword static in C and C++.</p>
<p>External linkage means that a single piece of storage is created to represent the identifier for all files being compiled. The storage is created once, and the linker must resolve all other references to that storage. Global variables and function names have external linkage. These are accessed from other files by declaring them with the keyword extern. Variables defined outside all functions (with the exception of const in C++) and function definitions default to external linkage. You can specifically force them to have internal linkage using the static keyword. You can explicitly state that an identifier has external linkage by defining it with the extern keyword. Defining a variable or function with extern is not necessary in C, but it is sometimes necessary for const in C++.</p>
<p>Automatic (local) variables exist only temporarily, on the stack, while a function is being called. The linker doesn’t know about automatic variables, and so these have no linkage.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>综上，我们可以知道：将具有外部链接的定义放在头文件中几乎都是编程错误。因为如果该头文件中被多个源文件包含，那么就会存在多个定义，链接时就会出错。</p>
<p>在头文件中放置内部链接的定义却是合法的，但不推荐使用的。</p>
<p>链接，本质上都是具有<strong>外部链接性质的符号们</strong>的事情！</p>
<h2 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h2><p>头文件为相关声明提供了一个集中存放的位置。头文件一般包含类的定义、枚举的定义、extern变量的声明、函数的声明、const int的定义、inline函数的定义。使用或者定义这些实体的文件要包含适当的头文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/07/30/learnSche_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/learnSche_cpp/" class="post-title-link" itemprop="url">学习 C++</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 11:00:15" itemprop="dateCreated datePublished" datetime="2016-07-30T11:00:15+08:00">2016-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2016-12-09 15:31:12" itemprop="dateModified" datetime="2016-12-09T15:31:12+08:00">2016-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>跌跌撞撞，兜来绕去，终究还是在 C++ 这个圈子里。毕业时，因为身外事去选择工作单位，而工作单位决定了工作性质，决定了自己处在做软件的边缘，甚至一度成为网管。两年之后跳出陷阱时，背负着“过去的选择”走进了 C++ 的世界，因为一无所长，在诸多技术更迭交替的 IT 圈我像个刚入门的新人似的，只了解一点点 VC++。我没有从头来过的魄力，我也并不清楚 Java 是否更有前途，互联网是否更多辛苦。</p>
<p>在毕业刚好三年的边上，想着“就是 C++ 了”其实很愚蠢。通过做决定安慰自己“明智”，其实只是没得选择的妥协。此时此刻应该想的是“如何学好 C++”，更现实一点“掌握 C++ 的哪些内容，能找到更好的工作”。暂时确定的目标：</p>
<ol>
<li>会写代码。强调编码规范。</li>
<li>会编写类，使用类。强调抽象思维。</li>
<li>数据库操作，封装</li>
<li>并发（多线程），POSIX、boost、C++11原生支持</li>
<li>通信，socket 编程</li>
</ol>
<p>曾经完美主义，现在坚持实用主义。站在公司的角度考虑，现实中生产使用，强调实用性。如果新特性带不来生产力上的提升，是不会有公司买账的。就是说是否掌握 C++11 甚至更新的特性，对找工作没有最直接的影响，如果带不了更高的生产力，都是空谈。不应该只为了关注新特性，学究式地死板地投入时间精力，要明白花时间做一件事的初衷、目的、意义和价值。举例来说，做并发时是否使用 C++11 的原生支持，在投产使用时没有什么影响的，重要的是能否解决问题，解决问题的能力，关键是把并发做出来，用什么技术往往并不重要。</p>
<p>那就好好学 C++11。工欲善其事，必先利其器。有兴趣可以看看<a target="_blank" rel="noopener" href="http://www.csdn.net/article/2012-08-13/2808540">各编译器对 C++11 的支持情况</a>、<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a>，但选择 g++ 总是省心的，前提是版本足够新，有条件就用最新的。编译器有了，<strong>编辑</strong>代码呢？主要关注代码提示，开发者体验。</p>
<ul>
<li>在 Windows 上考虑使用 VS2015，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23776769">轮子哥的观点 - 知乎</a>。个人观点，除了太大并不排斥 VS。</li>
<li>Linux 上呢？很难找到完善支持 C++11 代码提示的 IDE…<a target="_blank" rel="noopener" href="http://zuyunfei.com/2013/05/16/killer-plugin-of-vim-youcompleteme/">Vim代码补全</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22096642">Vim 和 IDE 之争 - 知乎</a>，个人观点，两者会越来越像，追求生产力。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/07/30/learnSche_cpp/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/07/15/Flume%20&%20Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/15/Flume%20&%20Redis/" class="post-title-link" itemprop="url">Flume & Redis 学习笔记V0.1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-15 11:18:07" itemprop="dateCreated datePublished" datetime="2016-07-15T11:18:07+08:00">2016-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 13:23:20" itemprop="dateModified" datetime="2019-11-19T13:23:20+08:00">2019-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flume-学习笔记"><a href="#Flume-学习笔记" class="headerlink" title="Flume 学习笔记"></a>Flume 学习笔记</h1><p><a target="_blank" rel="noopener" href="http://shiyanjun.cn/archives/915.html">Flume(NG)架构设计要点及配置实践</a>，在此基础上的扩展：<a target="_blank" rel="noopener" href="http://blog.javachen.com/2014/07/22/flume-ng.html">Flume-ng的原理和使用</a></p>
<ol>
<li>Agent 的串联、并联</li>
<li>Source 一般都是单一 Source；Source 一对多 Channel，分为复制（replication）和分流（multiplexing）</li>
<li>Channel 一对多 Sink，实现负载均衡（load balance）和故障转移（failover）</li>
</ol>
<p>在上述中多提到 Avro，在 Flume 的配置文件中也用到此项。<a target="_blank" rel="noopener" href="http://blog.javachen.com/2015/03/20/about-avro.html">Avro 介绍</a>，但目前不需要了解。</p>
<blockquote>
<p>Avro 是 Hadoop 中的一个子项目，也是 Apache 中一个独立的项目，Avro 是一个基于二进制数据传输高性能的中间件。</p>
</blockquote>
<h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><p><a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart">Redis Quick Start</a></p>
<ol>
<li>在安装过程中，如果缺少依赖项，需要先编译 deps 目录。</li>
<li>将 redis 加入系统启动项，手册中使用 <code>sudo update-rc.d redis_6379 defaults</code>。但此命令只在 Debian 系下使用。</li>
</ol>
<h1 id="70-13x-系列服务器搭建指南"><a href="#70-13x-系列服务器搭建指南" class="headerlink" title="70.13x 系列服务器搭建指南"></a>70.13x 系列服务器搭建指南</h1><ol start="0">
<li><p>先安装 jdk，配置好 JAVA_HOME 环境变量</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/cts/tool/jdk1.6.0_45/</span><br><span class="line"><span class="built_in">export</span> JAVA_BIN=<span class="variable">$JAVA_HOME</span>/bin/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jreb:<span class="variable">$JAVA_HOMEb</span>/tools.jar</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart#installing-redis">安装 redis</a>，<a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart#installing-redis-more-properly">启动 redis</a></p>
<ul>
<li>如果需要，可以配置主从 redis</li>
</ul>
</li>
<li><p>使用 cts2Cache-v0.2 程序初始化 redis</p>
<ul>
<li>执行 run-Init.sh 脚本执行初始化，需要修改 cts2Cache-0.1.0.jar 中配置文件 redis IP；</li>
<li>使用 crontab 命令设置定时任务，每日执行 run-update-recv.sh 和 run-update-send.sh 脚本生成次日的节目表；</li>
</ul>
</li>
<li><p>使用 cts2LogGate 程序开启日志网关</p>
<ul>
<li>参考 visio 图</li>
<li>依照 send、recv、mu、lb 顺序开启，使用 kill 命令逆序关闭</li>
<li>开启时可以使用 nohup 命令</li>
<li>怎么关闭呢？</li>
</ul>
</li>
<li><p>向日志网关发送日志</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/06/13/writing2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/13/writing2/" class="post-title-link" itemprop="url">使用 Markdown 注意事项</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-13 13:15:05" itemprop="dateCreated datePublished" datetime="2016-06-13T13:15:05+08:00">2016-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-28 17:01:33" itemprop="dateModified" datetime="2021-01-28T17:01:33+08:00">2021-01-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分为语法和工具两个部分，备忘录。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在使用 JotterPad（CommonMark）阅读 markdown 格式的文本时，发现的细节：</p>
<ol>
<li><p>标题 <code>#</code> 后需要有空格，才能解析成标题，不然就是文本；【重要】</p>
<ul>
<li>进一步修正：任意级别的标题行前后添加空行，至少标题行之前要有空行，<code>#</code> 之后添加空格；</li>
</ul>
</li>
<li><p>使用参考式链接时，链接网址只能放在文件最末尾，不然识别不出来；【重要】</p>
</li>
<li><p>引用内使用编号问题：</p>
<blockquote>
<p>引用文字</p>
<ol>
<li>item1</li>
<li>item</li>
</ol>
<p>编号结束，结尾的引用文字</p>
</blockquote>
</li>
<li><p>怎么写代码块？——是解析的，只不过呈现方式只体现在字体上，排版效果并不明显。</p>
</li>
<li><p><del>尽量不要嵌套使用。在 GitHub 上项目的 README.md 都不复杂。占一屏幕，不需要滚屏。</del> 建议很值得采纳，但实在是不实用。</p>
</li>
<li><p>可以做图片链接的哦，惊喜</p>
</li>
<li><p><del>嵌套时无需有空行（分段需求除外，比如引用时），当两个模块是平行关系时需要有空行（列表除外，列表项之间添加空行会引入 &lt;p&gt;）。参考 1.1 节</del></p>
</li>
<li><p>中英文混合排版加不加空格问题，持保留态度，无论加或者不加，都保持原状。</p>
<ol>
<li><p>强调语义，不加；强调呈现，添加。</p>
</li>
<li><p>书写笔记不考虑纯手工补充空格，为了表现效果美观<strong>吹毛求疵</strong>，时间成本太高，没有意义。【重要】</p>
<p>扩展阅读：</p>
</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.geekpark.net/topics/198213">不仅仅是空格的问题——再谈中西文混排</a></li>
</ul>
</li>
<li><p>测试 item</p>
</li>
</ol>
<h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><p>模块之间的嵌套使用，怎么书写是规范的一直是一件比较困惑的事情。但在我写下这篇文字的时候，我已经感觉到胜利在朝我招手了。</p>
<p>首先一定要有意识区分“块元素（Block Element）”和“Span Element”，对于熟悉 html 的程序员来说可能是很 easy 的一件事情，但是虽然我用 Markdown 两三个月，相关的操作手册、语法说明也看了很多，但我是自动过滤这两个单词的，讲解标题（用不同数目的 # 区分标题级别）和强调（用 * 斜体，** 加粗）时肯定是分别放在 Block Element 和 Span Element 中介绍，但我脑子里是没有这两个概念的，我并未意识到它们意味着什么，甚至并未意识到它们的存在。我真的是个前端白痴，原谅我。</p>
<ol>
<li><p>块元素（Block Element）包括：</p>
<ul>
<li>标题</li>
<li>引用</li>
<li>列表，注意是整个列表，而不是列表的 item</li>
<li>代码块</li>
<li>分割线</li>
</ul>
</li>
<li><p>Span Element 包括：</p>
<ul>
<li>链接</li>
<li>强调</li>
<li>代码</li>
<li>图片</li>
</ul>
</li>
</ol>
<p>块元素是涉及嵌套的主体！Span Element 不是。所以嵌套问题是块元素的嵌套问题，额，如果我了解 html 多好。</p>
<h2 id="结论（针对-GFM）"><a href="#结论（针对-GFM）" class="headerlink" title="结论（针对 GFM）"></a>结论（针对 GFM）</h2><p><strong>秘籍：</strong>（在严格坚持第一点的基础上，除却以下情况不会用到第二点：如果问题出现在章节末尾（见本文末尾）、列表末尾，使用第二点）</p>
<ol>
<li><p>每个独立的块元素（包括分段）之后留有空行，标题、分割线可以除外；</p>
</li>
<li><p>哪个块元素解析有问题，就在哪个块元素之前加空行；</p>
<ol>
<li>为了保证一致性（特殊情形，即当前嵌套情形（列表主体除末尾空行无其他空行，且在末尾嵌套有子列表）），要求嵌套子列表时，子模块前添加空行（即本行之前的空行，否则解释时不完美）；</li>
</ol>
</li>
<li><p>综合上述两点，在每个块元素（包括分段）的前后添加空行可以保证所有情形下解释正确。唯一的不足在于阅读源文本时可能稍显松散。</p>
</li>
<li><p>其实，在每个块元素（包括分段、标题、分割线）之前留有空行是不是就万事大吉了呢？【重要】</p>
</li>
</ol>
<p><strong>详细描述：</strong></p>
<ol>
<li><p>分段用空行，这句是废话；</p>
</li>
<li><p>标题之前加空行，保证所有情况下语法正常解释；【重要】</p>
<ul>
<li>如果前置标题、分割线或者普通段落，则没有空行语法也能正常解释；</li>
<li>如果前置列表、引用等，没有空行，语法解释后呈现有问题；</li>
</ul>
</li>
<li><p>空行意味着引用、列表的结束；标题、分割线是单行的；GFM 中代码块是 ``` 结束的。多个空行合并成一个。</p>
<ul>
<li>分段时，空行意味着段落的结束；</li>
<li>非分段情况下，段落之后不用跟空行。接标题、引用、<del>列表、</del>代码块都意味着段落结束。</li>
<li>非分段情况下，段落之后无空行直接跟有序列表，是有问题的；直接跟无序列表没问题；</li>
<li>综合上述三条，建议每个独立的块元素之后留有空行，标题、分割线除外【重要】</li>
</ul>
</li>
<li><p>列表内容拥有缩进概念；</p>
<ul>
<li>列表 item 中缩进内容（针对引用、代码块）前（或者后）加空行；否则语法无法正常解释</li>
<li>缩进内容为列表（即嵌套子列表）时，按照规则建议添加空行。即使无空行，语法也能正常解释，看着还顺眼一点</li>
<li>综合上述两条，建议在嵌套子模块的结尾留有空行【重要】</li>
</ul>
</li>
</ol>
<p>补充说明：</p>
<ol>
<li><p>列表的 item 之间一般不需要空行（分段除外），如果</p>
<blockquote>
<p>如果列表项之间有空行，markdown会给每一个生成的li元素创建一个p:</p>
</blockquote>
</li>
</ol>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>前两年一直使用的 MarkdownPad2，后来随着系统更新（而软件并未跟进）出现了几项功能性问题，虽然也能通过某些手段结局，但无疑是影响体验的。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40eb4f8207d1" title="MarkdownPad 2 使用问题">MarkdownPad 2 使用问题</a></p>
<p>在此基础上，由于对 Visual Studio Code 好奇心（喜新厌旧嘛），放弃了使用 MarkdownPad2，但回头再看（2020/12/25 17:38:28 ）前者也只那些 vimer 的狂欢，经过各种调教之后可能好用，但调教本身也是成本。</p>
<blockquote>
<p>快捷键支持并不完全。还是算了。<a target="_blank" rel="noopener" href="https://lanlan2017.github.io/blog/11f888fa/">来源</a></p>
</blockquote>
<p>深有感触，不胜其烦。所以又回归了 MarkdownPad2</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tnie & ilyw"
      src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
  <p class="site-author-name" itemprop="name">tnie & ilyw</p>
  <div class="site-description" itemprop="description">家人是奋斗的初衷，路途艰辛时常思初心。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tnie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tnie" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/nie7g" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;nie7g" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tnie & ilyw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>














  

  

</body>
</html>
