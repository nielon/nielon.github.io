<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="不积小流，无以成江海" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'AWLTH1YPN5',
      apiKey: 'd9101fc28af07d0ea8ade8654c1dc48b',
      indexName: 'test_niel',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:type" content="website">
<meta property="og:title" content="不积小流，无以成江海">
<meta property="og:url" content="https://tnie.github.io/page/12/index.html">
<meta property="og:site_name" content="不积小流，无以成江海">
<meta property="og:description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tnie &amp; ilyw">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tnie.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>不积小流，无以成江海</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不积小流，无以成江海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">海纳百川，有容乃大</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/10/17/singleton1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/17/singleton1/" class="post-title-link" itemprop="url">设计模式之单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-17 16:58:00" itemprop="dateCreated datePublished" datetime="2016-10-17T16:58:00+08:00">2016-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-11 18:08:25" itemprop="dateModified" datetime="2019-08-11T18:08:25+08:00">2019-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/cpp-idioms/" itemprop="url" rel="index">
                    <span itemprop="name">cpp-idioms</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们从 GoF 说起，书中写到单例模式（Singleton）的意图是：</p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p>在什么时候会用到单例模式呢？开发过程中常见的应用举例：</p>
<ul>
<li>日志类，一个应用往往只对应一个日志实例：丑陋的写法是在每个场景都实例化一个日志对象使用。</li>
<li>配置类，应用的配置集中管理，并提供全局访问：丑陋的写法是在每次使用配置时都实例化一个配置对象，然后访问配置文件读取其中的配置项。</li>
<li>管理器，比如我们写了一个 windows 服务，然后我们要封装一个启停此服务的管理器。</li>
<li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。比如文件连接，数据库连接等</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/10/17/singleton1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/09/18/Makefile1st/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/18/Makefile1st/" class="post-title-link" itemprop="url">Makefile 入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-18 16:08:08" itemprop="dateCreated datePublished" datetime="2016-09-18T16:08:08+08:00">2016-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-04-26 14:50:54" itemprop="dateModified" datetime="2017-04-26T14:50:54+08:00">2017-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/make/" itemprop="url" rel="index">
                    <span itemprop="name">make</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原来的笔记写于 2015年11月23日，当时使用的是为知笔记默认编辑器。十个月过去了，对于 make &amp; Makefile 也有了更多的认识。今天重新整理一下，不过仍然定位在<strong>入门的帖子</strong>，所以不会添加新的内容，只是修改表述不当的地方，对原有内容作出删减，并用 markdown 格式重写。</p>
<p><strong>这篇本来是打算写成阅读笔记的。但是所知不多，刚开始学习应该博览，求入门，求上手使用。再加上看的东西越来愈多，单纯的记录一篇帖子中的重点、难点，较真于一处在实践中基本不会碰到的细节，格局太小，意义也不大。</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/09/18/Makefile1st/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/26/PKM%20&%20GTD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/26/PKM%20&%20GTD/" class="post-title-link" itemprop="url">PKM & GTD</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-26 17:51:31" itemprop="dateCreated datePublished" datetime="2016-08-26T17:51:31+08:00">2016-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 13:23:20" itemprop="dateModified" datetime="2019-11-19T13:23:20+08:00">2019-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>个人知识管理（PKM）和时间管理（GTD），是很重要的。日常生活学习中肯定有零散的涉及到，但并无系统性、条理性的认识。有关的概念也是近两年才接触到，网上能搜到的东西很多，但太知识性的、深度的“规范”针对普通人又不具有实用价值，即，适当的掌握概念，按照“规则”整理知识，规划时间做事是有价值的，提升会很明显，但对于普通人来说并无掌握其原理的必要，简单的拿来用就可以了。过犹不及。</p>
<p>最重要的是<strong>坚持</strong>。</p>
<p>无论用什么方式，纸笔也好，还是 APP 也好，重要的是坚持，养成习惯。不能三天打鱼两天晒网。</p>
<p>我自己使用过，或正在使用的工具：</p>
<ol>
<li><p>思维导图工具：<a target="_blank" rel="noopener" href="https://www.mindjet.com/mindmanager/">mindjet</a></p>
<p> 最初半年的使用频率非常高，慢慢地到现在一两个月甚至用不上一次。工作、生活过程中记录事情，现在更习惯用列表，是思维固化了？还是这半年涉及的场景不需要发散性的思维？</p>
</li>
<li><p>GTD 工具：<a target="_blank" rel="noopener" href="http://doit.im/cn/">doit.im</a>，到 <a target="_blank" rel="noopener" href="https://www.any.do/">any.do</a>，再到接触 <a target="_blank" rel="noopener" href="http://www.thefabulous.co/">Fabulous</a> 之后简单的使用纸笔记录</p>
<p> 挺好用。坚持得不够，买了一年的会员，高频率使用了半年，闲置了半年之后销户了。直到今天，在 Fabulous 中见到一段话，直戳痛点：</p>
<blockquote>
<p>别掉入<strong>无止境清单症候群</strong>的圈套。换句话说，当你加入太多待办事项，你只会完成最容易的几项。</p>
<p>（而）迅速完成容易的事项会让你有种虚假的成就感。你会发现忙碌了一整天以后，其实并没有在你的终极目标上取得多少进展。</p>
<p>必须养成专注的性格。选择最重要的几件事项，然后除掉其他（相对来说不重要的）。</p>
</blockquote>
<p> doit 我没能坚持下来就是因为错误的使用方式。每天罗列好多的内容，带来虚假的成就感；每天完成一些（大多是最容易的），看着任务打上对勾，被划掉，带来虚假的成就感。甚至为了“打对勾，划掉”写上已经完成的事项，写上不重要的、做不做并无关键区别、随手就能解决、非关键任务等等类似的内容。然后把上午、下午大块大块的完整时间用来处理这些个“自讨的”琐碎任务，以“划掉多少”等价“成就多少”。好脆弱的内心，好虚假的幻想！随着时间的积累（也就是半年），doit 列表中堆积了大量的待办事项，而且都是筛选之后需要花费一定时间、精力并且有意义的事情，积累的越多越是提醒着自己的失败。潜意识里回避真相，现实世界里就做出“不再使用这款工具”的决定。关键问题在于：</p>
<ul>
<li><p>罗列待办事项清单之后，安排事项处理顺序、处理日期不合理，对自身解决问题的能力没有清晰的认识，“拍脑袋”定日期；</p>
<ul>
<li>也就是：不抓重点，或者抓不住重点。精力有限，肯定要做取舍。</li>
</ul>
</li>
<li><p>（因此）计划制定完之后，并不能严格的执行，做不到日清月清，更谈不上总结；</p>
<p>这也是放弃 doit 使用 any.do 之后没多长时间，又放弃 any.do 而使用 Fabulous/纸笔的原因，如果纠正不了根本问题，依旧还会在工具之间跳来跳去，在一个工具上遗留大量的未完事务之后迁移到另一个工具，如此循环，一直得不到解脱。类似的应用层出不穷，上文提到的 3 个是非常棒的了，用好一个就能给生活带来质变，不要因为<strong>错误的习惯</strong>埋没、错过了。</p>
<p>收集任务是前提；<strong>安排任务是关键；</strong>完成任务是目的。不能把时间浪费在“前提”上，在<strong>对自身解决问题的能力有清晰的认识</strong>的基础上，以<strong>量力而行、轻重缓急</strong>为原则<strong>制定当日计划</strong>是重中之重。</p>
<p>制定计划，包含完成时间，还<strong>隐含完成的能力</strong>，而不单单是罗列待办事项，想到的就罗列出来，不管今天能不能完成，今天想到的就列到今天的待办事项里，没有这么无脑操作。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/13/build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/13/build/" class="post-title-link" itemprop="url">构建 build]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-13 19:27:22" itemprop="dateCreated datePublished" datetime="2016-08-13T19:27:22+08:00">2016-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 18:11:39" itemprop="dateModified" datetime="2019-11-18T18:11:39+08:00">2019-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整理为知笔记中和 make makefile automake 有关内容，成此篇。</p>
<h1 id="从-gcc-说起"><a href="#从-gcc-说起" class="headerlink" title="从 gcc 说起"></a>从 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/">gcc</a> 说起</h1><p>在介绍 make 之前，首先要保证你会使用 gcc/g++ 编译。了解 gcc 执行的四个阶段，知道预编译阶段、链接阶段需要什么，做什么操作；知道预编译时找不到头文件，链接时缺少库文件怎么处理；知道动态库、静态库的区别，怎么创建并使用它们。以上是必需的！只有掌握了上面的内容，才能保证面对一个简单的项目（可能包含头文件、源文件和链接库）知道怎么组织，最终得到可执行文件。</p>
<p>维基百科的描述：</p>
<blockquote>
<p>GNU编译器套装（英语：GNU Compiler Collection，缩写为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GCC">GCC</a>），一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p>
</blockquote>
<h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>预处理、编译、汇编和链接。学习 gcc，比较重要的是预处理和链接：</p>
<p>参考 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/youxin/p/3181214.html">gcc编译4个阶段</a></p>
<ol>
<li><p>预处理阶段</p>
<blockquote>
<p>预处理器（cpp）根据以字符#开头的命令（directives），修改原始的C程序。</p>
</blockquote>
<p> 也就是说预处理阶段，会查找并加载头文件生成一个新的C程序。</p>
</li>
<li><p>编译阶段</p>
<p> 编译阶段会将代码翻译成汇编语言。</p>
<blockquote>
<p>汇编语言是非常有用的，它为不同高级语言不同编译器提供了 通用的语言。如：C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
</blockquote>
</li>
<li><p>汇编阶段</p>
<p> 汇编阶段将汇编语言程序转换成为目标文件，也就是二进制机器码。</p>
</li>
<li><p>链接阶段</p>
<p> 该阶段将用到的一个或多个目标文件（库文件）链接生成可执行文件。</p>
<blockquote>
<p>在预编译阶段包含进来的“stdio.h”中只有“printf”函数的声明，而没有函数的实现，那么，是在哪里实现的“printf”函数呢？答案是：系统把这些函数实现都做到名为libc.so.6的库文件中去了，链接阶段gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf” 了，而这也就是链接的作用。</p>
</blockquote>
<p> 从上面可以看出，链接时需要目标文件的名称及其所在目录。</p>
</li>
</ol>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>知道了预处理器（cpp）要读取头文件，那么报错“xxx.h:No such file or directory”就需要确认我们是不是指定了查找目录，或者核对我们指定的路径是否包含该头文件；同样的道理，链接器（ld）需要链接目标文件，和前者稍有不用的地方在于：头文件一般都写在源代码中，我们只需要指定头文件路径；而链接目标文件时，既需要我们指出目标文件所在的目录，同时还需要我们指定使用目标路径下的哪个文件。</p>
<p>以上算是原理。知其所以然之后，我们来看工具具体的使用方法：</p>
<ol>
<li>头文件相关的： -I 后跟绝对路径或相对路径，例如 <code>-I ./include</code>。预处理器会优先在 @搜索路径</li>
<li>链接过程： -L 后跟绝对路径或相对路径，例如 <code> -L ./lib</code>， -l 后跟库名，例如 <code>-lmath</code>，对应库文件 libmath.a 或 libmath.so</li>
<li>-c：使用源文件生成对应的目标文件，而不进行链接，使用  ，例如 <code>g++ -c main.cpp -o main.o</code></li>
<li>-Wall：使 gcc 产生尽可能多的警告信息，并非全部。</li>
<li>-Werror：把警告当做错误处理，即产生 warning 时就停止编译操作。</li>
</ol>
<p>特殊的参数：</p>
<ol>
<li><p>-nostdinc：使编译器不在系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置。</p>
</li>
<li><p>-Wl,-rpath：在<strong>编译过程</strong>指定程序在<strong>运行时</strong>动态库的搜索路径，示例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔</span><br><span class="line">gcc -Wl,-rpath,libPath -L libPath -ltest hello.c</span><br></pre></td></tr></table></figure>
<p> 将搜索路径信息写入可执行文件(rpath代表runtime path)。这样就不需要设置环境变量。坏处是，如果库文件移动位置，我们需要重新编译test。</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>更多的参数，更详细的使用说明可以查看 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/6.1.0/">官方手册</a>，或者使用 man info –help 等方式获取。</p>
<h3 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h3><p>测试环境：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vimer@debian8light:~/code/test_search$ uname -a</span><br><span class="line">Linux debian8light 3.16.0-4-amd64 <span class="comment">#1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29) x86_64 GNU/Linux</span></span><br><span class="line">vimer@debian8light:~/code/test_search$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Debian</span><br><span class="line">Description:	Debian GNU/Linux 8.3 (jessie)</span><br><span class="line">Release:	8.3</span><br><span class="line">Codename:	jessie</span><br><span class="line">vimer@debian8light:~/code/test_search$ </span><br></pre></td></tr></table></figure>
<p>在 gcc version 4.9.2 (Debian 4.9.2-10) 环境下实际测试，linux 编译时头文件的搜索路径：</p>
<ol>
<li>搜索会从 -I 开始</li>
<li>再找 /usr/lib/gcc/x86_64-linux-gnu/4.9/include</li>
<li>再找 /usr/local/include/</li>
<li>查找 /usr/include/</li>
</ol>
<p>此测试只是确定以上 4 者相对的先后。测试时未包含更多的潜在的搜索路径，比如 gcc 的环境变量 C_INCLUDE_PATH、CPLUS_INCLUDE_PATH、OBJC_INCLUDE_PATH</p>
<p>两种不类型的头文件 <code>#include&lt;&gt;</code> 和 <code>#include&quot;&quot;</code> 搜索规则：</p>
<ol>
<li>使用&lt;&gt;包含的头文件一般会先搜索-I选项后的路径（即用gcc编译时的-I选项，注意是大写），之后就是标准的系统头文件路径。</li>
<li>而用””号包含的头文件会首先搜索当前的工作目录，之后的搜索路径才是和&lt;&gt;号包含的头文件所搜索的路径一样的路径。</li>
</ol>
<p><strong>事实上，知道上述提及的搜索路径即可。不必学究式地死记硬背之间的搜索顺序，能有多少意义呢？。</strong></p>
<p>更直接、简单的方式，确认查找头文件时的路径搜索顺序。参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/maximuszhou/article/details/38559963">使用gcc时头文件路径和动态链接库路径</a>， 通过使用 -v 参数看到：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;...&quot; search starts here:</span></span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> ./include</span><br><span class="line"> /usr/include/c++/4.9</span><br><span class="line"> /usr/include/x86_64-linux-gnu/c++/4.9</span><br><span class="line"> /usr/include/c++/4.9/backward</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include</span><br><span class="line"> /usr/<span class="built_in">local</span>/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.9/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>
<p>在此不再具体测试编译过程中链接库文件时的搜索顺序、运行时动态库的搜索顺序，真正需要用之间的搜索顺序时再写代码测试。</p>
<h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><p>在“链接阶段”一节中出现了库文件“libc.so.6”。@Linxu 中动态库</p>
<p>@引出静态库</p>
<p>@动态链接和静态链接</p>
<h1 id="make-和-Makefile"><a href="#make-和-Makefile" class="headerlink" title="make 和 Makefile"></a><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">make</a> 和 Makefile</h1><p>make 命令用来解释、执行 Makefile文件。针对开发 C++ 程序来说：Makefile 文件是对项目文件（以源文件、链接库为主，也包括头文件）依赖关系的描述，是对 gcc 命令的有效组织。抛开依赖关系，如果项目不复杂，你也可以用 shell 脚本来组织 gcc 命令，前提是根据依赖关系调整好编译命令的排序。虽然能够得到同样的结果，但是执行的效率不如前者，容错的能力不如前者，耗费的精力更是项目越大越难以承受。事实上：</p>
<blockquote>
<p>在make诞生之前，编译工作主要依赖于操作系统里面的类似于“make”、“install”功能的shell脚本。</p>
</blockquote>
<p>来看看维基百科中的描述：</p>
<blockquote>
<p>在软件开发中，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Make">make</a> 是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。</p>
<p>它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。</p>
<p>它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。</p>
</blockquote>
<p>需要注意的是我们在 Linux 上用的一般是 make 的重写/改写版本 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">GNU Make</a>，除此之外还有 BSD Make 等。</p>
<p>我们来看怎么写 Makefile 文件。</p>
<h1 id="automake"><a href="#automake" class="headerlink" title="automake"></a><a target="_blank" rel="noopener" href="https://www.gnu.org/software/automake/">automake</a></h1><p>人工写 Makefile 文件已经满足不了我们了。事实是人越来越懒，项目也越来越大，我们希望电脑帮我们做更多的工作。引用 Wikipedia 中的描述：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Automake">GNU Automake</a> 是一种编程工具，可以产生供 make 程式使用的 Makefile，用来编译程式。它是自由软件基金会发起的 GNU 计划的其中一项，作为 GNU 构建系统的一部分。automake 所产生的Makefile 符合 GNU 编程标准。</p>
<p>automake 是由 Perl 语言所写的，必须和 GNU autoconf 一并使用。</p>
</blockquote>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>以下概念当做扩展知识保留下来，如果有兴趣可以展开学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Portable_Executable">PE 文件</a> 和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F">ELF 文件</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/08/13/headfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/13/headfile/" class="post-title-link" itemprop="url">怎么写头文件：内部链接、外部链接</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-13 19:16:39" itemprop="dateCreated datePublished" datetime="2016-08-13T19:16:39+08:00">2016-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 18:32:28" itemprop="dateModified" datetime="2019-11-18T18:32:28+08:00">2019-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由内部链接、外部链接引出怎么写头文件。</p>
<p>我看了一下，这篇笔记最早是在六月二号创建的，可是现在 2016/8/13 16:12:05 ，呵呵。一方面是自己懒，另一方面，对于“内部链接、外部链接”的概念，不多了解一些，不敢随便整理啊。</p>
<p>我们先看看 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E6%96%87%E4%BB%B6">维基百科- 头文件</a> 中说了什么：</p>
<blockquote>
<p>当一个子程序在定义的位置以外的地方被使用时，就需要进行<strong>前置声明</strong>，声明函数原型等。</p>
</blockquote>
<p>假设一个程序员不用“头文件”，那么他至少需要在两个地方维护函数的声明：一个是包含函数实现的的文件，以及使用该函数的文件。如果使用该函数的文件有很多个，那么对函数的定义进行更改时就是灾难。</p>
<p>从某个方面来说，头文件降低了这种场景中程序员手工操作的复杂度（解放双手，繁琐的工作交给机器/编译器）。更重要的是保证了编写大型项目的易用性，难以想象如果没有头文件，几十万行的代码全都在一个源文件中。</p>
<p>将函数原型移到 XXX 头文件中之后，我们可以在需要的地方通过 <code>#include &lt;XXX&gt;</code> <em>预处理器指令</em> 将其包含进来，这样每次编译时预处理阶段就会将 XXX 文件中的内容替换掉 <code>#include &lt;XXX&gt;</code> ，我们的函数原型也就被“前置声明”了。</p>
<p>阅读 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Include_directive">wikipedia - include derective</a>，我们可以从更高的层次考虑 Include 行为，想想 Makefile 中的 include，shell 脚本中的 include，表示类似甚至同样意义的关键字还有 import、copy。</p>
<p>在 C 语言中，什么内容需要放在头文件中，什么内容可以放在头文件中相对来说是比较容易区分的。接下来我们看看在 C++ 中，什么东西可以放在 .h 文件中，什么不能，什么东西又可以放在 .cpp 文件中。</p>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>首先需要区分开这两个概念，只是理解所有关键问题的前提。在笔记中暂时不展开说了，如果分不清楚，自行 Google。这里只备注几个容易混淆的条目：</p>
<ul>
<li><p>声明</p>
<ol>
<li><p>仅仅提供函数原型。类外面的，类里面的</p>
</li>
<li><p>class A；</p>
</li>
<li><p>typedef声明</p>
</li>
<li><p>在类中定义的静态数据成员的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义</p>
<ol>
<li><p>在类定义之外，定义并初始化一个静态数据成员。如 A::a=0;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A::a=<span class="number">0</span>；  <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li>
<li><p>在类外定义非内联成员函数</p>
</li>
</ol>
</li>
</ul>
<h1 id="内部链接和外部链接"><a href="#内部链接和外部链接" class="headerlink" title="内部链接和外部链接"></a>内部链接和外部链接</h1><p>参考自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/ithzhang/article/details/8119286">参考链接1</a>、<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">解析C++中的内部连接与外部连接</a></p>
<p>链接把不同编译单元产生的符号联系起来。有两种链接方式：内部链接和外部链接。</p>
<h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><p>如果一个符号名对于它的编译单元来说是局部的，并且在链接时不可能与其他编译单元中的同样的名称相冲突，那个这个符号就是内部链接。内部链接意味着对此符号的访问仅限于当前的编译单元中，对其他编译单元都是不可见的。</p>
<p>具有内部链接的符号无法作用于当前文件外部，要让其影响程序的其他部分，可以将其放在.h文件中。此时在所有包含此.h文件的源文件都有自己的定义且互不影响。</p>
<ol start="0">
<li><p>所有的声明，包括类的声明，比如：<code>class A;</code>；(有时也将声明看作是无连接的，这里我们统一看成是内部连接的)。</p>
<p> 由于声明只对当前编译单元有用，因此声明并不将任何东西写入.o文件。</p>
<p> 这些声明<strong>本身</strong>不会影响到.o文件的内容。在编译阶段（狭义的，从高级语言到汇编语言到二进制，从 main.i 到 main.o，预处理已过，尚未链接），编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会报错。链接阶段，声明已经没有用了。</p>
<p> 而函数调用会导致一个未定义的符号被写入到.o文件，此后此.o文件与定义此符号的.o文件被连接在一起，前面未定义的符号被解析。</p>
</li>
<li><p>局部变量肯定是内部链接性质的，更应该被看作无连接的；</p>
</li>
<li><p>全局变量，如果使用了 static、const 关键词修饰，其作用域仅仅在当前文件作用域内，其他文件中即使使用extern声明也是无法使用的。因此，带有 static、const 关键字的全局变量也是内部链接性质的；</p>
<p> static 和 const 还是有区别的。static 和 extern不能对同一个变量同时声明；但 const 和 extern 不是同一存储类别，可以同时用在同一个变量的声明。所以，我们可以用使用extern关键字修改const的连接属性。<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wangpei0522/p/4459624.html">更多详情</a>、<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiexievv/article/details/8491494">特别说明</a></p>
</li>
<li><p>枚举 enum、联合 union 类型是内部链接性质的；</p>
</li>
<li><p><strong>类的定义</strong>是内部链接性质的：</p>
<ul>
<li><p>定义，意味着在同一编译单元中不能重复出现；</p>
</li>
<li><p>内部链接性质，意味着如果需要在其他编译单元使用，类必须被定义在头文件且被其他文件包含。</p>
<p>  仅仅在其他文件中使用class a;声明是不行的，原因就是类的定义是内部链接，不会在目标文件导出符号。也就不会被其他单元解析它们的未定义符号。</p>
</li>
</ul>
</li>
<li><p>内联函数定义（包括自由函数和非自由函数）。</p>
<p> 内联函数之所有具有内部链接，因为编译器在可能的时候，会将所有 对函数的调用替换为函数体，不将任何符号写入.o文件。</p>
</li>
<li><p>名字空间(包括全局名字空间)中的静态自由函数、静态友元函数、静态变量的定义。<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
</li>
</ol>
<h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p>在一个多文件的程序中，如果一个符号在链接时可以和其他编译单元交互，那么这个名称就有外部链接。外部链接意味着该定义不仅仅局限在单个编译单元中。它可以在.o文件中产生外部符号。可以被其他编译单元访问用来解析它们未定义的符号。因此它们在整个程序中必须是唯一的，否则将会导致重复定义。</p>
<p><strong>区分：</strong>判断一个符号是内部链接还是外部链接的一个很好的方法就是看该符号是否被写入.o文件。</p>
<ol>
<li><p>类非内联成员函数，包括类成员函数和类静态成员函数</p>
</li>
<li><p>类的静态数据成员的定义具有外部链接性质</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">// 内部链接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::a = <span class="number">0</span>;  <span class="comment">// 外部链接</span></span><br></pre></td></tr></table></figure></li>
<li><p>非内联函数</p>
</li>
<li><p>名字空间(包括全局名字空间)中非静态自由函数、非静态友元函数及非静态变量。<a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201107/277364.htm">补充条目来源</a></p>
<p> 前提是认为，类之外一般不存在使用 inline 修饰的函数。</p>
</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a target="_blank" rel="noopener" href="http://www.52rd.com/Blog/Detail_RD.Blog_imjacob_5682.html">摘抄来源</a></p>
<p>Linkage</p>
<p>To understand the behavior of C and C++ programs, you need to know about linkage. In an executing program, an identifier is represented by storage in memory that holds a variable or a compiled function body. Linkage describes this storage as it is seen by the linker. There are two types of linkage: internal linkage and external linkage.</p>
<p>Internal linkage means that storage is created to represent the identifier only for the file being compiled. Other files may use the same identifier name with internal linkage, or for a global variable, and no conflicts will be found by the linker – separate storage is created for each identifier. Internal linkage is specified by the keyword static in C and C++.</p>
<p>External linkage means that a single piece of storage is created to represent the identifier for all files being compiled. The storage is created once, and the linker must resolve all other references to that storage. Global variables and function names have external linkage. These are accessed from other files by declaring them with the keyword extern. Variables defined outside all functions (with the exception of const in C++) and function definitions default to external linkage. You can specifically force them to have internal linkage using the static keyword. You can explicitly state that an identifier has external linkage by defining it with the extern keyword. Defining a variable or function with extern is not necessary in C, but it is sometimes necessary for const in C++.</p>
<p>Automatic (local) variables exist only temporarily, on the stack, while a function is being called. The linker doesn’t know about automatic variables, and so these have no linkage.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>综上，我们可以知道：将具有外部链接的定义放在头文件中几乎都是编程错误。因为如果该头文件中被多个源文件包含，那么就会存在多个定义，链接时就会出错。</p>
<p>在头文件中放置内部链接的定义却是合法的，但不推荐使用的。</p>
<p>链接，本质上都是具有<strong>外部链接性质的符号们</strong>的事情！</p>
<h2 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h2><p>头文件为相关声明提供了一个集中存放的位置。头文件一般包含类的定义、枚举的定义、extern变量的声明、函数的声明、const int的定义、inline函数的定义。使用或者定义这些实体的文件要包含适当的头文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/07/30/learnSche_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/learnSche_cpp/" class="post-title-link" itemprop="url">学习 C++</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 11:00:15" itemprop="dateCreated datePublished" datetime="2016-07-30T11:00:15+08:00">2016-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2016-12-09 15:31:12" itemprop="dateModified" datetime="2016-12-09T15:31:12+08:00">2016-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>跌跌撞撞，兜来绕去，终究还是在 C++ 这个圈子里。毕业时，因为身外事去选择工作单位，而工作单位决定了工作性质，决定了自己处在做软件的边缘，甚至一度成为网管。两年之后跳出陷阱时，背负着“过去的选择”走进了 C++ 的世界，因为一无所长，在诸多技术更迭交替的 IT 圈我像个刚入门的新人似的，只了解一点点 VC++。我没有从头来过的魄力，我也并不清楚 Java 是否更有前途，互联网是否更多辛苦。</p>
<p>在毕业刚好三年的边上，想着“就是 C++ 了”其实很愚蠢。通过做决定安慰自己“明智”，其实只是没得选择的妥协。此时此刻应该想的是“如何学好 C++”，更现实一点“掌握 C++ 的哪些内容，能找到更好的工作”。暂时确定的目标：</p>
<ol>
<li>会写代码。强调编码规范。</li>
<li>会编写类，使用类。强调抽象思维。</li>
<li>数据库操作，封装</li>
<li>并发（多线程），POSIX、boost、C++11原生支持</li>
<li>通信，socket 编程</li>
</ol>
<p>曾经完美主义，现在坚持实用主义。站在公司的角度考虑，现实中生产使用，强调实用性。如果新特性带不来生产力上的提升，是不会有公司买账的。就是说是否掌握 C++11 甚至更新的特性，对找工作没有最直接的影响，如果带不了更高的生产力，都是空谈。不应该只为了关注新特性，学究式地死板地投入时间精力，要明白花时间做一件事的初衷、目的、意义和价值。举例来说，做并发时是否使用 C++11 的原生支持，在投产使用时没有什么影响的，重要的是能否解决问题，解决问题的能力，关键是把并发做出来，用什么技术往往并不重要。</p>
<p>那就好好学 C++11。工欲善其事，必先利其器。有兴趣可以看看<a target="_blank" rel="noopener" href="http://www.csdn.net/article/2012-08-13/2808540">各编译器对 C++11 的支持情况</a>、<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a>，但选择 g++ 总是省心的，前提是版本足够新，有条件就用最新的。编译器有了，<strong>编辑</strong>代码呢？主要关注代码提示，开发者体验。</p>
<ul>
<li>在 Windows 上考虑使用 VS2015，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23776769">轮子哥的观点 - 知乎</a>。个人观点，除了太大并不排斥 VS。</li>
<li>Linux 上呢？很难找到完善支持 C++11 代码提示的 IDE…<a target="_blank" rel="noopener" href="http://zuyunfei.com/2013/05/16/killer-plugin-of-vim-youcompleteme/">Vim代码补全</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22096642">Vim 和 IDE 之争 - 知乎</a>，个人观点，两者会越来越像，追求生产力。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/07/30/learnSche_cpp/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/07/15/Flume%20&%20Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/15/Flume%20&%20Redis/" class="post-title-link" itemprop="url">Flume & Redis 学习笔记V0.1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-15 11:18:07" itemprop="dateCreated datePublished" datetime="2016-07-15T11:18:07+08:00">2016-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 13:23:20" itemprop="dateModified" datetime="2019-11-19T13:23:20+08:00">2019-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flume-学习笔记"><a href="#Flume-学习笔记" class="headerlink" title="Flume 学习笔记"></a>Flume 学习笔记</h1><p><a target="_blank" rel="noopener" href="http://shiyanjun.cn/archives/915.html">Flume(NG)架构设计要点及配置实践</a>，在此基础上的扩展：<a target="_blank" rel="noopener" href="http://blog.javachen.com/2014/07/22/flume-ng.html">Flume-ng的原理和使用</a></p>
<ol>
<li>Agent 的串联、并联</li>
<li>Source 一般都是单一 Source；Source 一对多 Channel，分为复制（replication）和分流（multiplexing）</li>
<li>Channel 一对多 Sink，实现负载均衡（load balance）和故障转移（failover）</li>
</ol>
<p>在上述中多提到 Avro，在 Flume 的配置文件中也用到此项。<a target="_blank" rel="noopener" href="http://blog.javachen.com/2015/03/20/about-avro.html">Avro 介绍</a>，但目前不需要了解。</p>
<blockquote>
<p>Avro 是 Hadoop 中的一个子项目，也是 Apache 中一个独立的项目，Avro 是一个基于二进制数据传输高性能的中间件。</p>
</blockquote>
<h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><p><a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart">Redis Quick Start</a></p>
<ol>
<li>在安装过程中，如果缺少依赖项，需要先编译 deps 目录。</li>
<li>将 redis 加入系统启动项，手册中使用 <code>sudo update-rc.d redis_6379 defaults</code>。但此命令只在 Debian 系下使用。</li>
</ol>
<h1 id="70-13x-系列服务器搭建指南"><a href="#70-13x-系列服务器搭建指南" class="headerlink" title="70.13x 系列服务器搭建指南"></a>70.13x 系列服务器搭建指南</h1><ol start="0">
<li><p>先安装 jdk，配置好 JAVA_HOME 环境变量</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/cts/tool/jdk1.6.0_45/</span><br><span class="line"><span class="built_in">export</span> JAVA_BIN=<span class="variable">$JAVA_HOME</span>/bin/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jreb:<span class="variable">$JAVA_HOMEb</span>/tools.jar</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart#installing-redis">安装 redis</a>，<a target="_blank" rel="noopener" href="http://redis.io/topics/quickstart#installing-redis-more-properly">启动 redis</a></p>
<ul>
<li>如果需要，可以配置主从 redis</li>
</ul>
</li>
<li><p>使用 cts2Cache-v0.2 程序初始化 redis</p>
<ul>
<li>执行 run-Init.sh 脚本执行初始化，需要修改 cts2Cache-0.1.0.jar 中配置文件 redis IP；</li>
<li>使用 crontab 命令设置定时任务，每日执行 run-update-recv.sh 和 run-update-send.sh 脚本生成次日的节目表；</li>
</ul>
</li>
<li><p>使用 cts2LogGate 程序开启日志网关</p>
<ul>
<li>参考 visio 图</li>
<li>依照 send、recv、mu、lb 顺序开启，使用 kill 命令逆序关闭</li>
<li>开启时可以使用 nohup 命令</li>
<li>怎么关闭呢？</li>
</ul>
</li>
<li><p>向日志网关发送日志</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/06/13/writeing2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/13/writeing2/" class="post-title-link" itemprop="url">使用Markdown 注意事项</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-13 13:15:05" itemprop="dateCreated datePublished" datetime="2016-06-13T13:15:05+08:00">2016-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 17:57:38" itemprop="dateModified" datetime="2019-11-18T17:57:38+08:00">2019-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在使用JotterPad（CommonMark）阅读markdown格式的文本时，发现的细节：</p>
<ol>
<li><p>标题# 后需要有空格，才能解析成标题，不然就是文本；【重要】</p>
<ul>
<li>进一步修正：任意级别的标题行前后添加空行，至少标题行之前要有空行，# 之后添加空格；</li>
</ul>
</li>
<li><p>使用参考式链接时，链接网址只能放在文件最末尾，不然识别不出来；【重要】</p>
</li>
<li><p>引用内使用编号问题：</p>
<blockquote>
<p>引用文字</p>
<ol>
<li>item1</li>
<li>item</li>
</ol>
<p>编号结束，结尾的引用文字</p>
</blockquote>
</li>
<li><p>怎么写代码块？——是解析的，只不过呈现方式只体现在字体上，排版效果并不明显。</p>
</li>
<li><p><del>尽量不要嵌套使用。在 GitHub 上项目的 README.md 都不复杂。占一屏幕，不需要滚屏。</del> 建议很值得采纳，但实在是不实用。</p>
</li>
<li><p>可以做图片链接的哦，惊喜</p>
</li>
<li><p><del>嵌套时无需有空行（分段需求除外，比如引用时），当两个模块是平行关系时需要有空行（列表除外，列表项之间添加空行会引入 &lt;p&gt;）。参考 1.1 节</del></p>
</li>
<li><p>中英文混合排版加不加空格问题，持保留态度，无论加或者不加，都保持原状。</p>
<ol>
<li><p>强调语义，不加；强调呈现，添加。</p>
</li>
<li><p>书写笔记不考虑纯手工补充空格，为了表现效果美观<strong>吹毛求疵</strong>，时间成本太高，没有意义。【重要】</p>
<p>扩展阅读：</p>
</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.geekpark.net/topics/198213">不仅仅是空格的问题——再谈中西文混排</a></li>
</ul>
</li>
<li><p>测试 item</p>
</li>
</ol>
<h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><p>模块之间的嵌套使用，怎么书写是规范的一直是一件比较困惑的事情。但在我写下这篇文字的时候，我已经感觉到胜利在朝我招手了。</p>
<p>首先一定要有意识区分“块元素（Block Element）”和“Span Element”，对于熟悉 html 的程序员来说可能是很 easy 的一件事情，但是虽然我用 Markdown 两三个月，相关的操作手册、语法说明也看了很多，但我是自动过滤这两个单词的，讲解标题（用不同数目的 # 区分标题级别）和强调（用 * 斜体，** 加粗）时肯定是分别放在 Block Element 和 Span Element 中介绍，但我脑子里是没有这两个概念的，我并未意识到它们意味着什么，甚至并未意识到它们的存在。我真的是个前端白痴，原谅我。</p>
<ol>
<li><p>块元素（Block Element）包括：</p>
<ul>
<li>标题</li>
<li>引用</li>
<li>列表，注意是整个列表，而不是列表的 item</li>
<li>代码块</li>
<li>分割线</li>
</ul>
</li>
<li><p>Span Element 包括：</p>
<ul>
<li>链接</li>
<li>强调</li>
<li>代码</li>
<li>图片</li>
</ul>
</li>
</ol>
<p>块元素是涉及嵌套的主体！Span Element 不是。所以嵌套问题是块元素的嵌套问题，额，如果我了解 html 多好。</p>
<h2 id="结论（针对-GFM）"><a href="#结论（针对-GFM）" class="headerlink" title="结论（针对 GFM）"></a>结论（针对 GFM）</h2><p><strong>秘籍：</strong>（在严格坚持第一点的基础上，除却以下情况不会用到第二点：如果问题出现在章节末尾（见本文末尾）、列表末尾，使用第二点）</p>
<ol>
<li><p>每个独立的块元素（包括分段）之后留有空行，标题、分割线可以除外；</p>
</li>
<li><p>哪个块元素解析有问题，就在哪个块元素之前加空行；</p>
<ol>
<li>为了保证一致性（特殊情形，即当前嵌套情形（列表主体除末尾空行无其他空行，且在末尾嵌套有子列表）），要求嵌套子列表时，子模块前添加空行（即本行之前的空行，否则解释时不完美）；</li>
</ol>
</li>
<li><p>综合上述两点，在每个块元素（包括分段）的前后添加空行可以保证所有情形下解释正确。唯一的不足在于阅读源文本时可能稍显松散。</p>
</li>
<li><p>其实，在每个块元素（包括分段、标题、分割线）之前留有空行是不是就万事大吉了呢？【重要】</p>
</li>
</ol>
<p><strong>详细描述：</strong></p>
<ol>
<li><p>分段用空行，这句是废话；</p>
</li>
<li><p>标题之前加空行，保证所有情况下语法正常解释；【重要】</p>
<ul>
<li>如果前置标题、分割线或者普通段落，则没有空行语法也能正常解释；</li>
<li>如果前置列表、引用等，没有空行，语法解释后呈现有问题；</li>
</ul>
</li>
<li><p>空行意味着引用、列表的结束；标题、分割线是单行的；GFM 中代码块是 ``` 结束的。多个空行合并成一个。</p>
<ul>
<li>分段时，空行意味着段落的结束；</li>
<li>非分段情况下，段落之后不用跟空行。接标题、引用、<del>列表、</del>代码块都意味着段落结束。</li>
<li>非分段情况下，段落之后无空行直接跟有序列表，是有问题的；直接跟无序列表没问题；</li>
<li>综合上述三条，建议每个独立的块元素之后留有空行，标题、分割线除外【重要】</li>
</ul>
</li>
<li><p>列表内容拥有缩进概念；</p>
<ul>
<li>列表 item 中缩进内容（针对引用、代码块）前（或者后）加空行；否则语法无法正常解释</li>
<li>缩进内容为列表（即嵌套子列表）时，按照规则建议添加空行。即使无空行，语法也能正常解释，看着还顺眼一点</li>
<li>综合上述两条，建议在嵌套子模块的结尾留有空行【重要】</li>
</ul>
</li>
</ol>
<p>补充说明：</p>
<ol>
<li><p>列表的 item 之间一般不需要空行（分段除外），如果</p>
<blockquote>
<p>如果列表项之间有空行，markdown会给每一个生成的li元素创建一个p:</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/05/31/regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/31/regex/" class="post-title-link" itemprop="url">正则表达式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-31 16:54:05" itemprop="dateCreated datePublished" datetime="2016-05-31T16:54:05+08:00">2016-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 18:04:38" itemprop="dateModified" datetime="2019-11-18T18:04:38+08:00">2019-11-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这两天工作上用到了 grep、sed、awk 文本处理命令。有心在业余时间花心思多掌握一些，在此前提下，发现熟悉正则表达式是很重要的。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>查阅维基百科，发现其中文词条 <a href="">正则表达式</a> 没有价值，个别的知识点即便有效也充斥在大量的垃圾信息里，此词条好似百度百科的众多词条，灌水横拉硬拽拼凑而成，或源于翻译英文词条时偷懒挑肥拣瘦，只翻译了一部分内容，却篡改章节目录造成“不成文”的感受。</p>
<p>其英文词条 [Regular expression][] 相对“丰满”一些，看目录至少提到了不同标准、不同流派，比中文词条要好。</p>
<p>参考 <a target="_blank" rel="noopener" href="http://liujiacai.net/blog/2014/12/07/regexp-favors/">正则表达式“派别”简述</a>、<a target="_blank" rel="noopener" href="http://blog.csdn.net/dreamerway/article/details/20700421">正则表达式 流派（flavor）及差异简介</a>，都明确指出了三种：</p>
<ul>
<li>BRE: Basic Regular Expression</li>
<li>ERE: Extended Regular Express</li>
<li>PCRE: Perl Compatible Regular Expression</li>
</ul>
<p>其中，前两者都是 POSIX: Portable Operating System Interface 的规范。</p>
<p>常见的编程语言中使用正则表达式的记法，其实都源于 Perl。</p>
<pre><code>&gt; 现在的编程语言中的正则表达式，大部分都属于 PCRE 这个分支。

&gt; 常见的正则表达式记法，其实都源于 Perl</code></pre>
<p>但在 POSIX 的系统上，有关的工具使用正则表达式，其记法与上述不同，大都要落于 BRE、ERE 这两者之中：</p>
<pre><code>&gt; － 使用BRE语法的命令有：grep、ed、sed、vim
&gt; 
&gt; － 使用ERE语法的命令有：egrep、awk、emacs</code></pre>
<p>需要补充的一点是，在 linux 上其有关工具对 BRE、ERE 语法是进行过扩充的，好比对 C 语言标准、C++ 语言标准进行的诸多 GNU 扩展。在 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux/Unix工具与正则表达式的POSIX规范</a> 中有提到 GNU 扩展的相关内容，在 <a target="_blank" rel="noopener" href="http://liujiacai.net/blog/2014/12/07/regexp-favors/">正则表达式“派别”简述</a> 讲述 POSIX 标准时也提到了 GNU 扩展。</p>
<pre><code>&gt; GNU 在实现了 POXIS 标准的同时，做了一定的扩展</code></pre>
<h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expression)：<del>可以说是正则表达式的老前辈</del>（niel 注：需考证），它是从Perl衍生出来的一个显赫流派，<code>\d</code> <code>\w</code> <code>\s</code> 等表示法就是它的特征；</p>
<h2 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h2><p>BRE(Basic Regular Expression)：POSIX 规范的正则表达式之一，grep、vi、sed 都属于这一派，它显著的特征就是 <code>(</code> <code>)</code> <code>&#123;</code> <code>&#125;</code> 这几个括号元字符必须经过转义才具有特殊含义，不支持 <code>+</code> <code>?</code> <code>|</code> 等元字符，随着时间发展，后来又出现了 GNU BRE，GNU BRE 支持上边这些字符，但是也必须都经过转义才能有特殊含义；</p>
<h2 id="ERE"><a href="#ERE" class="headerlink" title="ERE"></a>ERE</h2><p>ERE(Extended Regular Express)：也是 POSIX 规范的正则表达式之一，egrep awk 都属于这一派，<code>(</code> <code>)</code> <code>&#123;</code> <code>&#125;</code> <code>+</code> <code>?</code> <code>|</code> 等元字符可以直接使用不需要转义，这个流派后来也出现了 GNU ERE，在之前的基础上添加了支持 <code>\1</code> <code>\2</code> 等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>不明觉厉的 <a target="_blank" rel="noopener" href="http://www.greenend.org.uk/rjk/tech/regexp.html">各种语言或工具软件的不同风格的正则表达式文法规定</a>。</p>
<p>如果更关注使用有关工具时的细节，可以参考 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/finallyliuyu/archive/2013/05/27/3101220.html">Linux 中常用文本工具与正则表达式的关系 </a>。更多的语法细节还是要在用到的时候仔细查阅。</p>
<p>引擎 <a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/86751/">正则表达式引擎及其分类</a></p>
<h1 id="55分钟学会正则表达式学习笔记"><a href="#55分钟学会正则表达式学习笔记" class="headerlink" title="55分钟学会正则表达式学习笔记"></a><a target="_blank" rel="noopener" href="http://blog.jobbole.com/63398/">55分钟学会正则表达式</a>学习笔记</h1><p>建议看<a target="_blank" rel="noopener" href="http://qntm.org/files/re/re.html">原文（英文）</a>比较好，译者也给出了原文的链接。翻译时译者不够细心，和原文相比有好几处错误，有的是很明显的上下文冲突，所以觉得译者根本就不用心。</p>
<p>前言部分，简单描述正则表达式是什么；之后讲解正则表达式的基础语法。</p>
<ul>
<li>正则表达式有可能出现语法错误——不是所有的字符串都是正则表达式<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2>理解“元字符”概念。</li>
</ul>
<p>普通字符只能匹配它们本身；元字符可以匹配一些特殊规则。使用反斜杠“\”可以忽略元字符，使得元字符的功能与普通字符一样。</p>
<h2 id="点“-”"><a href="#点“-”" class="headerlink" title="点“.”"></a>点“.”</h2><p>匹配任意一个字符</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>字符类是一组在方括号内的字符，表示可以匹配其中的任何一个字符。</p>
<blockquote>
<p>重要提示：字符类中和字符类外的规则有时不同，一些字符在字符类中是元字符，在字符类外是普通字符。一些字符正好相反。还有一些字符在字符类中和字符类外都是元字符，这要视情况而定！</p>
</blockquote>
<h3 id="字符类的范围"><a href="#字符类的范围" class="headerlink" title="字符类的范围"></a>字符类的范围</h3><p>在字符类中，你可以通过使用短横线来表示匹配字母或数字的范围。</p>
<h3 id="字符类的反义"><a href="#字符类的反义" class="headerlink" title="字符类的反义"></a>字符类的反义</h3><p>你可以在字符类的起始位放一个反义符^。</p>
<h3 id="Freebie-character-classes"><a href="#Freebie-character-classes" class="headerlink" title="Freebie character classes"></a>Freebie character classes</h3><blockquote>
<p>译者翻译为“转义字符类”，个人觉得不能够表达原作的味道。参考上下文及“freebie”单词原意，应该是要表达，和某些字符类表示相同意义的转义字符。</p>
<p>下文中Freebie multipliers 译为“关于重复的转义字符”。类比，此处译为“关于字符类的转义字符”就会好很多。</p>
</blockquote>
<ul>
<li>\d：[0-9]</li>
<li>\w：[0-9A-Za-z_]</li>
<li>\s：匹配一个空字符（空格，制表符，回车或者换行）</li>
<li>\D：[^0-9]</li>
<li>\W：[^0-9A-Za-z]</li>
<li>\S：匹配一个非空字符<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2>在字符或字符集之后，你可以使用{ }大括号来表示重复<h3 id="指定重复次数范围"><a href="#指定重复次数范围" class="headerlink" title="指定重复次数范围"></a>指定重复次数范围</h3><h3 id="Freebie-multipliers"><a href="#Freebie-multipliers" class="headerlink" title="Freebie multipliers"></a>Freebie multipliers</h3></li>
<li>?：{0，1}，重复0次或1次</li>
<li>*：{0，}，重复任意次（0次、1次或多次）</li>
<li>+：{1，}，重复1次以上（包括1次）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2016/05/31/pointer&reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/31/pointer&reference/" class="post-title-link" itemprop="url">复合类型（指针、引用）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-31 14:47:28" itemprop="dateCreated datePublished" datetime="2016-05-31T14:47:28+08:00">2016-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 13:23:20" itemprop="dateModified" datetime="2019-11-19T13:23:20+08:00">2019-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当一条声明语句中包含多个指针，或者混用数组的时候，每每傻傻分不清。</p>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><p>在《C++ Primer》P38页，2.2节中描述到</p>
<blockquote>
<p>变量定义的基本形式是：首先是<strong>类型说明符</strong>（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p>
<p>列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值：<code>int a=0, b, c=3;</code></p>
</blockquote>
<p>ps：稍后再对变量的定义和声明做区分，对于初始化和赋值做区分。</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>P45页，2.3节描述如下</p>
<blockquote>
<p>一个简单的声明语句由……。更通用的描述是，一条声明语句由一个<strong>基本数据类型</strong>（base-type）和紧随其后的一个<strong>声明符</strong>（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
</blockquote>
<p>P51页</p>
<blockquote>
<p>在同一条定义语句中个，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量。</p>
<pre><code>// i是一个int型的数，p是一个int型指针，r是一个int型引用。
int i = 1024, *p = &amp;i, &amp;r =i;</code></pre>
</blockquote>
<p>P53页</p>
<blockquote>
<p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</p>
</blockquote>
<pre><code>int *p, *&amp;r = p;  // r是一个对指针p的引用</code></pre>
<h2 id="数组是一种复合类型-（P101页）"><a href="#数组是一种复合类型-（P101页）" class="headerlink" title="数组是一种复合类型 （P101页）"></a>数组是一种复合类型 （P101页）</h2><p>数组中元素的个数也属于数组类型的一部分。</p>
<p>P102页</p>
<blockquote>
<p>默认情况下，类型修饰符从右向左依次绑定。理解复杂的数组声明，由内向外，从右向左。</p>
</blockquote>
<pre><code>int *ptrs[10];  // ptrs是含有10个元素的数组，数组元素是int型指针
int *(&amp;array)[10] = ptr;  // array是数组的引用，该数组含有10个指针
//
int (*Parray)[10];  // Parray是一个指针，指向一个含有10个整数的数组</code></pre>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>reference to const，对常量的引用；不存在const reference，以为引用不是对象。</p>
<blockquote>
<pre><code>const int ci = 1.24;
const int &amp;r1 = ci;</code></pre>
</blockquote>
<p>pointer to const，指向常量的指针；const pointer，指针本身是常量。</p>
<blockquote>
<p>把<code>*</code>放在<code>const</code>关键字之前用以说明指针是一个常量。</p>
</blockquote>
<pre><code>const double pi = 3.1415;
const double *const pip = &amp;pi;</code></pre>
<blockquote>
<p>要想弄清楚这些生命的含义最行之有效的方法是从右向左阅读。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tnie & ilyw"
      src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
  <p class="site-author-name" itemprop="name">tnie & ilyw</p>
  <div class="site-description" itemprop="description">家人是奋斗的初衷，路途艰辛时常思初心。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tnie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tnie" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/nie7g" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;nie7g" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tnie & ilyw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>














  

  

</body>
</html>
