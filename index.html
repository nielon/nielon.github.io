<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="不积小流，无以成江海" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'AWLTH1YPN5',
      apiKey: 'd9101fc28af07d0ea8ade8654c1dc48b',
      indexName: 'test_niel',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:type" content="website">
<meta property="og:title" content="不积小流，无以成江海">
<meta property="og:url" content="https://tnie.github.io/index.html">
<meta property="og:site_name" content="不积小流，无以成江海">
<meta property="og:description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tnie &amp; ilyw">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tnie.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>不积小流，无以成江海</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不积小流，无以成江海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">海纳百川，有容乃大</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/04/02/coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/02/coroutine/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-02 09:59:05" itemprop="dateCreated datePublished" datetime="2021-04-02T09:59:05+08:00">2021-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-21 17:13:36" itemprop="dateModified" datetime="2021-04-21T17:13:36+08:00">2021-04-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考 <a target="_blank" rel="noopener" href="https://github.com/tnie/learn_chrono">tnie/learn_xxx</a> 中 coro 项目。</p>
<p>如果想看懂 asio 如何支持 <code>co_await</code> 的，想更细致地用好协程，就需要了解更基础（同时也是更复杂的）内容。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.panicsoftware.com/coroutines-introduction/">COROUTINES INTRODUCTION</a>，需要科学上网，PAC 全局</p>
<p>  关键的 <code>__builtin_coro_save()</code> 和 <code>return_to_the_caller()</code> 组合是如何实现功能的呢？作者并没有介绍，系列的三篇文章只是详细地讲解了各个代码定制点以及编译器如何展开并生成样本的代码，却对关键的“如何保存与跳转”只字未提。</p>
<p>  对协程介绍时，先介绍 <code>promise</code> 后 <code>awaitable/awaiter</code>。学习笔记/摘抄，见 coroutine1~4.md</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lewissbaker.github.io/">C++ Coroutines: Understanding operator co_await</a>，特别推荐的几篇文章，作者写了  cppcoro 库，牛人 </p>
<p>  首推，此系列的文章作为入门。 对协程介绍时，先介绍 <code>awaitable/awaiter</code> 后 <code>promise</code>。学习笔记/摘抄，见 coroutine-a~c.md</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://gqw.github.io/blog/2020/10/01/%E4%BB%8Ehellowold%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAc-20-coroutine-ts/">从HelloWold开始，深入浅出C++ 20 Coroutine TS</a></p>
<p>  作者分析了 IDE 生成的汇编语言，介绍了协程“如何保存状态，如何跳转”。可惜我看不懂</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://netcan.github.io/2020/09/05/C-20%E5%8D%8F%E7%A8%8B/">C++20 协程初探</a></p>
<p>  抽空，学习一下他的例子。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://owent.net/2019/1904.html">C++20 Coroutine</a></p>
<p>  作者应该也是小白用户，几个关键点都提到了，但展开得不够，轻重也没区分。罗列概念、罗列代码</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh4ui.net/tags/coroutine/">TAG : COROUTINE</a></p>
<p>  貌似高屋建瓴，但真的就是“乱拳打死老师傅”。有价值，但对小白入门非常不友好，得自行筛选。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/31/coroutine-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/coroutine-c/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 15:31:49" itemprop="dateCreated datePublished" datetime="2021-03-31T15:31:49+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 09:51:42" itemprop="dateModified" datetime="2021-04-02T09:51:42+08:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type</a></p>
<h1 id="Coroutine-Concepts"><a href="#Coroutine-Concepts" class="headerlink" title="Coroutine Concepts"></a>Coroutine Concepts</h1><p>The compiler applies some fairly mechanical transformations to the code that you write to turn it into a state-machine that allows it to suspend execution at particular points within the function and then later resume execution.</p>
<p>编译器会对您编写的代码进行一些相当机械的转换，以将其转换为状态机，使状态机可以在函数内的特定点挂起执行，然后再恢复执行。</p>
<h1 id="Promise-objects"><a href="#Promise-objects" class="headerlink" title="Promise objects"></a>Promise objects</h1><p>The Promise object defines and controls the behaviour of the coroutine itself by implementing methods that are called at specific points during execution of the coroutine.</p>
<blockquote>
<p>Before we go on, I want you to try and rid yourself of any preconceived notions of what a “promise” is. While, in some use-cases, the coroutine promise object does indeed act in a similar role to the <code>std::promise</code> part of a <code>std::future</code> pair, for other use-cases the analogy is somewhat stretched. It may be easier to think about the coroutine’s promise object as being a “coroutine state controller” object that controls the behaviour of the coroutine and can be used to track its state.</p>
<p>在继续之前，我希望您尝试摆脱对“promise”的任何先入为主的观念。虽承然在某些用例中，协程的 promise 对象确实起到了与<code>std :: future</code> 的 <code>std :: promise</code> 部分相似的作用，但在其他用例中，类推却有些捉襟见肘。将协程的 promise 对象视为控制协程行为并可以用来跟踪其状态的“协程状态控制器”对象可能更容易些。</p>
</blockquote>
<p>When you write a coroutine function that has a body, <code>&lt;body-statements&gt;</code>, which contains one of the coroutine keywords (<code>co_return</code>, <code>co_await</code>, <code>co_yield</code>) then the body of the coroutine is transformed to something (roughly) like the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">co_await</span> promise.initial_suspend();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    &lt;body-statements&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    promise.unhandled_exception();</span><br><span class="line">  &#125;</span><br><span class="line">FinalSuspend:</span><br><span class="line">  <span class="keyword">co_await</span> promise.final_suspend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When a coroutine function is called there are a number of steps that are performed prior to executing the code in the source of the coroutine body that are a little different to regular functions.</p>
<p>Here is a summary of the steps (I’ll go into more detail on each of the steps below).</p>
<ol>
<li>Allocate a coroutine frame using <code>operator new</code> (optional).</li>
<li>Copy any function parameters to the coroutine frame.</li>
<li>Call the constructor for the promise object of type, <code>P</code>.</li>
<li>Call the <code>promise.get_return_object()</code> method to obtain the result to return to the caller when the coroutine first suspends. Save the result as a local variable.</li>
<li>Call the <code>promise.initial_suspend()</code> method and <code>co_await</code> the result.</li>
<li>When the <code>co_await promise.initial_suspend()</code> expression resumes (either immediately or asynchronously), then the coroutine starts executing the coroutine body statements that you wrote.</li>
</ol>
<p>Some additional steps are executed when execution reaches a <code>co_return</code> statement:</p>
<ol>
<li>Call <code>promise.return_void()</code> or <code>promise.return_value(&lt;expr&gt;)</code></li>
<li>Destroy all variables with automatic storage duration in reverse order they were created.</li>
<li>Call <code>promise.final_suspend()</code> and <code>co_await</code> the result.</li>
</ol>
<p>If instead, execution leaves <code>&lt;body-statements&gt;</code> due to an unhandled exception then:</p>
<ol>
<li>Catch the exception and call <code>promise.unhandled_exception()</code> from within the catch-block.</li>
<li>Call <code>promise.final_suspend()</code> and <code>co_await</code> the result.</li>
</ol>
<p>Once execution propagates outside of the coroutine body then the coroutine frame is destroyed. Destroying the coroutine frame involves a number of steps:</p>
<ol>
<li>Call the destructor of the promise object.</li>
<li>Call the destructors of the function parameter copies.</li>
<li>Call <code>operator delete</code> to free the memory used by the coroutine frame (optional)</li>
<li>Transfer execution back to the caller/resumer.</li>
</ol>
<p>When execution first reaches a <code>&lt;return-to-caller-or-resumer&gt;</code> point inside a <code>co_await</code> expression, or if the coroutine runs to completion without hitting a <code>&lt;return-to-caller-or-resumer&gt;</code> point, then the coroutine is either suspended or destroyed and the return-object previously returned from the call to <code>promise.get_return_object()</code> is then returned to the caller of the coroutine.</p>
<p>之后，作者就上述步骤进行了详细的介绍。</p>
<h2 id="How-the-compiler-chooses-the-promise-type"><a href="#How-the-compiler-chooses-the-promise-type" class="headerlink" title="How the compiler chooses the promise type"></a>How the compiler chooses the promise type</h2><p>The type of the promise object is determined from the signature of the coroutine by using the <code>std::experimental::coroutine_traits</code> class.</p>
<p>模板类的参数，就是协程函数签名中的返回类型+入参类型。</p>
<p>模板类 <code>coroutine_traits</code> 的默认实现，是使用返回类型的嵌套类型或类型别名：</p>
<p><code>using promise_type = typename RET::promise_type;</code></p>
<p>如果有权限，则在返回值类型中定义嵌套类即可；否则新增 <code>coroutine_traits</code> 特例化。</p>
<h2 id="Identifying-a-specific-coroutine-activation-frame"><a href="#Identifying-a-specific-coroutine-activation-frame" class="headerlink" title="Identifying a specific coroutine activation frame"></a>Identifying a specific coroutine activation frame</h2><p>When you call a coroutine function, a coroutine frame is created. In order to resume the associated coroutine or destroy the coroutine frame you need some way to identify or refer to that particular coroutine frame.</p>
<p>The mechanism the Coroutines TS provides for this is the <code>coroutine_handle</code> type.</p>
<p>You can obtain a coroutine_handle for a coroutine in two ways:</p>
<ol>
<li>It is passed to the <code>await_suspend()</code> method during a <code>co_await</code> expression.</li>
<li>If you have a reference to the coroutine’s promise object, you can reconstruct its coroutine_handle using <code>coroutine_handle&lt;Promise&gt;::from_promise()</code>.</li>
</ol>
<p>Note that the coroutine_handle is <strong>NOT</strong> and RAII object. You must manually call <code>.destroy()</code> to destroy the coroutine frame and free its resources.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/31/coroutine-b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/coroutine-b/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-31 11:57:12 / 修改时间：15:31:39" itemprop="dateCreated datePublished" datetime="2021-03-31T11:57:12+08:00">2021-03-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await</a></p>
<h1 id="What-does-the-Coroutines-TS-give-us"><a href="#What-does-the-Coroutines-TS-give-us" class="headerlink" title="What does the Coroutines TS give us?"></a>What does the Coroutines TS give us?</h1><p>The facilities the C++ Coroutines TS provides in the language can be thought of as a low-level assembly-language for coroutines. These facilities can be difficult to use directly in a safe way and are mainly intended to be used by library-writers to build higher-level abstractions that application developers can work with safely.</p>
<p>C ++ Coroutines TS 提供的功能可以被认为是协程的一种低级汇编语言。这些功能可能很难以安全的方式直接使用，并且主要旨在供库编写人员用来构建更高级的抽象，以便应用程序开发人员可以安全地使用它们。</p>
<h1 id="Compiler-lt-gt-Library-interaction"><a href="#Compiler-lt-gt-Library-interaction" class="headerlink" title="Compiler &lt;-&gt; Library interaction"></a>Compiler &lt;-&gt; Library interaction</h1><p>Instead, it specifies a general mechanism for library code to customise the behaviour of the coroutine by implementing types that conform to a specific interface. The compiler then generates code that calls methods on instances of types provided by the library.</p>
<p>它为库代码指定了一种通用机制，可通过 <em>实现符合特定接口的类型</em> 来自定义协程的行为。然后编译器调用 这些类型的方法 = <em>库提供的类型的实例的方法</em>。</p>
<p>There are two kinds of interfaces that are defined by the coroutines TS: The <strong>Promise</strong> interface and the <strong>Awaitable</strong> interface.</p>
<p>The <strong>Promise</strong> interface specifies methods for customising the behaviour of the coroutine itself. The library-writer is able to customise what happens when the coroutine is called, what happens when the coroutine returns (either by normal means or via an unhandled exception) and customise the behaviour of any <code>co_await</code> or <code>co_yield</code> expression within the coroutine.</p>
<p>用于定义协程的行为。</p>
<p>The <strong>Awaitable</strong> interface specifies methods that control the semantics of a <code>co_await</code> expression. When a value is <code>co_await</code>ed, the code is translated into a series of calls to methods on the awaitable object that allow it to specify: whether to suspend the current coroutine, execute some logic after it has suspended to schedule the coroutine for later resumption, and execute some logic after the coroutine resumes to produce the result of the <code>co_await</code> expression.</p>
<p>控制 <code>co_await</code> 表达式的语义。</p>
<h1 id="Awaiters-and-Awaitables-Explaining-operator-co-await"><a href="#Awaiters-and-Awaitables-Explaining-operator-co-await" class="headerlink" title="Awaiters and Awaitables: Explaining operator co_await"></a>Awaiters and Awaitables: Explaining operator co_await</h1><p>Awaitable has 2 kinds:</p>
<ul>
<li>Normal Awatable : 原生支持 <code>operator co_await()</code></li>
<li>Contextually Awaitable : 原生不支持 <code>operator co_await()</code> , 但在特定的 Promise 上下文中，通过 <code>Promise::await_transform()</code> 转化后，返回值支持 <code>operator co_await()</code></li>
</ul>
<p>An Awaiter type is a type that implements the 3 special methods that are called as part of a <code>co_await</code> expression: </p>
<ul>
<li><code>await_ready()</code></li>
<li><code>await_suspend()</code></li>
<li><code>await_resume()</code></li>
</ul>
<p>Note that a type can be both an Awaitable type and an Awaiter type.</p>
<p>具体到某个类型，是可以同时满足 Awaitable 的 Awaiter 要求的。</p>
<h2 id="Obtaining-the-Awaiter"><a href="#Obtaining-the-Awaiter" class="headerlink" title="Obtaining the Awaiter"></a>Obtaining the Awaiter</h2><p>-&gt; Awaitable -&gt; Awaiter</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有转换就直接用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaitable</span><span class="params">(P&amp; promise, T&amp;&amp; expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_any_await_transform_member_v&lt;P&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> promise.<span class="title">await_transform</span><span class="params">(<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr))</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有操作符方法（成员或全局）就直接用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaiter</span><span class="params">(Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_member_operator_co_await_v&lt;Awaitable&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;<span class="params">(awaitable)</span>.<span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (has_non_member_operator_co_await_v&lt;Awaitable&amp;&amp;&gt;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="keyword">co_await</span>(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Awaiting-the-Awaiter"><a href="#Awaiting-the-Awaiter" class="headerlink" title="Awaiting the Awaiter"></a>Awaiting the Awaiter</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaitable = get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaiter = get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.await_ready())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)));</span><br><span class="line"></span><br><span class="line">    &lt;suspend-coroutine&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_void_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">static_assert</span>(</span><br><span class="line">         <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;,</span><br><span class="line">         <span class="string">&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;resume-point&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is the responsibility of the <code>await_suspend()</code> method to schedule the coroutine for resumption (or destruction) at some point in the future once the operation has completed. Note that returning <code>false</code> from <code>await_suspend()</code> counts as scheduling the coroutine for immediate resumption on the current thread.</p>
<p>The return-value of the <code>await_resume()</code> method call becomes the result of the <code>co_await</code> expression.</p>
<h2 id="Coroutine-Handles"><a href="#Coroutine-Handles" class="headerlink" title="Coroutine Handles"></a>Coroutine Handles</h2><p>其实现可以在 <code>&lt;experimental\resumable&gt;</code> 头文件中找到。</p>
<p>此类型提供的接口中：</p>
<ul>
<li><code>resume()</code> 最常用</li>
<li>避免使用 <code>destroy()</code> 和 <code>.promise()</code>，库作者除外</li>
</ul>
<p>You should generally not need to (and indeed should really avoid) calling <code>.destroy()</code> unless you are a library writer implementing the coroutine promise type. Normally, coroutine frames will be owned by some kind of RAII type returned from the call to the coroutine. So calling <code>.destroy()</code> without cooperation with the RAII object could lead to a double-destruction bug.</p>
<p>The <code>.promise()</code> method returns a reference to the coroutine’s promise object. However, like <code>.destroy()</code>, it is generally only useful if you are authoring coroutine promise types. You should consider the coroutine’s promise object as an internal implementation detail of the coroutine. For most Normally Awaitable types you should use <code>coroutine_handle&lt;void&gt;</code> as the parameter type to the <code>await_suspend()</code> method instead of <code>coroutine_handle&lt;Promise&gt;</code>.</p>
<p>此章节有很多针对库开发者、使用者的建议。</p>
<h1 id="Synchronisation-free-async-code"><a href="#Synchronisation-free-async-code" class="headerlink" title="Synchronisation-free async code"></a>Synchronisation-free async code</h1><p>免同步的异步代码</p>
<h1 id="An-example-Implementing-a-simple-thread-synchronisation-primitive"><a href="#An-example-Implementing-a-simple-thread-synchronisation-primitive" class="headerlink" title="An example: Implementing a simple thread-synchronisation primitive"></a>An example: Implementing a simple thread-synchronisation primitive</h1><p>TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/31/coroutine-a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/coroutine-a/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-31 10:05:34 / 修改时间：11:54:29" itemprop="dateCreated datePublished" datetime="2021-03-31T10:05:34+08:00">2021-03-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">https://lewissbaker.github.io/2017/09/25/coroutine-theory</a></p>
<h1 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h1><p>Coroutines generalise the operations of a function by separating out some of the steps performed in the <strong>Call</strong> and <strong>Return</strong> operations into three <strong>extra</strong> operations: <strong>Suspend</strong>, <strong>Resume</strong> and <strong>Destroy</strong>.</p>
<p>比其他文章多描述了一个 Destroy 步骤，更准确。</p>
<p>Note that, like the Return operation of a function, a coroutine can only be suspended from within the coroutine itself at well-defined suspend-points.</p>
<p>请注意，就像函数的 Return 操作一样，协程只能在定义好的暂停点处从协程自身内部暂停。</p>
<h2 id="Coroutine-activation-frames"><a href="#Coroutine-activation-frames" class="headerlink" title="Coroutine activation frames"></a>Coroutine activation frames</h2><p>With coroutines there are some parts of the activation frame that need to be preserved across coroutine suspension and there are some parts that only need to be kept around while the coroutine is executing. For example, the lifetime of a variable with a scope that does not span any coroutine suspend-points can potentially be stored on the stack.</p>
<p>对于协程，activation frame 的某些部分在协程暂停时需要保留，而 activation frame 的某些部分只有在协程执行时才需要保留。例如，不跨越任何协程暂停点的变量可以潜在地存储在堆栈中。</p>
<p>You can logically think of the activation frame of a coroutine as being comprised of two parts: the ‘coroutine frame’ and the ‘stack frame’.</p>
<p>您可以从逻辑上将协程的 activation frame 想象为由两部分组成：“coroutine frame”和“stack frame”。</p>
<p>The ‘coroutine frame’ holds part of the coroutine’s activation frame that persists while the coroutine is suspended and the ‘stack frame’ part only exists while the coroutine is executing and is freed when the coroutine suspends and transfers execution back to the caller/resumer.</p>
<p>“coroutine frame”保留了协程 activation frame 的一部分，该部分在协程被挂起时仍然存在，而“stack frame”部分仅在协程执行时存在，而在协程挂起并将执行转移回调用者/恢复者时则被释放。</p>
<h2 id="The-‘Suspend’-operation"><a href="#The-‘Suspend’-operation" class="headerlink" title="The ‘Suspend’ operation"></a>The ‘Suspend’ operation</h2><p>Once the coroutine has been prepared for resumption, the coroutine is considered ‘suspended’.</p>
<p>The coroutine then has the opportunity to execute some additional logic before execution is transferred back to the caller/resumer. This additional logic is given access to a handle to the coroutine-frame that can be used to later resume or destroy it.</p>
<p>协程进入暂停状态之后，执行逻辑返还调用者之前，是有机会做些额外操作的：有个句柄可用，以便恢复或销毁协程。</p>
<p>是不是指 awaiter 的 <code>await_suspend()</code> 接口呢？</p>
<h2 id="The-‘Resume’-operation"><a href="#The-‘Resume’-operation" class="headerlink" title="The ‘Resume’ operation"></a>The ‘Resume’ operation</h2><p>When a function wants to resume a coroutine it needs to effectively ‘call’ into the middle of a particular invocation of the function. The way the caller/resumer identifies the particular invocation to resume is by calling the <code>void resume()</code> method on the coroutine-frame handle provided to the corresponding Suspend operation.</p>
<p>恢复协程的方式，是调用 <code>handle.resume()</code>，handle 对象由与之对应的 暂停操作提供。</p>
<h2 id="The-‘Destroy’-operation"><a href="#The-‘Destroy’-operation" class="headerlink" title="The ‘Destroy’ operation"></a>The ‘Destroy’ operation</h2><p>The Destroy operation destroys the coroutine frame without resuming execution of the coroutine.</p>
<p>This operation can only be performed on a suspended coroutine.</p>
<p>Similar to the Resume operation, the Destroy operation identifies the particular activation-frame to destroy by calling the <code>void destroy()</code> method on the coroutine-frame handle provided during the corresponding Suspend operation.</p>
<h2 id="The-‘Call’-operation-of-a-coroutine"><a href="#The-‘Call’-operation-of-a-coroutine" class="headerlink" title="The ‘Call’ operation of a coroutine"></a>The ‘Call’ operation of a coroutine</h2><p>However, rather than execution only returning to the caller when the function has run to completion, with a coroutine the call operation will instead resume execution of the caller when the coroutine reaches its first suspend-point.</p>
<p>但是，不是执行仅在函数运行完成后才返回到调用方，使用协程时，在协程到达其第一个挂起点时，调用操作将恢复调用方的执行。</p>
<p>此时会返给调用方一个变量哦，这个变量一般都会持有协程的句柄</p>
<h2 id="The-‘Return’-operation-of-a-coroutine"><a href="#The-‘Return’-operation-of-a-coroutine" class="headerlink" title="The ‘Return’ operation of a coroutine"></a>The ‘Return’ operation of a coroutine</h2><p>When a coroutine executes a return-statement (<code>co_return</code> according to the TS) operation it stores the return-value somewhere (exactly where this is stored can be customised by the coroutine) and then destructs any in-scope local variables (but not parameters).</p>
<p>The coroutine then has the opportunity to execute some additional logic before transferring execution back to the caller/resumer.</p>
<p>是不是指 <code>promise.return_value()</code> 接口呢？</p>
<p>It is important to note that the return-value passed to the Return operation is not the same as the return-value returned from a Call operation as the return operation may be executed long after the caller resumed from the initial Call operation.</p>
<p>不单单是返回值不同吧？返回类型大概率都不一样啊？</p>
<h1 id="An-illustration"><a href="#An-illustration" class="headerlink" title="An illustration"></a>An illustration</h1><p>Note that the compiler will typically hold the address of the coroutine frame in a separate register to the stack pointer (eg. MSVC stores this in the rbp register).</p>
<p>如何理解“coroutine frame 被存在另一个专用寄存器中”呢？ 这个操作意味着什么？</p>
<p>When the coroutine suspends for the first time, a return-value is returned to the caller. This return value often holds a handle to the coroutine-frame that suspended that can be used to later resume it.</p>
<p>调用者之后就能够使用这个返回值来恢复协程的执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/26/coroutine3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/coroutine3/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 16:38:22" itemprop="dateCreated datePublished" datetime="2021-03-26T16:38:22+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 17:50:56" itemprop="dateModified" datetime="2021-03-30T17:50:56+08:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://blog.panicsoftware.com/co_awaiting-coroutines/">https://blog.panicsoftware.com/co_awaiting-coroutines/</a></p>
<h1 id="Awaitable"><a href="#Awaitable" class="headerlink" title="Awaitable"></a>Awaitable</h1><p>As I have mentioned in the previous posts, the <code>suspend_always</code> and <code>suspend_never</code> are types, that fulfill the <code>Awaitable</code> concept. </p>
<p>We can get the Awaitable object in two ways:</p>
<ul>
<li>Direct creation of Awaitable,</li>
<li>Transformation of the object into Awaitable because of <code>await_transform</code> function.</li>
</ul>
<h1 id="co-await-operator-and-Awaiter"><a href="#co-await-operator-and-Awaiter" class="headerlink" title="co_await operator and Awaiter"></a>co_await operator and Awaiter</h1><p>The <code>co_await</code> operator is actually responsible for two things:</p>
<ul>
<li>Forcing compiler to generate some coroutine boilerplate code</li>
<li>Creating the Awaiter object.</li>
</ul>
<p>So first let’s have a look at how is the awaiter object is created. The <code>co_await</code> operator is responsible for the creation of the awaiter object. The <code>co_await</code> operator declaration is looked upon in the awaitable object and if it’s found this <code>co_await</code> operator is executed to obtain awaiter object. Otherwise, if the appropriate function is not found, then awaitable becomes the awaiter. </p>
<p>Whenever compiler encounters occurrence of the <code>co_await</code> operator it generates the more or less following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::exception_ptr exception = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> a.await_ready()) &#123;</span><br><span class="line">  __builtin_coro_save(); <span class="comment">//suspend_coroutine();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//if await_suspend returns void</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a.await_suspend(coroutine_handle);</span><br><span class="line">    return_to_the_caller();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    exception = <span class="built_in">std</span>::current_exception();</span><br><span class="line">    <span class="keyword">goto</span> resume_point;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//if await_suspend returns bool</span></span><br><span class="line">  <span class="keyword">bool</span> await_suspend_result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    await_suspend_result = a.await_suspend(coroutine_handle);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    exception = <span class="built_in">std</span>::current_exception();</span><br><span class="line">    <span class="keyword">goto</span> resume_point;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">not</span> await_suspend_result)</span><br><span class="line">    <span class="keyword">goto</span> resume_point;</span><br><span class="line">  return_to_the_caller();</span><br><span class="line">  <span class="comment">//endif</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//if await_suspend returns another coroutine_handle</span></span><br><span class="line">  <span class="keyword">decltype</span>(a.await_suspend(<span class="built_in">std</span>::declval&lt;<span class="keyword">coro_handle_t</span>&gt;())) another_coro_handle;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    another_coro_handle = a.await_suspend(coroutine_handle);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    exception = <span class="built_in">std</span>::current_exception();</span><br><span class="line">    <span class="keyword">goto</span> resume_point;</span><br><span class="line">  &#125;</span><br><span class="line">  another_coro_handle.resume();</span><br><span class="line">  return_to_the_caller();</span><br><span class="line">  <span class="comment">//endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resume_point:</span><br><span class="line"><span class="keyword">if</span>(exception)</span><br><span class="line">  <span class="built_in">std</span>::rethrow_exception(exception);</span><br><span class="line"><span class="string">&quot;return&quot;</span> a.await_resume();</span><br></pre></td></tr></table></figure>
<h1 id="Coroutine-suspension"><a href="#Coroutine-suspension" class="headerlink" title="Coroutine suspension"></a>Coroutine suspension</h1><p>Immediately after evaluating <code>await_ready</code> expression the coroutine is suspended (on condition, that <code>await_ready</code> evaluated to <code>false</code>). It doesn’t mean, that control flow returns to the caller. It means that the needed local data is saved (possibly on the heap) to be restored when coroutine is suspended. </p>
<p>作者的此番解释，源于他在上述样本代码中误用 suspend 表达了 save 的概念。 suspend = (save something of coroutine) + (return to the caller)</p>
<p>我在上述样本代码中使用 <code>__builtin_coro_save()</code> 替换了 <code>suspend_coroutine()</code>，前者来源于 <a target="_blank" rel="noopener" href="https://gqw.github.io/blog/2020/10/01/%E4%BB%8Ehellowold%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAc-20-coroutine-ts/">从HelloWold开始，深入浅出C++ 20 Coroutine TS</a>，这篇帖子里的后续的 <code>__builtin_coro_suspend() // jmp </code> 反而不如此处的 <code>return_to_the_caller()</code> 表意明确。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>When looking into the coroutines you will definitely feel (or should feel) that this is not something you want to write as your daily work and you are right! In the future standard library will come with predefined sets of implemented Awaitables, and coroutine types. Once C++20 comes out, make yourself and your friend the pleasure and use cppcoro instead writing your own implementations.</p>
<p>当查看协程时，您肯定会感觉（或应该感觉到）这不是您日常工作中想要写的东西，而且您是对的！将来，标准库将附带已实现的预定义集合以及已实现的协程类型。一旦C ++ 20发布，让您自己和您的朋友感到高兴，并使用cppcoro代替编写您自己的实现。</p>
<p>那么关键的 <code>__builtin_coro_save()</code> 和 <code>return_to_the_caller()</code> 组合是如何实现功能的呢？作者并没有介绍，系列的三篇文章只是详细地讲解了各个代码定制点以及编译器如何展开并生成样本的代码，却对关键的“如何保存与跳转”只字未提。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/26/coroutine4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/coroutine4/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 15:16:54" itemprop="dateCreated datePublished" datetime="2021-03-26T15:16:54+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 16:03:02" itemprop="dateModified" datetime="2021-03-29T16:03:02+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对称协程只是非对称协程的一个特例，我们可以通过添加一个中立的第三方调度中心的方式将非对称协程转换成对称协程（只需要在所有协程“暂停”时将控制权转交给调度中心统一调度即可）。</p>
<p>猜测 asio 得 <code>awaitable&lt;&gt;</code> 和 <code>co_spawn</code> 也是干了这件事</p>
<p><a target="_blank" rel="noopener" href="https://gqw.github.io/blog/2020/10/01/%E4%BB%8Ehellowold%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAc-20-coroutine-ts/">https://gqw.github.io/blog/2020/10/01/%E4%BB%8Ehellowold%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAc-20-coroutine-ts/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">suspend_always</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">suspend_never</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co_await 表达式展开后是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co_await std::experimental::suspend_always&#123;&#125;;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; tmp = <span class="built_in">std</span>::experimental::suspend_always&#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.await_ready()) &#123;</span><br><span class="line">    __builtin_coro_save() <span class="comment">// frame-&gt;suspend_index = m;</span></span><br><span class="line">    <span class="keyword">if</span> (tmp.await_suspend(&lt;coroutine_handle&gt;)) &#123;</span><br><span class="line">      __builtin_coro_suspend() <span class="comment">// jmp </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">resume_label_m:</span><br><span class="line">  tmp.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/26/coroutine2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/coroutine2/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 11:03:50" itemprop="dateCreated datePublished" datetime="2021-03-26T11:03:50+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 16:49:16" itemprop="dateModified" datetime="2021-03-29T16:49:16+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://blog.panicsoftware.com/your-first-coroutine/">https://blog.panicsoftware.com/your-first-coroutine/</a></p>
<p><code>std::future&lt;int&gt; foo();</code></p>
<p>这是个普通函数，还是协程？这是由其具体实现决定的。</p>
<p>If any of those keywords occur in the function, then it becomes a coroutine.</p>
<ul>
<li><code>co_await</code></li>
<li><code>co_return</code></li>
<li><code>co_yield</code></li>
</ul>
<p>So the operator <code>co_await</code> is a unary operator, which takes the <code>Awaitable</code> object as its argument.</p>
<h1 id="Why-do-we-need-to-define-additional-types"><a href="#Why-do-we-need-to-define-additional-types" class="headerlink" title="Why do we need to define additional types?"></a>Why do we need to define additional types?</h1><p>So the object used to communicate with the coroutine is the object of the coroutine’s return type.</p>
<p>我们使用协程的返回值，和协程进行沟通。</p>
<p>If our coroutine is able to suspend, we need to be able to somehow resume it, so our return type needs to have some <code>resume()</code> method.</p>
<p>协程可以暂停，所以协程的返回类型需要有 <code>resume()</code> 等接口。 </p>
<p>How will the resumable object be created (there is no return statement)? Basically, the compiler generates some additional code for the coroutines. Every coroutine function is transformed by the compiler to the form similar to this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise promise;</span><br><span class="line"><span class="keyword">co_await</span> promise.initial_suspend();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// co-routine body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123;</span><br><span class="line">  promise.unhandled_exception(); </span><br><span class="line">&#125;</span><br><span class="line">final_suspend:</span><br><span class="line">  <span class="keyword">co_await</span> promise.final_suspend();</span><br></pre></td></tr></table></figure>
<p>What is more, the resumable object will be created before the <code>initial_suspend</code> through a call to the:</p>
<p><code>promise.get_return_object();</code></p>
<p>So what we need to do is to create the <code>Promise</code> type.</p>
<p>如何创建这个返回对象呢？由编译器生成的样板代码约束我们得实现 <code>Promise</code> 类型，它得包含以下接口：</p>
<ul>
<li><code>resumable get_return_object()</code>    // 创建返回对象</li>
<li><code>auto initial_suspend()</code></li>
<li><code>auto final_suspend()</code></li>
<li><code>void return_void()</code></li>
<li><code>void unhandled_exception()</code></li>
</ul>
<p>Unfortunately, we are not yet ready to define functions of our first promise type. To operate on the coroutine, we need to have some sort of handle to the coroutine, which we will manage. There already is a built-in object for this exact purpose.</p>
<p>如何实现上述接口呢？我们需要某种句柄来管理协程。</p>
<h1 id="The-coroutine-handle"><a href="#The-coroutine-handle" class="headerlink" title="The coroutine_handle"></a>The coroutine_handle</h1><p>The <code>coroutine_handle</code> is an object, that refers to the coroutine’s dynamically allocated state.</p>
<p>很关键的类型，TODO 稍后整理</p>
<h1 id="Deeper-into-promise-type"><a href="#Deeper-into-promise-type" class="headerlink" title="Deeper into promise type."></a>Deeper into promise type.</h1><h2 id="Handling-co-return"><a href="#Handling-co-return" class="headerlink" title="Handling co_return"></a>Handling co_return</h2><p>First of all, if you use <code>co_return</code> keyword without any expression on its right side (or void expression), the compiler generates:</p>
<p><code>promise.return_void(); goto final_suspend;</code></p>
<p>But if there is some non-void expression, the compiler generates a slightly different code:</p>
<p><code>promise.return_value(expression); goto final_suspend;</code></p>
<h2 id="Making-the-use-of-co-yield-operator"><a href="#Making-the-use-of-co-yield-operator" class="headerlink" title="Making the use of co_yield operator"></a>Making the use of co_yield operator</h2><p>Now to implement our promise_type correctly, we need to know what kind of code compiler generates when it encounters the co_yield keyword. And the following snippet shows precisely this.</p>
<p><code>co_await promise.yield_value(expression);</code></p>
<p>So what is missing is the <code>yield_value</code> member function. Also worth to note is, that no <code>co_await</code> keyword appears, but we will be talking about the <code>co_await</code> keyword later on. For now, the knowledge, that <code>co_await</code> + <code>suspend_always</code> suspends the coroutine is enough.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>So as you can see, the coroutines are hard to learn, after all, it’s still not everything about the coroutines since we only touched Awaitables and Awaiter objects. Fortunately because of the level of difficulty the coroutines the coroutines are very flexible.</p>
<p>幸运的是，由于协程的难度，协程非常灵活。</p>
<p>The good thing is that the whole complicated part of this feature is not to be known by the regular C++ developer. In fact, the regular C++ developer should know how to write the body of the coroutine, but not coroutine objects themselves.</p>
<p>好消息是常规C ++开发人员不知道此功能的整个复杂部分。实际上，常规的C ++开发人员应该知道如何编写协程的主体，而不是协程对象本身。</p>
<p>Developers definitely should use already defined coroutines objects from the standard library (which later will come into the standard) or third-party libraries (like cppcoro).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/03/26/coroutine1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/coroutine1/" class="post-title-link" itemprop="url">未命名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 09:10:39" itemprop="dateCreated datePublished" datetime="2021-03-26T09:10:39+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 10:55:16" itemprop="dateModified" datetime="2021-03-31T10:55:16+08:00">2021-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来源：<a target="_blank" rel="noopener" href="https://blog.panicsoftware.com/coroutines-introduction/">https://blog.panicsoftware.com/coroutines-introduction/</a></p>
<p>虽然协程作为重要特性，即将进入 C++ 20，但仍然有很多人吐槽。</p>
<blockquote>
<p> Main complaints were regarding the hardness to understand, lots of customisation points, and possibly not optimal performance due to possibly unoptimised dynamic memory allocations</p>
</blockquote>
<p>主要的抱怨是关于理解起来很难，大量的定制点以及，未优化的动态内存分配可能造成性能的损失。</p>
<p>谷歌的提案存在一些问题，最终被接受的协程方案来自微软。</p>
<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><p>The coroutines already exist in many programming languages, may it be Python or C#. Coroutines provide one more way to create asynchronous code. How this way differs from threads and why do we need a dedicated language feature for coroutines and finally how we can benefit will be explained in this section.</p>
<p>协程和线程有什么不同？为什么我们需要协程的专用语言功能？我们从协程中能获得哪些好处？在这一节会给出答案。</p>
<p>Depending on the environment in which they are used they might be called:</p>
<ul>
<li>stackless coroutines</li>
<li>stackful coroutines</li>
<li>green threads</li>
<li>fibers</li>
<li>goroutines</li>
</ul>
<p>Good news is that stackful coroutines, green threads, fibres, goroutines are the same thing (sometimes used differently).</p>
<h1 id="协程库-vs-语言特性"><a href="#协程库-vs-语言特性" class="headerlink" title="协程库 vs 语言特性"></a>协程库 vs 语言特性</h1><p>实现协程功能的库，都是有栈协程吗？</p>
<p>此章节作者介绍了 Stackful coroutines 的特性和实现。针对 Stackful coroutines 和 Stackless coroutines 做了比较（前者是库，后者是语言特性）。</p>
<h2 id="Stackful-coroutines"><a href="#Stackful-coroutines" class="headerlink" title="Stackful coroutines"></a>Stackful coroutines</h2><p>Fibers or stackful coroutines are, a separate stack, that can be used to process function calls.</p>
<p>First of all, threads and fibers have their own separate stacks.</p>
<p>首先，线程和纤维有自己独立的栈。</p>
<p>每次 suspend 时 frame(on fiber stack) 保留，切回 fram on the thread stack，resume 时再次回到原 frame。—— 理解正确吗？</p>
<h2 id="Stackless-coroutines"><a href="#Stackless-coroutines" class="headerlink" title="Stackless coroutines"></a>Stackless coroutines</h2><p>So first of all, if they do not allocate the memory for the stack, then how do they work? Where goes all the data meant to be stored on the stack in case of the stackful coroutines? The answer is: on the caller’s stack.</p>
<p>无栈协程不是不使用栈：区分于有栈协程单独分配栈存储，无栈协程并不额外分配栈，而是使用调用方的栈。</p>
<p>The secret of stackless coroutines is that they can suspend themselves only from the top-level function.</p>
<p>无栈协程只能在顶层函数暂停执行。</p>
<p>每次 suspend 时 frame 释放掉(pop)，resume 的时候由 coroutine object (as local variable on the caller’s frame) 再次建立 frame。—— 参考 <a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">coroutine-theory</a> 的 The ‘Resume’ operation 章节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/02/18/openwrt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/openwrt/" class="post-title-link" itemprop="url">软路由 OpenWRT</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 11:52:42" itemprop="dateCreated datePublished" datetime="2021-02-18T11:52:42+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-16 16:42:09" itemprop="dateModified" datetime="2021-03-16T16:42:09+08:00">2021-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TODO</p>
<ol start="4">
<li>蓝牙网络连接，什么作用？删掉或禁用有影响吗？</li>
<li>如何自动切换网关</li>
<li>将 共享目录从台式机移到笔记本中，使用网线已经没有带宽限制了。</li>
</ol>
<h1 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows%E9%A0%90%E5%85%88%E5%AE%89%E8%A3%9D%E7%92%B0%E5%A2%83">Windows预先安装环境</a>（英语：Microsoft Windows Preinstallation Environment），简称 Windows PE 或 WinPE，是 Microsoft Windows 的轻量版本。</p>
<p>关于装机的知识，通过 <a target="_blank" rel="noopener" href="http://www.wepe.com.cn/ubook/">微PE优盘使用说明书</a> 可以学习，虽然我们并不购买他家的优盘。以下摘录部分笔记。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/02/18/openwrt/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tnie.github.io/2021/02/02/function-template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
      <meta itemprop="name" content="tnie & ilyw">
      <meta itemprop="description" content="家人是奋斗的初衷，路途艰辛时常思初心。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不积小流，无以成江海">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/02/function-template/" class="post-title-link" itemprop="url">函数模板</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 16:22:31" itemprop="dateCreated datePublished" datetime="2021-02-02T16:22:31+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-16 16:43:26" itemprop="dateModified" datetime="2021-03-16T16:43:26+08:00">2021-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/cpp-code/" itemprop="url" rel="index">
                    <span itemprop="name">cpp-code</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>std::function&lt;&gt;</code> 模板到底是什么？ <a target="_blank" rel="noopener" href="https://github.com/tnie/YDData2/issues/163">YDData2/issue</a>，可以简单理解为对应 C 语言中的函数指针。入参或绑定的参数如果是原始指针或引用时，需要特别注意其生存周期。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2067988/recursive-lambda-functions-in-c11">为什么 <code>function&lt;&gt;</code> 对象递归调用自身不能使用 <code>auto</code>?</a></p>
<p>vc2015 IntelliSence 提示</p>
<blockquote>
<p>使用 <code>auto</code> 类型说明符声明的变量不能出现在其自身的初始值设定项中</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/02/02/function-template/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tnie & ilyw"
      src="https://raw.githubusercontent.com/tnie/MarkdownPhotos/master/Baymax1.jpg">
  <p class="site-author-name" itemprop="name">tnie & ilyw</p>
  <div class="site-description" itemprop="description">家人是奋斗的初衷，路途艰辛时常思初心。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tnie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tnie" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/nie7g" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;nie7g" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tnie & ilyw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>














  

  

</body>
</html>
